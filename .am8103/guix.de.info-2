This is guix.de.info, produced by makeinfo version 6.7 from
guix.de.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 ng0
Copyright © 2016, 2017, 2018, 2019 Jan Nieuwenhuizen
Copyright © 2016 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar

   Es ist Ihnen gestattet, dieses Dokument zu vervielfältigen,
weiterzugeben und/oder zu verändern, unter den Bedingungen der GNU Free
Documentation License, entweder gemäß Version 1.3 der Lizenz oder (nach
Ihrer Option) einer späteren Version, die von der Free Software
Foundation veröffentlicht wurde, ohne unveränderliche Abschnitte, ohne
vorderen Umschlagtext und ohne hinteren Umschlagtext. Eine Kopie der
Lizenz finden Sie im Abschnitt mit dem Titel „GNU Free Documentation
License“.
INFO-DIR-SECTION Systemadministration
START-INFO-DIR-ENTRY
* Guix: (guix.de).           Installierte Software und Systemkonfigurationen
                               verwalten.
* guix package: (guix.de)guix package aufrufen.  Pakete installieren,
                                                   entfernen und
                                                   aktualisieren.
* guix gc: (guix.de)guix gc aufrufen.  Unbenutzten Plattenspeicher wieder
                                         freigeben.
* guix pull: (guix.de)guix pull aufrufen.  Die Liste verfügbarer Pakete
                                             aktualisieren.
* guix system: (guix.de)guix system aufrufen.  Die
                                                 Betriebssystemkonfiguration
                                                 verwalten.
* guix deploy: (guix.de)guix deploy aufrufen.  Betriebssystemkonfigurationen
                                                 entfernter Rechner verwalten.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Softwareentwicklung
START-INFO-DIR-ENTRY
* guix environment: (guix.de)guix environment aufrufen.  Umgebungen für
                                                           Entwickler
                                                           erstellen
* guix build: (guix.de)guix build aufrufen.  Erstellen von Paketen.
* guix pack: (guix.de)guix pack aufrufen.  Bündel aus Binärdateien
                                             erstellen.
END-INFO-DIR-ENTRY


File: guix.de.info,  Node: Der Store,  Next: Ableitungen,  Prev: Erstellungssysteme,  Up: Programmierschnittstelle

6.4 Der Store
=============

Konzeptionell ist der “Store” der Ort, wo Ableitungen nach erfolgreicher
Erstellung gespeichert werden — standardmäßig finden Sie ihn in
‘/gnu/store’. Unterverzeichnisse im Store werden “Store-Objekte” oder
manchmal auch “Store-Pfade” genannt. Mit dem Store ist eine Datenbank
assoziiert, die Informationen enthält wie zum Beispiel, welche
Store-Pfade jeder Store-Pfad jeweils referenziert, und eine Liste,
welche Store-Objekte _gültig_ sind, also Ergebnisse erfolgreicher
Erstellungen sind. Die Datenbank befindet sich in
‘LOCALSTATEDIR/guix/db’, wobei LOCALSTATEDIR das mit ‘--localstatedir’
bei der Ausführung von „configure“ angegebene Zustandsverzeichnis ist,
normalerweise ‘/var’.

   Auf den Store wird _nur_ durch den Daemon im Auftrag seiner Clients
zugegriffen (siehe *note Aufruf des guix-daemon::). Um den Store zu
verändern, verbinden sich Clients über einen Unix-Socket mit dem Daemon,
senden ihm entsprechende Anfragen und lesen dann dessen Antwort — so
etwas nennt sich entfernter Prozeduraufruf (englisch „Remote Procedure
Call“ oder kurz RPC).

     Anmerkung: Benutzer dürfen _niemals_ Dateien in ‘/gnu/store’ direkt
     verändern, sonst wären diese nicht mehr konsistent und die
     Grundannahmen im funktionalen Modell von Guix, dass die Objekte
     unveränderlich sind, wären dahin (siehe *note Einführung::).

     Siehe *note ‘guix gc --verify’: Aufruf von guix gc. für
     Informationen, wie die Integrität des Stores überprüft und nach
     versehentlichen Veränderungen unter Umständen wiederhergestellt
     werden kann.

   Das Modul ‘(guix store)’ bietet Prozeduren an, um sich mit dem Daemon
zu verbinden und entfernte Prozeduraufrufe durchzuführen. Diese werden
im Folgenden beschrieben. Das vorgegebene Verhalten von
‘open-connection’, und daher allen ‘guix’-Befehlen, ist, sich mit dem
lokalen Daemon oder dem an der in der Umgebungsvariablen
‘GUIX_DAEMON_SOCKET’ angegeben URL zu verbinden.

 -- Umgebungsvariable: GUIX_DAEMON_SOCKET
     Ist diese Variable gesetzt, dann sollte ihr Wert ein Dateipfad oder
     eine URI sein, worüber man sich mit dem Daemon verbinden kann. Ist
     der Wert der Pfad zu einer Datei, bezeichnet dieser einen
     Unix-Socket, mit dem eine Verbindung hergestellt werden soll. Ist
     er eine URI, so werden folgende URI-Schemata unterstützt:

     ‘file’
     ‘unix’
          Für Unix-Sockets. ‘file:///var/guix/daemon-socket/socket’ kann
          gleichbedeutend auch als ‘/var/guix/daemon-socket/socket’
          angegeben werden.

     ‘guix’
          Solche URIs benennen Verbindungen über TCP/IP ohne
          Verschlüsselung oder Authentifizierung des entfernten
          Rechners. Die URI muss den Hostnamen, also den Rechnernamen
          des entfernten Rechners, und optional eine Port-Nummer angeben
          (sonst wird als Vorgabe der Port 44146 benutzt):

               guix://master.guix.example.org:1234

          Diese Konfiguration ist für lokale Netzwerke wie etwa in
          Rechen-Clustern geeignet, wo sich nur vertrauenswürdige Knoten
          mit dem Erstellungs-Daemon z.B. unter
          ‘master.guix.example.org’ verbinden können.

          Die Befehlszeilenoption ‘--listen’ von ‘guix-daemon’ kann
          benutzt werden, damit er auf TCP-Verbindungen lauscht (siehe
          *note ‘--listen’: Aufruf des guix-daemon.).

     ‘ssh’
          Mit solchen URIs kann eine Verbindung zu einem entfernten
          Daemon über SSH hergestellt werden. Diese Funktionalität setzt
          Guile-SSH voraus (siehe *note Voraussetzungen::) sowie eine
          funktionierende ‘guile’-Binärdatei, deren Ort im ‘PATH’ der
          Zielmaschine eingetragen ist. Authentisierung über einen
          öffentlichen Schlüssel oder GSSAPI ist möglich. Eine typische
          URL sieht so aus:

               ssh://charlie@guix.example.org:22

          Was ‘guix copy’ betrifft, richtet es sich nach den üblichen
          OpenSSH-Client-Konfigurationsdateien (siehe *note Aufruf von
          guix copy::).

     In Zukunft könnten weitere URI-Schemata unterstützt werden.

          Anmerkung: Die Fähigkeit, sich mit entfernten
          Erstellungs-Daemons zu verbinden, sehen wir als experimentell
          an, Stand 1.1.0.411-5c10d. Bitte diskutieren Sie mit uns
          jegliche Probleme oder Vorschläge, die Sie haben könnten
          (siehe *note Mitwirken::).

 -- Scheme-Prozedur: open-connection [URI] [#:reserve-space? #t]
     Sich mit dem Daemon über den Unix-Socket an URI verbinden (einer
     Zeichenkette). Wenn RESERVE-SPACE? wahr ist, lässt ihn das etwas
     zusätzlichen Speicher im Dateisystem reservieren, damit der
     Müllsammler auch dann noch funktioniert, wenn die Platte zu voll
     wird. Liefert ein Server-Objekt.

     URI nimmt standardmäßig den Wert von ‘%default-socket-path’ an, was
     dem bei der Installation mit dem Aufruf von ‘configure’
     ausgewählten Vorgabeort entspricht, gemäß den
     Befehlszeilenoptionen, mit denen ‘configure’ aufgerufen wurde.

 -- Scheme-Prozedur: close-connection SERVER
     Die Verbindung zum SERVER trennen.

 -- Scheme-Variable: current-build-output-port
     Diese Variable ist an einen SRFI-39-Parameter gebunden, der auf den
     Scheme-Port verweist, an den vom Daemon empfangene
     Erstellungsprotokolle und Fehlerprotokolle geschrieben werden
     sollen.

   Prozeduren, die entfernte Prozeduraufrufe durchführen, nehmen immer
ein Server-Objekt als ihr erstes Argument.

 -- Scheme-Prozedur: valid-path? SERVER PFAD
     Liefert ‘#t’, wenn der PFAD ein gültiges Store-Objekt benennt, und
     sonst ‘#f’ (ein ungültiges Objekt kann auf der Platte gespeichert
     sein, tatsächlich aber ungültig sein, zum Beispiel weil es das
     Ergebnis einer abgebrochenen oder fehlgeschlagenen Erstellung ist).

     Ein ‘&store-protocol-error’-Fehlerzustand wird ausgelöst, wenn der
     PFAD nicht mit dem Store-Verzeichnis als Präfix beginnt
     (‘/gnu/store’).

 -- Scheme-Prozedur: add-text-to-store SERVER NAME TEXT [REFERENZEN]
     Den TEXT im Store in einer Datei namens NAME ablegen und ihren
     Store-Pfad zurückliefern. REFERENZEN ist die Liste der Store-Pfade,
     die der Store-Pfad dann referenzieren soll.

 -- Scheme-Prozedur: build-derivations STORE ABLEITUNGEN [MODUS] Die
          ABLEITUNGEN erstellen (eine Liste von
     ‘<derivation>’-Objekten, ‘.drv’-Dateinamen oder Paaren aus je
     Ableitung und Ausgabe. Dabei gilt der angegebene MODUS — vorgegeben
     ist ‘(build-mode normal)’.

   Es sei erwähnt, dass im Modul ‘(guix monads)’ eine Monade sowie
monadische Versionen obiger Prozeduren angeboten werden, damit an Code,
der auf den Store zugreift, bequemer gearbeitet werden kann (siehe *note
Die Store-Monade::).

   Dieser Abschnitt ist im Moment noch unvollständig.


File: guix.de.info,  Node: Ableitungen,  Next: Die Store-Monade,  Prev: Der Store,  Up: Programmierschnittstelle

6.5 Ableitungen
===============

Systemnahe Erstellungsaktionen sowie die Umgebung, in der selbige
durchzuführen sind, werden durch “Ableitungen” dargestellt. Eine
Ableitung enthält folgende Informationen:

   • Die Ausgaben, die die Ableitung hat. Ableitungen erzeugen
     mindestens eine Datei bzw. ein Verzeichnis im Store, können aber
     auch mehrere erzeugen.

   • Die Eingaben der Ableitung, also Abhängigkeiten zur Zeit ihrer
     Erstellung, die entweder andere Ableitungen oder einfache Dateien
     im Store sind (wie Patches, Erstellungsskripts usw.).

   • Das System, wofür mit der Ableitung erstellt wird, also ihr Ziel —
     z.B. ‘x86_64-linux’.

   • Der Dateiname eines Erstellungsskripts im Store, zusammen mit den
     Argumenten, mit denen es aufgerufen werden soll.

   • Eine Liste zu definierender Umgebungsvariabler.

   Ableitungen ermöglichen es den Clients des Daemons, diesem
Erstellungsaktionen für den Store mitzuteilen. Es gibt davon zwei Arten,
sowohl Darstellungen im Arbeitsspeicher jeweils für Client und Daemon,
als auch Dateien im Store, deren Namen auf ‘.drv’ enden — diese Dateien
werden als “Ableitungspfade” bezeichnet. Ableitungspfade können an die
Prozedur ‘build-derivations’ übergeben werden, damit die darin
niedergeschriebenen Erstellungsaktionen durchgeführt werden (siehe *note
Der Store::).

   Operationen wie das Herunterladen von Dateien und Checkouts von unter
Versionskontrolle stehenden Quelldateien, bei denen der Hash des Inhalts
im Voraus bekannt ist, werden als “Ableitungen mit fester Ausgabe”
modelliert. Anders als reguläre Ableitungen sind die Ausgaben von
Ableitungen mit fester Ausgabe unabhängig von ihren Eingaben — z.B.
liefert das Herunterladen desselben Quellcodes dasselbe Ergebnis
unabhängig davon, mit welcher Methode und welchen Werkzeugen er
heruntergeladen wurde.

   Den Ausgaben von Ableitungen — d.h. Erstellungergebnissen — ist eine
Liste von “Referenzen” zugeordnet, die auch der entfernte Prozeduraufruf
‘references’ oder der Befehl ‘guix gc --references’ liefert (siehe *note
Aufruf von guix gc::). Referenzen sind die Menge der
Laufzeitabhängigkeiten von Erstellungsergebnissen. Referenzen sind eine
Teilmenge der Eingaben von Ableitungen; die Teilmenge wird automatisch
ermittelt, indem der Erstellungsdaemon alle Dateien unter den Ausgaben
nach Referenzen durchsucht.

   Das Modul ‘(guix derivations)’ stellt eine Repräsentation von
Ableitungen als Scheme-Objekte zur Verfügung, zusammen mit Prozeduren,
um Ableitungen zu erzeugen und zu manipulieren. Die am wenigsten
abstrahierte Methode, eine Ableitung zu erzeugen, ist mit der Prozedur
‘derivation’:

 -- Scheme-Prozedur: derivation STORE NAME ERSTELLER ARGUMENTE
          [#:outputs '("out")] [#:hash #f] [#:hash-algo #f]
          [#:recursive? #f] [#:inputs '()] [#:env-vars '()]  [#:system
     (%current-system)] [#:references-graphs #f]  [#:allowed-references
     #f] [#:disallowed-references #f]  [#:leaked-env-vars #f]
     [#:local-build? #f]  [#:substitutable? #t] [#:properties ’()] Eine
     Ableitungen mit den ARGUMENTEn erstellen und das resultierende
     ‘<derivation>’-Objekt liefern.

     Wurden HASH und HASH-ALGO angegeben, wird eine “Ableitung mit
     fester Ausgabe” erzeugt — d.h. eine, deren Ausgabe schon im Voraus
     bekannt ist, wie z.B. beim Herunterladen einer Datei. Wenn des
     Weiteren auch RECURSIVE? wahr ist, darf die Ableitung mit fester
     Ausgabe eine ausführbare Datei oder ein Verzeichnis sein und HASH
     muss die Prüfsumme eines Archivs mit dieser Ausgabe sein.

     Ist REFERENCES-GRAPHS wahr, dann muss es eine Liste von Paaren aus
     je einem Dateinamen und einem Store-Pfad sein. In diesem Fall wird
     der Referenzengraph jedes Store-Pfads in einer Datei mit dem
     angegebenen Namen in der Erstellungsumgebung zugänglich gemacht, in
     einem einfachen Text-Format.

     Ist ALLOWED-REFERENCES ein wahr, muss es eine Liste von
     Store-Objekten oder Ausgaben sein, die die Ausgabe der Ableitung
     referenzieren darf. Ebenso muss DISALLOWED-REFERENCES, wenn es auf
     wahr gesetzt ist, eine Liste von Dingen bezeichnen, die die
     Ausgaben _nicht_ referenzieren dürfen.

     Ist LEAKED-ENV-VARS wahr, muss es eine Liste von Zeichenketten
     sein, die Umgebungsvariable benennen, die aus der Umgebung des
     Daemons in die Erstellungsumgebung überlaufen — ein „Leck“,
     englisch „leak“. Dies kann nur in Ableitungen mit fester Ausgabe
     benutzt werden, also wenn HASH wahr ist. So ein Leck kann zum
     Beispiel benutzt werden, um Variable wie ‘http_proxy’ an
     Ableitungen zu übergeben, die darüber Dateien herunterladen.

     Ist LOCAL-BUILD? wahr, wird die Ableitung als schlechter Kandidat
     für das Auslagern deklariert, der besser lokal erstellt werden
     sollte (siehe *note Auslagern des Daemons einrichten::). Dies
     betrifft kleine Ableitungen, wo das Übertragen der Daten
     aufwendiger als ihre Erstellung ist.

     Ist SUBSTITUTABLE? falsch, wird deklariert, dass für die Ausgabe
     der Ableitung keine Substitute benutzt werden sollen (siehe *note
     Substitute::). Das ist nützlich, wenn Pakete erstellt werden, die
     Details über den Prozessorbefehlssatz des Wirtssystems auslesen.

     PROPERTIES muss eine assoziative Liste enthalten, die
     „Eigenschaften“ der Ableitungen beschreibt. Sie wird genau so, wie
     sie ist, in der Ableitung gespeichert.

Hier ist ein Beispiel mit einem Shell-Skript, das als Ersteller benutzt
wird. Es wird angenommen, dass STORE eine offene Verbindung zum Daemon
ist und BASH auf eine ausführbare Bash im Store verweist:

     (use-modules (guix utils)
                  (guix store)
                  (guix derivations))

     (let ((builder   ; das Ersteller-Bash-Skript in den Store einfügen
             (add-text-to-store store "my-builder.sh"
                                "echo Hallo Welt > $out\n" '())))
       (derivation store "foo"
                   bash `("-e" ,builder)
                   #:inputs `((,bash) (,builder))
                   #:env-vars '(("HOME" . "/homeless"))))
     ⇒ #<derivation /gnu/store/…-foo.drv => /gnu/store/…-foo>

   Wie man sehen kann, ist es umständlich, diese grundlegende Methode
direkt zu benutzen. Natürlich ist es besser, Erstellungsskripts in
Scheme zu schreiben! Am besten schreibt man den Erstellungscode als
„G-Ausdruck“ und übergibt ihn an ‘gexp->derivation’. Mehr Informationen
finden Sie im Abschnitt *note G-Ausdrücke::.

   Doch es gab einmal eine Zeit, zu der ‘gexp->derivation’ noch nicht
existiert hatte und wo das Zusammenstellen von Ableitungen mit
Scheme-Erstellungscode noch mit ‘build-expression->derivation’
bewerkstelligt wurde, was im Folgenden beschrieben wird. Diese Prozedur
gilt als veraltet und man sollte nunmehr die viel schönere Prozedur
‘gexp->derivation’ benutzen.

 -- Scheme-Prozedur: build-expression->derivation STORE NAME AUSDRUCK
           [#:system (%current-system)] [#:inputs '()] [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f]  [#:recursive? #f]
     [#:env-vars ’()] [#:modules ’()]  [#:references-graphs #f]
     [#:allowed-references #f]  [#:disallowed-references #f]
      [#:local-build? #f] [#:substitutable? #t] [#:guile-for-build #f]
     Liefert eine Ableitung, die den Scheme-Ausdruck AUSDRUCK als
     Ersteller einer Ableitung namens NAME ausführt. INPUTS muss die
     Liste der Eingaben enthalten, jeweils als Tupel ‘(Name
     Ableitungspfad Unterableitung)’; wird keine UNTERABLEITUNG
     angegeben, wird ‘"out"’ angenommen. MODULE ist eine Liste der Namen
     von Guile-Modulen im momentanen Suchpfad, die in den Store kopiert,
     kompiliert und zur Verfügung gestellt werden, wenn der AUSDRUCK
     ausgeführt wird — z.B. ‘((guix build utils) (guix build
     gnu-build-system))’.

     Der AUSDRUCK wird in einer Umgebung ausgewertet, in der ‘%outputs’
     an eine Liste von Ausgabe-/Pfad-Paaren gebunden wurde und in der
     ‘%build-inputs’ an eine Liste von Zeichenkette-/Ausgabepfad-Paaren
     gebunden wurde, die aus den INPUTS-Eingaben konstruiert worden ist.
     Optional kann in ENV-VARS eine Liste von Paaren aus Zeichenketten
     stehen, die Name und Wert von für den Ersteller sichtbaren
     Umgebungsvariablen angeben. Der Ersteller terminiert, indem er
     ‘exit’ mit dem Ergebnis des AUSDRUCKs aufruft; wenn also der
     AUSDRUCK den Wert ‘#f’ liefert, wird angenommen, dass die
     Erstellung fehlgeschlagen ist.

     AUSDRUCK wird mit einer Ableitung GUILE-FOR-BUILD erstellt. Wird
     kein GUILE-FOR-BUILD angegeben oder steht es auf ‘#f’, wird
     stattdessen der Wert der Fluiden ‘%guile-for-build’ benutzt.

     Siehe die Erklärungen zur Prozedur ‘derivation’ für die Bedeutung
     von REFERENCES-GRAPHS, ALLOWED-REFERENCES, DISALLOWED-REFERENCES,
     LOCAL-BUILD? und SUBSTITUTABLE?.

Hier ist ein Beispiel einer Ableitung mit nur einer Ausgabe, die ein
Verzeichnis erzeugt, in dem eine einzelne Datei enthalten ist:

     (let ((builder '(let ((out (assoc-ref %outputs "out")))
                       (mkdir out)    ; das Verzeichnis
                                      ; /gnu/store/…-goo erstellen
                       (call-with-output-file (string-append out "/test")
                         (lambda (p)
                           (display '(Hallo Guix) p))))))
       (build-expression->derivation store "goo" builder))

     ⇒ #<derivation /gnu/store/…-goo.drv => …>


File: guix.de.info,  Node: Die Store-Monade,  Next: G-Ausdrücke,  Prev: Ableitungen,  Up: Programmierschnittstelle

6.6 Die Store-Monade
====================

Die auf dem Store arbeitenden Prozeduren, die in den vorigen Abschnitten
beschrieben wurden, nehmen alle eine offene Verbindung zum
Erstellungs-Daemon als ihr erstes Argument entgegen. Obwohl das ihnen zu
Grunde liegende Modell funktional ist, weisen sie doch alle
Nebenwirkungen auf oder hängen vom momentanen Zustand des Stores ab.

   Ersteres ist umständlich, weil die Verbindung zum Erstellungs-Daemon
zwischen all diesen Funktionen durchgereicht werden muss, so dass eine
Komposition mit Funktionen ohne diesen Parameter unmöglich wird.
Letzteres kann problematisch sein, weil Operationen auf dem Store
Nebenwirkungen und/oder Abhängigkeiten von externem Zustand haben und
ihre Ausführungsreihenfolge deswegen eine Rolle spielt.

   Hier kommt das Modul ‘(guix monads)’ ins Spiel. Im Rahmen dieses
Moduls können “Monaden” benutzt werden und dazu gehört insbesondere eine
für unsere Zwecke sehr nützliche Monade, die “Store-Monade”. Monaden
sind ein Konstrukt, mit dem zwei Dinge möglich sind: eine Assoziation
von Werten mit einem „Kontext“ (in unserem Fall ist das die Verbindung
zum Store) und das Festlegen einer Reihenfolge für Berechnungen (hiermit
sind auch Zugriffe auf den Store gemeint). Werte in einer Monade —
solche, die mit weiterem Kontext assoziiert sind — werden “monadische
Werte” genannt; Prozeduren, die solche Werte liefern, heißen “monadische
Prozeduren”.

   Betrachten Sie folgende „normale“ Prozedur:

     (define (sh-symlink store)
       ;; Eine Ableitung liefern, die mit der ausführbaren Datei „bash“
       ;; symbolisch verknüpft.
       (let* ((drv (package-derivation store bash))
              (out (derivation->output-path drv))
              (sh  (string-append out "/bin/bash")))
         (build-expression->derivation store "sh"
                                       `(symlink ,sh %output))))

   Unter Verwendung von ‘(guix monads)’ und ‘(guix gexp)’ lässt sie sich
als monadische Funktion aufschreiben:

     (define (sh-symlink)
       ;; Ebenso, liefert aber einen monadischen Wert.
       (mlet %store-monad ((drv (package->derivation bash)))
         (gexp->derivation "sh"
                           #~(symlink (string-append #$drv "/bin/bash")
                                      #$output))))

   An der zweiten Version lassen sich mehrere Dinge beobachten: Der
Parameter ‘Store’ ist jetzt implizit geworden und wurde in die Aufrufe
der monadischen Prozeduren ‘package->derivation’ und ‘gexp->derivation’
„eingefädelt“ und der von ‘package->derivation’ gelieferte monadische
Wert wurde mit ‘mlet’ statt einem einfachen ‘let’ “gebunden”.

   Wie sich herausstellt, muss man den Aufruf von ‘package->derivation’
nicht einmal aufschreiben, weil er implizit geschieht, wie wir später
sehen werden (siehe *note G-Ausdrücke::):

     (define (sh-symlink)
       (gexp->derivation "sh"
                         #~(symlink (string-append #$bash "/bin/bash")
                                    #$output)))

   Die monadische ‘sh-symlink’ einfach aufzurufen, bewirkt nichts. Wie
jemand einst sagte: „Mit einer Monade geht man um, wie mit Gefangenen,
gegen die man keine Beweise hat: Man muss sie laufen lassen.“ Um also
aus der Monade auszubrechen und die gewünschte Wirkung zu erzielen, muss
man ‘run-with-store’ benutzen:

     (run-with-store (open-connection) (sh-symlink))
     ⇒ /gnu/store/…-sh-symlink

   Erwähnenswert ist, dass das Modul ‘(guix monad-repl)’ die REPL von
Guile um neue „Meta-Befehle“ erweitert, mit denen es leichter ist, mit
monadischen Prozeduren umzugehen: ‘run-in-store’ und
‘enter-store-monad’. Mit Ersterer wird ein einzelner monadischer Wert
durch den Store „laufen gelassen“:

     scheme@(guile-user)> ,run-in-store (package->derivation hello)
     $1 = #<derivation /gnu/store/…-hello-2.9.drv => …>

   Mit Letzterer wird rekursiv eine weitere REPL betreten, in der alle
Rückgabewerte automatisch durch den Store laufen gelassen werden:

     scheme@(guile-user)> ,enter-store-monad
     store-monad@(guile-user) [1]> (package->derivation hello)
     $2 = #<derivation /gnu/store/…-hello-2.9.drv => …>
     store-monad@(guile-user) [1]> (text-file "foo" "Hallo!")
     $3 = "/gnu/store/…-foo"
     store-monad@(guile-user) [1]> ,q
     scheme@(guile-user)>

Beachten Sie, dass in einer ‘store-monad’-REPL keine nicht-monadischen
Werte zurückgeliefert werden können.

   Die wichtigsten syntaktischen Formen, um mit Monaden im Allgemeinen
umzugehen, werden im Modul ‘(guix monads)’ bereitgestellt und sind im
Folgenden beschrieben.

 -- Scheme-Syntax: with-monad MONADE RUMPF ...
     Alle ‘>>=’- oder ‘return’-Formen im RUMPF in der MONADE auswerten.

 -- Scheme-Syntax: return WERT
     Einen monadischen Wert liefern, der den übergebenen WERT kapselt.

 -- Scheme-Syntax: >>= MWERT MPROZ ...
     Den monadischen Wert MWERT “binden”, wobei sein „Inhalt“ an die
     monadischen Prozeduren MPROZ… übergeben wird(1). Es kann eine
     einzelne MPROZ oder mehrere davon geben, wie in diesem Beispiel:

          (run-with-state
              (with-monad %state-monad
                (>>= (return 1)
                     (lambda (x) (return (+ 1 x)))
                     (lambda (x) (return (* 2 x)))))
            'irgendein-Zustand)

          ⇒ 4
          ⇒ irgendein-Zustand

 -- Scheme-Syntax: mlet MONADE ((VARIABLE MWERT) ...) RUMPF ...
 -- Scheme-Syntax: mlet* MONADE ((VARIABLE MWERT) ...) RUMPF ... Die
          VARIABLEn an die monadischen Werte MWERT im
     RUMPF binden, der eine Folge von Ausdrücken ist. Wie beim
     bind-Operator kann man es sich vorstellen als „Auspacken“ des
     rohen, nicht-monadischen Werts, der im MWERT steckt, wobei
     anschließend dieser rohe, nicht-monadische Wert im
     Sichtbarkeitsbereich des RUMPFs von der VARIABLEn bezeichnet wird.
     Die Form (VARIABLE -> WERT) bindet die VARIABLE an den „normalen“
     WERT, wie es ‘let’ tun würde. Die Bindungsoperation geschieht in
     der Reihenfolge von links nach rechts. Der letzte Ausdruck des
     RUMPFS muss ein monadischer Ausdruck sein und dessen Ergebnis wird
     das Ergebnis von ‘mlet’ oder ‘mlet*’ werden, wenn es durch die
     MONAD laufen gelassen wurde.

     ‘mlet*’ verhält sich gegenüber ‘mlet’ wie ‘let*’ gegenüber ‘let’
     (siehe *note (guile)Local Bindings::).

 -- Scheme-System: mbegin MONADE MAUSDRUCK ...
     Der Reihe nach den MAUSDRUCK und die nachfolgenden monadischen
     Ausdrücke binden und als Ergebnis das des letzten Ausdrucks
     liefern. Jeder Ausdruck in der Abfolge muss ein monadischer
     Ausdruck sein.

     Dies verhält sich ähnlich wie ‘mlet’, außer dass die Rückgabewerte
     der monadischen Prozeduren ignoriert werden. In diesem Sinn verhält
     es sich analog zu ‘begin’, nur auf monadischen Ausdrücken.

 -- Scheme-System: mwhen BEDINGUNG MAUSDR0 MAUSDR* ...
     Wenn die BEDINGUNG wahr ist, wird die Folge monadischer Ausdrücke
     MAUSDR0..MAUSDR* wie bei ‘mbegin’ ausgewertet. Wenn die BEDINGUNG
     falsch ist, wird ‘*unspecified*’ („unbestimmt“) in der momentanen
     Monade zurückgeliefert. Jeder Ausdruck in der Folge muss ein
     monadischer Ausdruck sein.

 -- Scheme-System: munless BEDINGUNG MAUSDR0 MAUSDR* ...
     Wenn die BEDINGUNG falsch ist, wird die Folge monadischer Ausdrücke
     MAUSDR0..MAUSDR* wie bei ‘mbegin’ ausgewertet. Wenn die BEDINGUNG
     wahr ist, wird ‘*unspecified*’ („unbestimmt“) in der momentanen
     Monade zurückgeliefert. Jeder Ausdruck in der Folge muss ein
     monadischer Ausdruck sein.

   Das Modul ‘(guix monads)’ macht die “Zustandsmonade” (englisch „state
monad“) verfügbar, mit der ein zusätzlicher Wert — der Zustand — durch
die monadischen Prozeduraufrufe _gefädelt_ werden kann.

 -- Scheme-Variable: %state-monad
     Die Zustandsmonade. Prozeduren in der Zustandsmonade können auf den
     gefädelten Zustand zugreifen und ihn verändern.

     Betrachten Sie das folgende Beispiel. Die Prozedur ‘Quadrat’
     liefert einen Wert in der Zustandsmonade zurück. Sie liefert das
     Quadrat ihres Arguments, aber sie inkrementiert auch den momentanen
     Zustandswert:

          (define (Quadrat x)
            (mlet %state-monad ((Anzahl (current-state)))
              (mbegin %state-monad
                (set-current-state (+ 1 Anzahl))
                (return (* x x)))))

          (run-with-state (sequence %state-monad (map Quadrat (iota 3))) 0)
          ⇒ (0 1 4)
          ⇒ 3

     When “run” through ‘%state-monad’, we obtain that additional state
     value, which is the number of ‘square’ calls.

 -- Monadische Prozedur: current-state
     Liefert den momentanen Zustand als einen monadischen Wert.

 -- Monadische Prozedur: set-current-state WERT
     Setzt den momentanen Zustand auf WERT und liefert den vorherigen
     Zustand als einen monadischen Wert.

 -- Monadische Prozedur: state-push WERT
     Hängt den WERT vorne an den momentanen Zustand an, der eine Liste
     sein muss. Liefert den vorherigen Zustand als monadischen Wert.

 -- Monadische Prozedur: state-pop
     Entfernt einen Wert vorne vom momentanen Zustand und liefert ihn
     als monadischen Wert zurück. Dabei wird angenommen, dass es sich
     beim Zustand um eine Liste handelt.

 -- Scheme-Prozedur: run-with-state MWERT [ZUSTAND]
     Den monadischen Wert MWERT mit ZUSTAND als initialem Zustand laufen
     lassen. Dies liefert zwei Werte: den Ergebniswert und den
     Ergebniszustand.

   Die zentrale Schnittstelle zur Store-Monade, wie sie vom Modul ‘(guix
store)’ angeboten wird, ist die Folgende:

 -- Scheme-Variable: %store-monad
     The store monad—an alias for ‘%state-monad’.

     Werte in der Store-Monade kapseln Zugriffe auf den Store. Sobald
     ihre Wirkung gebraucht wird, muss ein Wert der Store-Monade
     „ausgewertet“ werden, indem er an die Prozedur ‘run-with-store’
     übergeben wird (siehe unten).

 -- Scheme-Prozedur: run-with-store STORE MWERT [#:guile-for-build]
          [#:system (%current-system)]
     Den MWERT, einen monadischen Wert in der Store-Monade, in der
     offenen Verbindung STORE laufen lassen.

 -- Monadische Prozedur: text-file NAME TEXT [REFERENZEN]
     Als monadischen Wert den absoluten Dateinamen im Store für eine
     Datei liefern, deren Inhalt der der Zeichenkette TEXT ist.
     REFERENZEN ist dabei eine Liste von Store-Objekten, die die
     Ergebnis-Textdatei referenzieren wird; der Vorgabewert ist die
     leere Liste.

 -- Monadische Prozedur: binary-file NAME DATEN [REFERENZEN]
     Den absoluten Dateinamen im Store als monadischen Wert für eine
     Datei liefern, deren Inhalt der des Byte-Vektors DATEN ist.
     REFERENZEN ist dabei eine Liste von Store-Objekten, die die
     Ergebnis-Binärdatei referenzieren wird; der Vorgabewert ist die
     leere Liste.

 -- Monadische Prozedur: interned-file DATEI [NAME] [#:recursive? #t]
          [#:select? (const #t)] Liefert den Namen der DATEI,
     nachdem sie in den Store interniert wurde. Dabei wird der NAME als
     ihr Store-Name verwendet, oder, wenn kein NAME angegeben wurde, der
     Basisname der DATEI.

     Ist RECURSIVE? wahr, werden in der DATEI enthaltene Dateien
     rekursiv hinzugefügt; ist die DATEI eine flache Datei und
     RECURSIVE? ist wahr, wird ihr Inhalt in den Store eingelagert und
     ihre Berechtigungs-Bits übernommen.

     Steht RECURSIVE? auf wahr, wird ‘(SELECT? DATEI STAT)’ für jeden
     Verzeichniseintrag aufgerufen, wobei DATEI der absolute Dateiname
     und STAT das Ergebnis von ‘lstat’ ist, außer auf den Einträgen, wo
     SELECT? keinen wahren Wert liefert.

     Folgendes Beispiel fügt eine Datei unter zwei verschiedenen Namen
     in den Store ein:

          (run-with-store (open-connection)
            (mlet %store-monad ((a (interned-file "README"))
                                (b (interned-file "README" "LEGU-MIN")))
              (return (list a b))))

          ⇒ ("/gnu/store/rwm…-README" "/gnu/store/44i…-LEGU-MIN")

   Das Modul ‘(guix packages)’ exportiert die folgenden paketbezogenen
monadischen Prozeduren:

 -- Monadische Prozedur: package-file PAKET [DATEI] [#:system
          (%current-system)] [#:target #f]  [#:output "out"] Liefert als
     monadischen Wert den absoluten Dateinamen der DATEI innerhalb des
     Ausgabeverzeichnisses OUTPUT des PAKETs. Wird keine DATEI
     angegeben, wird der Name des Ausgabeverzeichnisses OUTPUT für das
     PAKET zurückgeliefert. Ist TARGET wahr, wird sein Wert als das
     Zielsystem bezeichnendes Tripel zum Cross-Kompilieren benutzt.

 -- Monadische Prozedur: package->derivation PAKET [SYSTEM]
 -- Monadische Prozedur: package->cross-derivation PAKET ZIEL [SYSTEM]
          Monadische Version von ‘package-derivation’
     und ‘package-cross-derivation’ (siehe *note Pakete definieren::).

   ---------- Footnotes ----------

   (1) Diese Operation wird gemeinhin „bind“ genannt, aber mit diesem
Begriff wird in Guile eine völlig andere Prozedur bezeichnet, die nichts
damit zu tun hat. Also benutzen wir dieses etwas kryptische Symbol als
Erbe der Haskell-Programmiersprache.


File: guix.de.info,  Node: G-Ausdrücke,  Next: Aufruf von guix repl,  Prev: Die Store-Monade,  Up: Programmierschnittstelle

6.7 G-Ausdrücke
===============

Es gibt also „Ableitungen“, die eine Abfolge von Erstellungsaktionen
repräsentieren, die durchgeführt werden müssen, um ein Objekt im Store
zu erzeugen (siehe *note Ableitungen::). Diese Erstellungsaktionen
werden durchgeführt, nachdem der Daemon gebeten wurde, die Ableitungen
tatsächlich zu erstellen; dann führt der Daemon sie in einer isolierten
Umgebung (einem sogenannten Container) aus (siehe *note Aufruf des
guix-daemon::).

   Wenig überraschend ist, dass wir diese Erstellungsaktionen gerne in
Scheme schreiben würden. Wenn wir das tun, bekommen wir zwei
verschiedene “Schichten” von Scheme-Code(1): den „wirtsseitigen Code“
(„host code“) — also Code, der Pakete definiert, mit dem Daemon
kommuniziert etc. — und den „erstellungsseitigen Code“ („build code“) —
also Code, der die Erstellungsaktionen auch wirklich umsetzt, indem
Dateien erstellt werden, ‘make’ aufgerufen wird etc.

   Um eine Ableitung und ihre Erstellungsaktionen zu beschreiben, muss
man normalerweise erstellungsseitigen Code im wirtsseitigen Code
einbetten. Das bedeutet, man behandelt den erstellungsseitigen Code als
Daten, was wegen der Homoikonizität von Scheme — dass Code genauso als
Daten repräsentiert werden kann — sehr praktisch ist. Doch brauchen wir
hier mehr als nur den normalen Quasimaskierungsmechanismus mit
‘quasiquote’ in Scheme, wenn wir Erstellungsausdrücke konstruieren
möchten.

   Das Modul ‘(guix gexp)’ implementiert “G-Ausdrücke”, eine Form von
S-Ausdrücken, die zu Erstellungsausdrücken angepasst wurden. G-Ausdrücke
(englisch „G-expressions“, kurz “Gexps”) setzen sich grundlegend aus
drei syntaktischen Formen zusammen: ‘gexp’, ‘ungexp’ und
‘ungexp-splicing’ (alternativ einfach: ‘#~’, ‘#$’ und ‘#$@’), die
jeweils mit ‘quasiquote’, ‘unquote’ und ‘unquote-splicing’ vergleichbar
sind (siehe *note ‘quasiquote’: (guile)Expression Syntax.). Es gibt aber
auch erhebliche Unterschiede:

   • G-Ausdrücke sind dafür gedacht, in eine Datei geschrieben zu
     werden, wo sie von anderen Prozessen ausgeführt oder manipuliert
     werden können.

   • Wenn ein abstraktes Objekt wie ein Paket oder eine Ableitung
     innerhalb eines G-Ausdrucks demaskiert wird, ist das Ergebnis davon
     dasselbe, wie wenn dessen Ausgabedateiname genannt worden wäre.

   • G-Ausdrücke tragen Informationen über die Pakete oder Ableitungen
     mit sich, auf die sie sich beziehen, und diese Abhängigkeiten
     werden automatisch zu den sie benutzenden Erstellungsprozessen als
     Eingaben hinzugefügt.

   Dieser Mechanismus ist nicht auf Pakete und Ableitung beschränkt: Es
können “Compiler” definiert werden, die weitere abstrakte,
hochsprachliche Objekte auf Ableitungen oder Dateien im Store
„herunterbrechen“, womit diese Objekte dann auch in G-Ausdrücken
eingefügt werden können. Zum Beispiel sind „dateiartige Objekte“ ein
nützlicher Typ solcher abstrakter Objekte. Mit ihnen können Dateien
leicht in den Store eingefügt und von Ableitungen und anderem
referenziert werden (siehe unten ‘local-file’ und ‘plain-file’).

   Zur Veranschaulichung dieser Idee soll uns dieses Beispiel eines
G-Ausdrucks dienen:

     (define build-exp
       #~(begin
           (mkdir #$output)
           (chdir #$output)
           (symlink (string-append #$coreutils "/bin/ls")
                    "list-files")))

   Indem wir diesen G-Ausdruck an ‘gexp->derivation’ übergeben, bekommen
wir eine Ableitung, die ein Verzeichnis mit genau einer symbolischen
Verknüpfung auf ‘/gnu/store/…-coreutils-8.22/bin/ls’ erstellt:

     (gexp->derivation "das-ding" build-exp)

   Wie man es erwarten würde, wird die Zeichenkette
‘"/gnu/store/…-coreutils-8.22"’ anstelle der Referenzen auf das Paket
COREUTILS im eigentlichen Erstellungscode eingefügt und COREUTILS
automatisch zu einer Eingabe der Ableitung gemacht. Genauso wird auch
‘#$output’ (was äquivalent zur Schreibweise ‘(ungexp output)’ ist)
ersetzt durch eine Zeichenkette mit dem Namen der Ausgabe der Ableitung.

   Im Kontext der Cross-Kompilierung bietet es sich an, zwischen
Referenzen auf die _native_ Erstellung eines Pakets — also der, die auf
dem Wirtssystem ausgeführt werden kann — und Referenzen auf
Cross-Erstellungen eines Pakets zu unterscheiden. Hierfür spielt ‘#+’
dieselbe Rolle wie ‘#$’, steht aber für eine Referenz auf eine native
Paketerstellung.

     (gexp->derivation "vi"
        #~(begin
            (mkdir #$output)
            (mkdir (string-append #$output "/bin"))
            (system* (string-append #+coreutils "/bin/ln")
                     "-s"
                     (string-append #$emacs "/bin/emacs")
                     (string-append #$output "/bin/vi")))
        #:target "mips64el-linux-gnu")

Im obigen Beispiel wird die native Erstellung der COREUTILS benutzt,
damit ‘ln’ tatsächlich auf dem Wirtssystem ausgeführt werden kann, aber
danach die cross-kompilierte Erstellung von EMACS referenziert.

   Eine weitere Funktionalität von G-Ausdrücken stellen “importierte
Module” dar. Manchmal will man bestimmte Guile-Module von der
„wirtsseitigen Umgebung“ im G-Ausdruck benutzen können, deswegen sollten
diese Module in die „erstellungsseitige Umgebung“ importiert werden. Die
‘with-imported-modules’-Form macht das möglich:

     (let ((build (with-imported-modules '((guix build utils))
                    #~(begin
                        (use-modules (guix build utils))
                        (mkdir-p (string-append #$output "/bin"))))))
       (gexp->derivation "leeres-Verzeichnis"
                         #~(begin
                             #$build
                             (display "Erfolg!\n")
                             #t)))

In diesem Beispiel wird das Modul ‘(guix build utils)’ automatisch in
die isolierte Erstellungsumgebung unseres G-Ausdrucks geholt, so dass
‘(use-modules (guix build utils))’ wie erwartet funktioniert.

   Normalerweise möchten Sie, dass der _Abschluss_ eines Moduls
importiert wird — also das Modul und alle Module, von denen es abhängt —
statt nur das Modul selbst. Ansonsten scheitern Versuche, das Modul zu
benutzen, weil seine Modulabhängigkeiten fehlen. Die Prozedur
‘source-module-closure’ berechnet den Abschluss eines Moduls, indem es
den Kopf seiner Quelldatei analysiert, deswegen schafft die Prozedur
hier Abhilfe:

     (use-modules (guix modules))   ;„source-module-closure“ verfügbar machen

     (with-imported-modules (source-module-closure
                              '((guix build utils)
                                (gnu build vm)))
       (gexp->derivation "etwas-mit-vm"
                         #~(begin
                             (use-modules (guix build utils)
                                          (gnu build vm))
                             …)))

   Auf die gleiche Art können Sie auch vorgehen, wenn Sie nicht bloß
reine Scheme-Module importieren möchten, sondern auch „Erweiterungen“
wie Guile-Anbindungen von C-Bibliotheken oder andere „vollumfängliche“
Pakete. Sagen wir, Sie bräuchten das Paket ‘guile-json’ auf der
Erstellungsseite, dann könnten Sie es hiermit bekommen:

     (use-modules (gnu packages guile))  ;für „guile-json“

     (with-extensions (list guile-json)
       (gexp->derivation "etwas-mit-json"
                         #~(begin
                             (use-modules (json))
                             …)))

   Die syntaktische Form, in der G-Ausdrücke konstruiert werden, ist im
Folgenden zusammengefasst.

 -- Scheme-Syntax: #~AUSDRUCK
 -- Scheme-Syntax: (gexp AUSDRUCK)
     Liefert einen G-Ausdruck, der den AUSDRUCK enthält. Der AUSDRUCK
     kann eine oder mehrere der folgenden Formen enthalten:

     ‘#$OBJEKT’
     ‘(ungexp OBJEKT)’
          Eine Referenz auf das OBJEKT einführen. Das OBJEKT kann einen
          der unterstützten Typen haben, zum Beispiel ein Paket oder
          eine Ableitung, so dass die ‘ungexp’-Form durch deren
          Ausgabedateiname ersetzt wird — z.B.
          ‘"/gnu/store/…-coreutils-8.22’.

          Wenn das OBJEKT eine Liste ist, wird diese durchlaufen und
          alle unterstützten Objekte darin auf diese Weise ersetzt.

          Wenn das OBJEKT ein anderer G-Ausdruck ist, wird sein Inhalt
          eingefügt und seine Abhängigkeiten zu denen des äußeren
          G-Ausdrucks hinzugefügt.

          Wenn das OBJEKT eine andere Art von Objekt ist, wird es so wie
          es ist eingefügt.

     ‘#$OBJEKT:AUSGABE’
     ‘(ungexp OBJEKT AUSGABE)’
          Dies verhält sich wie die Form oben, bezieht sich aber
          ausdrücklich auf die angegebene AUSGABE des OBJEKTs — dies ist
          nützlich, wenn das OBJEKT mehrere Ausgaben generiert (siehe
          *note Pakete mit mehreren Ausgaben.::).

     ‘#+OBJEKT’
     ‘#+OBJEKT:AUSGABE’
     ‘(ungexp-native OBJEKT)’
     ‘(ungexp-native OBJEKT AUSGABE)’
          Das Gleiche wie ‘ungexp’, jedoch wird im Kontext einer
          Cross-Kompilierung eine Referenz auf die _native_ Erstellung
          des OBJEKTs eingefügt.

     ‘#$output[:AUSGABE]’
     ‘(ungexp output [AUSGABE])’
          Fügt eine Referenz auf die angegebene AUSGABE dieser Ableitung
          ein, oder auf die Hauptausgabe, wenn keine AUSGABE angegeben
          wurde.

          Dies ist nur bei G-Ausdrücken sinnvoll, die an
          ‘gexp->derivation’ übergeben werden.

     ‘#$@LISTE’
     ‘(ungexp-splicing LISTE)’
          Das Gleiche wie oben, jedoch wird nur der Inhalt der LISTE in
          die äußere Liste eingespleißt.

     ‘#+@LISTE’
     ‘(ungexp-native-splicing LISTE)’
          Das Gleiche, aber referenziert werden native Erstellungen der
          Objekte in der LISTE.

     G-Ausdrücke, die mit ‘gexp’ oder ‘#~’ erzeugt wurden, sind zur
     Laufzeit Objekte vom Typ ‘gexp?’ (siehe unten).

 -- Scheme-Syntax: with-imported-modules MODULE RUMPF…
     Markiert die in RUMPF… definierten G-Ausdrücke, dass sie in ihrer
     Ausführungsumgebung die angegebenen MODULE brauchen.

     Jedes Objekt unter den MODULEn kann der Name eines Moduls wie
     ‘(guix build utils)’ sein, oder es kann nacheinander ein Modulname,
     ein Pfeil und ein dateiartiges Objekt sein:

          `((guix build utils)
            (guix gcrypt)
            ((guix config) => ,(scheme-file "config.scm"
                                            #~(define-module …))))

     Im Beispiel oben werden die ersten beiden Module vom Suchpfad
     genommen und das letzte aus dem angegebenen dateiartigen Objekt
     erzeugt.

     Diese Form hat einen _lexikalischen_ Sichtbarkeitsbereich: Sie
     wirkt sich auf die direkt in RUMPF… definierten G-Ausdrücke aus,
     aber nicht auf jene, die, sagen wir, in aus RUMPF… heraus
     aufgerufenen Prozeduren definiert wurden.

 -- Scheme-Syntax: with-extensions ERWEITERUNGEN RUMPF…
     Markiert die in RUMPF… definierten G-Ausdrücke, dass sie
     ERWEITERUNGEN in ihrer Erstellungs- und Ausführungsumgebung
     benötigen. ERWEITERUNGEN sind typischerweise eine Liste von
     Paketobjekten wie zum Beispiel die im Modul ‘(gnu packages guile)’
     definierten.

     Konkret werden die unter den ERWEITERUNGEN aufgeführten Pakete zum
     Ladepfad hinzugefügt, während die in RUMPF… aufgeführten
     importierten Module kompiliert werden und sie werden auch zum
     Ladepfad des von RUMPF… gelieferten G-Ausdrucks hinzugefügt.

 -- Scheme-Prozedur: gexp? OBJEKT
     Liefert ‘#t’, wenn das OBJEKT ein G-Ausdruck ist.

   G-Ausdrücke sind dazu gedacht, auf die Platte geschrieben zu werden,
entweder als Code, der eine Ableitung erstellt, oder als einfache
Dateien im Store. Die monadischen Prozeduren unten ermöglichen Ihnen das
(siehe *note Die Store-Monade::, wenn Sie mehr Informationen über
Monaden suchen).

 -- Monadische Prozedur: gexp->derivation NAME AUSDRUCK [#:system
          (%current-system)] [#:target #f] [#:graft? #t]  [#:hash #f]
     [#:hash-algo #f]  [#:recursive? #f] [#:env-vars ’()] [#:modules
     ’()]  [#:module-path ‘%load-path’]  [#:effective-version "2.2"]
      [#:references-graphs #f] [#:allowed-references #f]
      [#:disallowed-references #f]  [#:leaked-env-vars #f]
      [#:script-name (string-append NAME "-builder")]
      [#:deprecation-warnings #f]  [#:local-build? #f] [#:substitutable?
     #t]  [#:properties ’()] [#:guile-for-build #f] Return a derivation
     NAME that runs EXP (a gexp) with GUILE-FOR-BUILD (a derivation) on
     SYSTEM; EXP is stored in a file called SCRIPT-NAME. When TARGET is
     true, it is used as the cross-compilation target triplet for
     packages referred to by EXP.

     MODULES gilt als veraltet; stattdessen sollte
     ‘with-imported-modules’ benutzt werden. Die Bedeutung ist, dass die
     MODULE im Ausführungskontext des AUSDRUCKs verfügbar gemacht
     werden; MODULES ist dabei eine Liste von Namen von Guile-Modulen,
     die im Modulpfad MODULE-PATH gesucht werden, um sie in den Store zu
     kopieren, zu kompilieren und im Ladepfad während der Ausführung des
     AUSDRUCKs verfügbar zu machen — z.B. ‘((guix build utils) (guix
     build gnu-build-system))’.

     EFFECTIVE-VERSION bestimmt, unter welcher Zeichenkette die
     Erweiterungen des AUSDRUCKs zum Suchpfad hinzugefügt werden (siehe
     ‘with-extensions’) — z.B. ‘"2.2"’.

     GRAFT? bestimmt, ob vom AUSDRUCK benannte Pakete veredelt werden
     sollen, falls Veredelungen zur Verfügung stehen.

     Ist REFERENCES-GRAPHS wahr, muss es eine Liste von Tupeln in einer
     der folgenden Formen sein:

          (DATEINAME PAKET)
          (DATEINAME PAKET AUSGABE)
          (DATEINAME ABLEITUNG)
          (DATEINAME ABLEITUNG AUSGABE)
          (DATEINAME STORE-OBJEKT)

     Bei jedem Element von REFERENCES-GRAPHS wird das rechts Stehende
     automatisch zu einer Eingabe des Erstellungsprozesses vom AUSDRUCK
     gemacht. In der Erstellungsumgebung enthält das, was mit DATEINAME
     bezeichnet wird, den Referenzgraphen des entsprechenden Objekts in
     einem einfachen Textformat.

     ALLOWED-REFERENCES muss entweder ‘#f’ oder eine Liste von
     Ausgabenamen und Paketen sein. Eine solche Liste benennt
     Store-Objekte, die das Ergebnis referenzieren darf. Jede Referenz
     auf ein nicht dort aufgeführtes Store-Objekt löst einen
     Erstellungsfehler aus. Genauso funktioniert DISALLOWED-REFERENCES,
     was eine Liste von Objekten sein kann, die von den Ausgaben nicht
     referenziert werden dürfen.

     DEPRECATION-WARNINGS bestimmt, ob beim Kompilieren von Modulen
     Warnungen angezeigt werden sollen, wenn auf als veraltet markierten
     Code zugegriffen wird. DEPRECATION-WARNINGS kann ‘#f’, ‘#t’ oder
     ‘'detailed’ (detailliert) sein.

     Die anderen Argumente verhalten sich wie bei ‘derivation’ (siehe
     *note Ableitungen::).

   Die im Folgenden erklärten Prozeduren ‘local-file’, ‘plain-file’,
‘computed-file’, ‘program-file’ und ‘scheme-file’ liefern “dateiartige
Objekte”. Das bedeutet, dass diese Objekte, wenn sie in einem G-Ausdruck
demaskiert werden, zu einer Datei im Store führen. Betrachten Sie zum
Beispiel diesen G-Ausdruck:

     #~(system* #$(file-append glibc "/sbin/nscd") "-f"
                #$(local-file "/tmp/my-nscd.conf"))

   Der Effekt hiervon ist, dass ‘/tmp/my-nscd.conf’ „interniert“ wird,
indem es in den Store kopiert wird. Sobald er umgeschrieben wurde, zum
Beispiel über ‘gexp->derivation’, referenziert der G-Ausdruck diese
Kopie im ‘/gnu/store’. Die Datei in ‘/tmp’ zu bearbeiten oder zu
löschen, hat dann keinen Effekt mehr darauf, was der G-Ausdruck tut.
‘plain-file’ kann in ähnlicher Weise benutzt werden, es unterscheidet
sich aber darin, dass dort der Prozedur der Inhalt der Datei als eine
Zeichenkette übergeben wird.

 -- Scheme-Prozedur: local-file DATEI [NAME] [#:recursive? #f]
          [#:select? (const #t)] Liefert ein Objekt, dass die lokale
     Datei DATEI repräsentiert und sie zum Store hinzufügen lässt;
     dieses Objekt kann in einem G-Ausdruck benutzt werden. Wurde für
     die DATEI ein relativer Dateiname als literaler Ausdruck angegeben,
     wird sie relativ zur Quelldatei gesucht, in der diese Form steht.
     Wurde die DATEI _nicht_ als literale Zeichenkette angegeben, wird
     sie zur Laufzeit relativ zum aktuellen Arbeitsverzeichnis gesucht.
     Die DATEI wird unter dem angegebenen NAMEn im Store abgelegt — als
     Vorgabe wird dabei der Basisname der DATEI genommen.

     Ist RECURSIVE? wahr, werden in der DATEI enthaltene Dateien
     rekursiv hinzugefügt; ist die DATEI eine flache Datei und
     RECURSIVE? ist wahr, wird ihr Inhalt in den Store eingelagert und
     ihre Berechtigungs-Bits übernommen.

     Steht RECURSIVE? auf wahr, wird ‘(SELECT? DATEI STAT)’ für jeden
     Verzeichniseintrag aufgerufen, wobei DATEI der absolute Dateiname
     und STAT das Ergebnis von ‘lstat’ ist, außer auf den Einträgen, wo
     SELECT? keinen wahren Wert liefert.

     Dies ist das deklarative Gegenstück zur monadischen Prozedur
     ‘interned-file’ (siehe *note ‘interned-file’: Die Store-Monade.).

 -- Scheme-Prozedur: plain-file NAME INHALT
     Liefert ein Objekt, das eine Textdatei mit dem angegebenen NAMEn
     repräsentiert, die den angegebenen INHALT hat (eine Zeichenkette
     oder ein Bytevektor), welche zum Store hinzugefügt werden soll.

     Dies ist das deklarative Gegenstück zu ‘text-file’.

 -- Scheme-Prozedur: computed-file NAME G-AUSDRUCK [#:options
          '(#:local-build? #t)] Liefert ein Objekt, das das Store-Objekt
     mit dem NAMEn repräsentiert, eine Datei oder ein Verzeichnis, das
     vom G-AUSDRUCK berechnet wurde. OPTIONS ist eine Liste zusätzlicher
     Argumente, die an ‘gexp->derivation’ übergeben werden.

     Dies ist das deklarative Gegenstück zu ‘gexp->derivation’.

 -- Monadische Prozedur: gexp->script NAME AUSDRUCK [#:guile
          (default-guile)] [#:module-path %load-path]  [#:system
     (%current-system)] [#:target #f] Liefert ein ausführbares Skript
     namens NAME, das den AUSDRUCK mit dem angegebenen GUILE ausführt,
     wobei vom AUSDRUCK importierte Module in seinem Suchpfad stehen.
     Die Module des AUSDRUCKs werden dazu im Modulpfad MODULE-PATH
     gesucht.

     Folgendes Beispiel erstellt ein Skript, das einfach nur den Befehl
     ‘ls’ ausführt:

          (use-modules (guix gexp) (gnu packages base))

          (gexp->script "list-files"
                        #~(execl #$(file-append coreutils "/bin/ls")
                                 "ls"))

     Lässt man es durch den Store „laufen“ (siehe *note
     ‘run-with-store’: Die Store-Monade.), erhalten wir eine Ableitung,
     die eine ausführbare Datei ‘/gnu/store/…-list-files’ generiert,
     ungefähr so:

          #!/gnu/store/…-guile-2.0.11/bin/guile -ds
          !#
          (execl "/gnu/store/…-coreutils-8.22"/bin/ls" "ls")

 -- Scheme-Prozedur: program-file NAME G-AUSDRUCK [#:guile #f]
          [#:module-path %load-path] Liefert ein Objekt, das eine
     ausführbare Store-Datei NAME repräsentiert, die den G-AUSDRUCK
     ausführt. GUILE ist das zu verwendende Guile-Paket, mit dem das
     Skript ausgeführt werden kann. Importierte Module des G-AUSDRUCKs
     werden im Modulpfad MODULE-PATH gesucht.

     Dies ist das deklarative Gegenstück zu ‘gexp->script’.

 -- Monadische Prozedur: gexp->file NAME G-AUSDRUCK [#:set-load-path?
          #t] [#:module-path %load-path]  [#:splice? #f]  [#:guile
     (default-guile)] Liefert eine Ableitung, die eine Datei NAME
     erstellen wird, deren Inhalt der G-AUSDRUCK ist. Ist SPLICE? wahr,
     dann wird G-AUSDRUCK stattdessen als eine Liste von mehreren
     G-Ausdrücken behandelt, die alle in die resultierende Datei
     gespleißt werden.

     Ist SET-LOAD-PATH? wahr, wird in die resultierende Datei Code
     hinzugefügt, der den Ladepfad ‘%load-path’ und den Ladepfad für
     kompilierte Dateien ‘%load-compiled-path’ festlegt, die für die
     importierten Module des G-AUSDRUCKs nötig sind. Die Module des
     G-AUSDRUCKs werden im Modulpfad MODULE-PATH gesucht.

     Die resultierende Datei referenziert alle Abhängigkeiten des
     G-AUSDRUCKs oder eine Teilmenge davon.

 -- Scheme-Prozedur: scheme-file NAME G-AUSDRUCK [#:splice? #f]
     Liefert ein Objekt, das die Scheme-Datei NAME mit dem G-AUSDRUCK
     als Inhalt repräsentiert.

     Dies ist das deklarative Gegenstück zu ‘gexp->file’.

 -- Monadische Prozedur: text-file* NAME TEXT …
     Liefert eine Ableitung als monadischen Wert, welche eine Textdatei
     erstellt, in der der gesamte TEXT enthalten ist. TEXT kann eine
     Folge nicht nur von Zeichenketten, sondern auch Objekten beliebigen
     Typs sein, die in einem G-Ausdruck benutzt werden können, also
     Paketen, Ableitungen, Objekte lokaler Dateien und so weiter. Die
     resultierende Store-Datei referenziert alle davon.

     Diese Variante sollte gegenüber ‘text-file’ bevorzugt verwendet
     werden, wann immer die zu erstellende Datei Objekte im Store
     referenzieren wird. Typischerweise ist das der Fall, wenn eine
     Konfigurationsdatei erstellt wird, die Namen von Store-Dateien
     enthält, so wie hier:

          (define (profile.sh)
            ;; Liefert den Namen eines Shell-Skripts im Store,
            ;; welcher die Umgebungsvariable „PATH“ initialisiert.
            (text-file* "profile.sh"
                        "export PATH=" coreutils "/bin:"
                        grep "/bin:" sed "/bin\n"))

     In diesem Beispiel wird die resultierende Datei
     ‘/gnu/store/…-profile.sh’ sowohl COREUTILS, GREP als auch SED
     referenzieren, so dass der Müllsammler diese nicht löscht, während
     die resultierende Datei noch lebendig ist.

 -- Scheme-Prozedur: mixed-text-file NAME TEXT …
     Liefert ein Objekt, was die Store-Datei NAME repräsentiert, die
     TEXT enthält. TEXT ist dabei eine Folge von Zeichenketten und
     dateiartigen Objekten wie zum Beispiel:

          (mixed-text-file "profile"
                           "export PATH=" coreutils "/bin:" grep "/bin")

     Dies ist das deklarative Gegenstück zu ‘text-file*’.

 -- Scheme-Prozedur: file-union NAME DATEIEN
     Liefert ein ‘<computed-file>’, das ein Verzeichnis mit allen
     DATEIEN enthält. Jedes Objekt in DATEIEN muss eine zweielementige
     Liste sein, deren erstes Element der im neuen Verzeichnis zu
     benutzende Dateiname ist und deren zweites Element ein G-Ausdruck
     ist, der die Zieldatei benennt. Hier ist ein Beispiel:

          (file-union "etc"
                      `(("hosts" ,(plain-file "hosts"
                                              "127.0.0.1 localhost"))
                        ("bashrc" ,(plain-file "bashrc"
                                               "alias ls='ls --color=auto'"))))

     Dies liefert ein Verzeichnis ‘etc’, das zwei Dateien enthält.

 -- Scheme-Prozedur: directory-union NAME DINGE
     Liefert ein Verzeichnis, was die Vereinigung (englisch „Union“) der
     DINGE darstellt, wobei DINGE eine Liste dateiartiger Objekte sein
     muss, die Verzeichnisse bezeichnen. Zum Beispiel:

          (directory-union "guile+emacs" (list guile emacs))

     Das liefert ein Verzeichnis, welches die Vereinigung der Pakete
     ‘guile’ und ‘emacs’ ist.

 -- Scheme-Prozedur: file-append OBJEKT SUFFIX …
     Liefert ein dateiartiges Objekt, das zur Aneinanderreihung von
     OBJEKT und SUFFIX umgeschrieben wird, wobei das OBJEKT ein
     herunterbrechbares Objekt und jedes SUFFIX eine Zeichenkette sein
     muss.

     Betrachten Sie zum Beispiel diesen G-Ausdruck:

          (gexp->script "uname-ausfuehren"
                        #~(system* #$(file-append coreutils
                                                  "/bin/uname")))

     Denselben Effekt könnte man erreichen mit:

          (gexp->script "uname-ausfuehren"
                        #~(system* (string-append #$coreutils
                                                  "/bin/uname")))

     Es gibt jedoch einen Unterschied, nämlich enthält das resultierende
     Skript bei ‘file-append’ tatsächlich den absoluten Dateinamen als
     Zeichenkette, während im anderen Fall das resultierende Skript
     einen Ausdruck ‘(string-append …)’ enthält, der den Dateinamen erst
     _zur Laufzeit_ zusammensetzt.

 -- Scheme-Syntax: with-parameters ((PARAMETER WERT) …) AUSDRUCK
     Mit diesem Makro verhält es sich ähnlich wie mit der
     ‘parameterize’-Form für dynamisch gebundene “Parameter” (siehe
     *note (guile)Parameters::). Der Hauptunterschied ist, dass es sich
     erst auswirkt, wenn das vom AUSDRUCK zurückgelieferte dateiartige
     Objekt auf eine Ableitung oder ein Store-Objekt heruntergebrochen
     wird.

     Eine typische Anwendung von ‘with-parameters’ ist, den für ein
     bestimmtes Objekt geltenden Systemtyp zwingend festzulegen:

          (with-parameters ((%current-system "i686-linux"))
            coreutils)

     Obiges Beispiel liefert ein Objekt, das der Erstellung von
     Coreutils für die i686-Architektur entspricht, egal was der
     aktuelle Wert von ‘%current-system’ ist.

   Natürlich gibt es zusätzlich zu in „wirtsseitigem“ Code eingebetteten
G-Ausdrücken auch Module mit „erstellungsseitig“ nutzbaren Werkzeugen.
Um klarzustellen, dass sie dafür gedacht sind, in der Erstellungsschicht
benutzt zu werden, bleiben diese Module im Namensraum ‘(guix build …)’.

   Intern werden hochsprachliche, abstrakte Objekte mit ihrem Compiler
entweder zu Ableitungen oder zu Store-Objekten “heruntergebrochen”. Wird
zum Beispiel ein Paket heruntergebrochen, bekommt man eine Ableitung,
während ein ‘plain-file’ zu einem Store-Objekt heruntergebrochen wird.
Das wird mit der monadischen Prozedur ‘lower-object’ bewerkstelligt.

 -- Monadische Prozedur: lower-object OBJEKT [SYSTEM] [#:target #f]
          Return as a value in ‘%store-monad’ the derivation or
     store item corresponding to OBJ for SYSTEM, cross-compiling for
     TARGET if TARGET is true. OBJ must be an object that has an
     associated gexp compiler, such as a ‘<package>’.

   ---------- Footnotes ----------

   (1) Der Begriff “Schicht”, englisch Stratum, wurde in diesem Kontext
von Manuel Serrano et al. in ihrer Arbeit an Hop geprägt. Oleg Kiselyov,
der aufschlussreiche Essays und Code zu diesem Thema
(http://okmij.org/ftp/meta-programming/#meta-scheme) geschrieben hat,
nennt diese Art der Code-Generierung “Staging”, deutsch etwa
Inszenierung bzw. Aufführung.


File: guix.de.info,  Node: Aufruf von guix repl,  Prev: G-Ausdrücke,  Up: Programmierschnittstelle

6.8 ‘guix repl’ aufrufen
========================

Der Befehl ‘guix repl’ startet eine Guile-REPL (“Read-Eval-Print Loop”,
kurz REPL, deutsch Lese-Auswerten-Schreiben-Schleife) zur interaktiven
Programmierung (siehe *note (guile)Using Guile Interactively::). Im
Vergleich dazu, einfach den Befehl ‘guile’ aufzurufen, garantiert ‘guix
repl’, dass alle Guix-Module und deren Abhängigkeiten im Suchpfad
verfügbar sind. Sie können die REPL so benutzen:

     $ guix repl
     scheme@(guile-user)> ,use (gnu packages base)
     scheme@(guile-user)> coreutils
     $1 = #<package coreutils@8.29 gnu/packages/base.scm:327 3e28300>

   ‘guix repl’ implementiert zusätzlich ein einfaches maschinenlesbares
Protokoll für die REPL, das von ‘(guix inferior)’ benutzt wird, um mit
“Untergeordneten” zu interagieren, also mit getrennten Prozessen einer
womöglich anderen Version von Guix.

   Folgende OPTIONEN gibt es:

‘--type=TYP’
‘-t TYP’
     Startet eine REPL des angegebenen TYPs, der einer der Folgenden
     sein darf:

     ‘guile’
          Die Voreinstellung, mit der eine normale, voll funktionsfähige
          Guile-REPL gestartet wird.
     ‘machine’
          Startet eine REPL, die ein maschinenlesbares Protokoll
          benutzt. Dieses Protokoll wird vom Modul ‘(guix inferior)’
          gesprochen.

‘--listen=ENDPUNKT’
     Der Vorgabe nach würde ‘guix repl’ von der Standardeingabe lesen
     und auf die Standardausgabe schreiben. Wird diese
     Befehlszeilenoption angegeben, lauscht die REPL stattdessen auf dem
     ENDPUNKT auf Verbindungen. Hier sind Beispiele gültiger
     Befehlszeilenoptionen:

     ‘--listen=tcp:37146’
          Verbindungen mit dem „localhost“ auf Port 37146 akzeptieren.

     ‘--listen=unix:/tmp/socket’
          Verbindungen zum Unix-Socket ‘/tmp/socket’ akzeptieren.

‘--load-path=VERZEICHNIS’
‘-L VERZEICHNIS’
     Das VERZEICHNIS vorne an den Suchpfad für Paketmodule anfügen
     (siehe *note Paketmodule::).

     Damit können Nutzer dafür sorgen, dass ihre eigenen
     selbstdefinierten Pakete für das Befehlszeilenwerkzeug sichtbar
     sind.

‘-q’
     Das Laden der ‘~/.guile’-Datei unterdrücken. Nach Voreinstellung
     würde diese Konfigurationsdatei beim Erzeugen einer REPL für
     ‘guile’ geladen.


File: guix.de.info,  Node: Zubehör,  Next: Systemkonfiguration,  Prev: Programmierschnittstelle,  Up: Top

7 Zubehör
*********

Dieser Abschnitt beschreibt die Befehlszeilenwerkzeuge von Guix. Manche
davon richten sich hauptsächlich an Entwickler und solche Nutzer, die
neue Paketdefinitionen schreiben, andere sind auch für ein breiteres
Publikum nützlich. Sie ergänzen die Scheme-Programmierschnittstelle um
bequeme Befehle.

* Menu:

* Aufruf von guix build::    Pakete aus der Befehlszeile heraus erstellen.
* Aufruf von guix edit::     Paketdefinitionen bearbeiten.
* Aufruf von guix download::  Herunterladen einer Datei und Ausgabe ihres
                                Hashes.
* Aufruf von guix hash::     Den kryptografischen Hash einer Datei
                               berechnen.
* Aufruf von guix import::   Paketdefinitionen importieren.
* Aufruf von guix refresh::  Paketdefinitionen aktualisieren.
* Aufruf von guix lint::     Fehler in Paketdefinitionen finden.
* Aufruf von guix size::     Plattenplatzverbrauch profilieren.
* Aufruf von guix graph::    Den Paketgraphen visualisieren.
* Aufruf von guix publish::  Substitute teilen.
* Aufruf von guix challenge::  Die Substitut-Server anfechten.
* Aufruf von guix copy::     Mit einem entfernten Store Dateien austauschen.
* Aufruf von guix container::  Prozesse isolieren.
* Aufruf von guix weather::  Die Verfügbarkeit von Substituten
                               einschätzen.
* Aufruf von guix processes::  Auflisten der Client-Prozesse


File: guix.de.info,  Node: Aufruf von guix build,  Next: Aufruf von guix edit,  Up: Zubehör

7.1 Aufruf von ‘guix build’
===========================

Der Befehl ‘guix build’ lässt Pakete oder Ableitungen samt ihrer
Abhängigkeiten erstellen und gibt die resultierenden Pfade im Store aus.
Beachten Sie, dass das Nutzerprofil dadurch nicht modifiziert wird —
eine solche Installation bewirkt der Befehl ‘guix package’ (siehe *note
Aufruf von guix package::). ‘guix build’ wird also hauptsächlich von
Entwicklern der Distribution benutzt.

   Die allgemeine Syntax lautet:

     guix build OPTIONEN PAKET-ODER-ABLEITUNG…

   Zum Beispiel wird mit folgendem Befehl die neueste Version von Emacs
und von Guile erstellt, das zugehörige Erstellungsprotokoll angezeigt
und letztendlich werden die resultierenden Verzeichnisse ausgegeben:

     guix build emacs guile

   Folgender Befehl erstellt alle Pakete, die zur Verfügung stehen:

     guix build --quiet --keep-going \
       `guix package -A | cut -f1,2 --output-delimiter=@`

   Als PAKET-ODER-ABLEITUNG muss entweder der Name eines in der
Software-Distribution zu findenden Pakets, wie etwa ‘coreutils’ oder
‘coreutils@8.20’, oder eine Ableitung wie
‘/gnu/store/…-coreutils-8.19.drv’ sein. Im ersten Fall wird nach einem
Paket mit entsprechendem Namen (und optional der entsprechenden Version)
in den Modulen der GNU-Distribution gesucht (siehe *note Paketmodule::).

   Alternativ kann die Befehlszeilenoption ‘--expression’ benutzt
werden, um einen Scheme-Ausdruck anzugeben, der zu einem Paket
ausgewertet wird; dies ist nützlich, wenn zwischen mehreren
gleichnamigen Paketen oder Paket-Varianten unterschieden werden muss.

   Null oder mehr OPTIONEN können angegeben werden. Zur Verfügung stehen
die in den folgenden Unterabschnitten beschriebenen
Befehlszeilenoptionen.

* Menu:

* Gemeinsame Erstellungsoptionen::  Erstellungsoptionen für die meisten
                                      Befehle.
* Paketumwandlungsoptionen::  Varianten von Paketen erzeugen.
* Zusätzliche Erstellungsoptionen::  Optionen spezifisch für „guix
                                        build“.
* Fehlschläge beim Erstellen untersuchen::  Praxiserfahrung bei der
                                               Paketerstellung.


File: guix.de.info,  Node: Gemeinsame Erstellungsoptionen,  Next: Paketumwandlungsoptionen,  Up: Aufruf von guix build

7.1.1 Gemeinsame Erstellungsoptionen
------------------------------------

Einige dieser Befehlszeilenoptionen zur Steuerung des Erstellungsprozess
haben ‘guix build’ und andere Befehle, mit denen Erstellungen ausgelöst
werden können, wie ‘guix package’ oder ‘guix archive’, gemeinsam. Das
sind folgende:

‘--load-path=VERZEICHNIS’
‘-L VERZEICHNIS’
     Das VERZEICHNIS vorne an den Suchpfad für Paketmodule anfügen
     (siehe *note Paketmodule::).

     Damit können Nutzer dafür sorgen, dass ihre eigenen
     selbstdefinierten Pakete für die Befehlszeilenwerkzeuge sichtbar
     sind.

‘--keep-failed’
‘-K’
     Den Verzeichnisbaum, in dem fehlgeschlagene Erstellungen
     durchgeführt wurden, behalten. Wenn also eine Erstellung
     fehlschlägt, bleibt ihr Erstellungsbaum in ‘/tmp’ erhalten. Der
     Name dieses Unterverzeichnisses wird am Ende dem
     Erstellungsprotokolls ausgegeben. Dies hilft bei der Suche nach
     Fehlern in Erstellungen. Der Abschnitt *note Fehlschläge beim
     Erstellen untersuchen:: zeigt Ihnen Hinweise und Tricks, wie
     Erstellungsfehler untersucht werden können.

     Diese Option impliziert ‘--no-offload’ und sie hat keine
     Auswirkungen, wenn eine Verbindung zu einem entfernten Daemon über
     eine ‘guix://’-URI verwendet wurde (siehe *note the
     ‘GUIX_DAEMON_SOCKET’ variable: Der Store.).

‘--keep-going’
‘-k’
     Weitermachen, auch wenn ein Teil der Erstellungen fehlschlägt. Das
     bedeutet, dass der Befehl erst terminiert, wenn alle Erstellungen
     erfolgreich oder mit Fehler durchgeführt wurden.

     Das normale Verhalten ist, abzubrechen, sobald eine der angegebenen
     Ableitungen fehlschlägt.

‘--dry-run’
‘-n’
     Die Ableitungen nicht erstellen.

‘--fallback’
     Wenn das Substituieren vorerstellter Binärdateien fehlschlägt,
     diese ersatzweise lokal selbst erstellen (siehe *note Fehler bei
     der Substitution::).

‘--substitute-urls=URLS’
     Die URLS als durch Leerraumzeichen getrennte Liste von Quell-URLs
     für Substitute anstelle der vorgegebenen URL-Liste für den
     ‘guix-daemon’ verwenden (siehe *note ‘guix-daemon’ URLs:
     daemon-substitute-urls.).

     Das heißt, die Substitute dürfen von den URLS heruntergeladen
     werden, sofern sie mit einem durch den Systemadministrator
     autorisierten Schlüssel signiert worden sind (siehe *note
     Substitute::).

     Wenn als URLS eine leere Zeichenkette angegeben wurde, verhält es
     sich, als wären Substitute abgeschaltet.

‘--no-substitutes’
     Benutze keine Substitute für Erstellungsergebnisse. Das heißt, dass
     alle Objekte lokal erstellt werden müssen, und kein Herunterladen
     von vorab erstellten Binärdateien erlaubt ist (siehe *note
     Substitute::).

‘--no-grafts’
     Pakete nicht „veredeln“ (engl. „graft“). Praktisch heißt das, dass
     als Veredelungen verfügbare Paketaktualisierungen nicht angewandt
     werden. Der Abschnitt *note Sicherheitsaktualisierungen:: hat
     weitere Informationen zu Veredelungen.

‘--rounds=N’
     Jede Ableitung N-mal nacheinander erstellen und einen Fehler
     melden, wenn die aufeinanderfolgenden Erstellungsergebnisse nicht
     Bit für Bit identisch sind.

     Das ist eine nützliche Methode, um nicht-deterministische
     Erstellungsprozesse zu erkennen. Nicht-deterministische
     Erstellungsprozesse sind ein Problem, weil Nutzer dadurch praktisch
     nicht _verifizieren_ können, ob von Drittanbietern bereitgestellte
     Binärdateien echt sind. Der Abschnitt *note Aufruf von guix
     challenge:: erklärt dies genauer.

     Beachten Sie, dass die sich unterscheidenden Erstellungsergebnisse
     nicht erhalten bleiben, so dass Sie eventuelle Fehler manuell
     untersuchen müssen, z.B. indem Sie eines oder mehrere der
     Erstellungsergebnisse ‘guix archive --export’ auslagern (siehe
     *note Aufruf von guix archive::), dann neu erstellen und letztlich
     die beiden Erstellungsergebnisse vergleichen.

‘--no-offload’
     Nicht versuchen, an andere Maschinen ausgelagerte Erstellungen zu
     benutzen (siehe *note Auslagern des Daemons einrichten::). Somit
     wird lokal erstellt, statt Erstellungen auf entfernte Maschinen
     auszulagern.

‘--max-silent-time=SEKUNDEN’
     Wenn der Erstellungs- oder Substitutionsprozess länger als
     SEKUNDEN-lang keine Ausgabe erzeugt, wird er abgebrochen und ein
     Fehler beim Erstellen gemeldet.

     Standardmäßig wird die Einstellung für den Daemon benutzt (siehe
     *note ‘--max-silent-time’: Aufruf des guix-daemon.).

‘--timeout=SEKUNDEN’
     Entsprechend wird hier der Erstellungs- oder Substitutionsprozess
     abgebrochen und als Fehlschlag gemeldet, wenn er mehr als
     SEKUNDEN-lang dauert.

     Standardmäßig wird die Einstellung für den Daemon benutzt (siehe
     *note ‘--timeout’: Aufruf des guix-daemon.).

‘-v STUFE’
‘--verbosity=STUFE’
     Die angegebene Ausführlichkeitsstufe verwenden. Als STUFE muss eine
     ganze Zahl angegeben werden. Wird 0 gewählt, wird keine Ausgabe zur
     Fehlersuche angezeigt, 1 bedeutet eine knappe Ausgabe und 2 lässt
     alle Erstellungsprotokollausgaben auf die Standardfehlerausgabe
     schreiben.

‘--cores=N’
‘-c N’
     Die Nutzung von bis zu N Prozessorkernen für die Erstellungen
     gestatten. Der besondere Wert ‘0’ bedeutet, dass so viele wie
     möglich benutzt werden.

‘--max-jobs=N’
‘-M N’
     Höchstens N gleichzeitige Erstellungsaufträge erlauben. Im
     Abschnitt *note ‘--max-jobs’: Aufruf des guix-daemon. finden Sie
     Details zu dieser Option und der äquivalenten Option des
     ‘guix-daemon’.

‘--debug=STUFE’
     Ein Protokoll zur Fehlersuche ausgeben, das vom Erstellungsdaemon
     kommt. Als STUFE muss eine ganze Zahl zwischen 0 und 5 angegeben
     werden; höhere Zahlen stehen für ausführlichere Ausgaben. Stufe 4
     oder höher zu wählen, kann bei der Suche nach Fehlern, wie der
     Erstellungs-Daemon eingerichtet ist, helfen.

   Intern ist ‘guix build’ im Kern eine Schnittstelle zur Prozedur
‘package-derivation’ aus dem Modul ‘(guix packages)’ und zu der Prozedur
‘build-derivations’ des Moduls ‘(guix derivations)’.

   Neben auf der Befehlszeile übergebenen Optionen beachten ‘guix build’
und andere ‘guix’-Befehle, die Erstellungen durchführen lassen, die
Umgebungsvariable ‘GUIX_BUILD_OPTIONS’.

 -- Umgebungsvariable: GUIX_BUILD_OPTIONS
     Nutzer können diese Variable auf eine Liste von
     Befehlszeilenoptionen definieren, die automatisch von ‘guix build’
     und anderen ‘guix’-Befehlen, die Erstellungen durchführen lassen,
     benutzt wird, wie in folgendem Beispiel:

          $ export GUIX_BUILD_OPTIONS="--no-substitutes -c 2 -L /foo/bar"

     Diese Befehlszeilenoptionen werden unabhängig von den auf der
     Befehlszeile übergebenen Befehlszeilenoptionen grammatikalisch
     analysiert und das Ergebnis an die bereits analysierten auf der
     Befehlszeile übergebenen Befehlszeilenoptionen angehängt.


File: guix.de.info,  Node: Paketumwandlungsoptionen,  Next: Zusätzliche Erstellungsoptionen,  Prev: Gemeinsame Erstellungsoptionen,  Up: Aufruf von guix build

7.1.2 Paketumwandlungsoptionen
------------------------------

Eine weitere Gruppe von Befehlszeilenoptionen, die ‘guix build’ und auch
‘guix package’ unterstützen, sind “Paketumwandlungsoptionen”. Diese
Optionen ermöglichen es, “Paketvarianten” zu definieren — zum Beispiel
können Pakete aus einem anderen Quellcode als normalerweise erstellt
werden. Damit ist es leicht, angepasste Pakete schnell zu erstellen,
ohne die vollständigen Definitionen von Paketvarianten einzutippen
(siehe *note Pakete definieren::).

‘--with-source=QUELLE’
‘--with-source=PAKET=QUELLE’
‘--with-source=PAKET@VERSION=QUELLE’
     Den Paketquellcode für das PAKET von der angegebenen QUELLE holen
     und die VERSION als seine Versionsnummer verwenden. Die QUELLE muss
     ein Dateiname oder eine URL sein wie bei ‘guix download’ (siehe
     *note Aufruf von guix download::).

     Wird kein PAKET angegeben, wird als Paketname derjenige auf der
     Befehlszeile angegebene Paketname angenommen, der zur Basis am Ende
     der QUELLE passt — wenn z.B. als QUELLE die Datei
     ‘/src/guile-2.0.10.tar.gz’ angegeben wurde, entspricht das dem
     ‘guile’-Paket.

     Ebenso wird, wenn keine VERSION angegeben wurde, die Version als
     Zeichenkette aus der QUELLE abgeleitet; im vorherigen Beispiel wäre
     sie ‘2.0.10’.

     Mit dieser Option können Nutzer versuchen, eine andere Version
     ihres Pakets auszuprobieren, als die in der Distribution enthaltene
     Version. Folgendes Beispiel lädt ‘ed-1.7.tar.gz’ von einem
     GNU-Spiegelserver herunter und benutzt es als Quelle für das
     ‘ed’-Paket:

          guix build ed --with-source=mirror://gnu/ed/ed-1.7.tar.gz

     Für Entwickler wird es einem durch ‘--with-source’ leicht gemacht,
     „Release Candidates“, also Vorabversionen, zu testen:

          guix build guile --with-source=../guile-2.0.9.219-e1bb7.tar.xz

     … oder ein Checkout eines versionskontrollierten Repositorys in
     einer isolierten Umgebung zu erstellen:

          $ git clone git://git.sv.gnu.org/guix.git
          $ guix build guix --with-source=guix@1.0=./guix

‘--with-input=PAKET=ERSATZ’
     Abhängigkeiten vom PAKET durch eine Abhängigkeit vom ERSATZ-Paket
     ersetzen. Als PAKET muss ein Paketname angegeben werden und als
     ERSATZ eine Paketspezifikation wie ‘guile’ oder ‘guile@1.8’.

     Mit folgendem Befehl wird zum Beispiel Guix erstellt, aber statt
     der aktuellen stabilen Guile-Version hängt es von der alten
     Guile-Version ‘guile@2.0’ ab:

          guix build --with-input=guile=guile@2.0 guix

     Die Ersetzung ist rekursiv und umfassend. In diesem Beispiel würde
     nicht nur ‘guix’, sondern auch seine Abhängigkeit ‘guile-json’ (was
     auch von ‘guile’ abhängt) für ‘guile@2.0’ neu erstellt.

     Implementiert wird das alles mit der Scheme-Prozedur
     ‘package-input-rewriting’ (siehe *note ‘package-input-rewriting’:
     Pakete definieren.).

‘--with-graft=PAKET=ERSATZ’
     Dies verhält sich ähnlich wie mit ‘--with-input’, aber mit dem
     wichtigen Unterschied, dass nicht die gesamte Abhängigkeitskette
     neu erstellt wird, sondern das ERSATZ-Paket erstellt und die
     ursprünglichen Binärdateien, die auf das PAKET verwiesen haben,
     damit “veredelt” werden. Im Abschnitt *note
     Sicherheitsaktualisierungen:: finden Sie weitere Informationen über
     Veredelungen.

     Zum Beispiel veredelt folgender Befehl Wget und alle Abhängigkeiten
     davon mit der Version 3.5.4 von GnuTLS, indem Verweise auf die
     ursprünglich verwendete GnuTLS-Version ersetzt werden:

          guix build --with-graft=gnutls=gnutls@3.5.4 wget

     Das hat den Vorteil, dass es viel schneller geht, als alles neu zu
     erstellen. Die Sache hat aber einen Haken: Veredelung funktioniert
     nur, wenn das PAKET und sein ERSATZ miteinander streng kompatibel
     sind — zum Beispiel muss, wenn diese eine Programmbibliothek zur
     Verfügung stellen, deren Binärschnittstelle („Application Binary
     Interface“, kurz ABI) kompatibel sein. Wenn das ERSATZ-Paket auf
     irgendeine Art inkompatibel mit dem PAKET ist, könnte das
     Ergebnispaket unbrauchbar sein. Vorsicht ist also geboten!

‘--with-git-url=PAKET=URL’
     Das PAKET aus dem neuesten Commit im ‘master’-Branch des unter der
     URL befindlichen Git-Repositorys erstellen. Git-Submodule des
     Repositorys werden dabei rekursiv geladen.

     Zum Beispiel erstellt der folgende Befehl die
     NumPy-Python-Bibliothek unter Verwendung des neuesten Commits von
     Python auf dessen „master“-Branch.

          guix build python-numpy \
            --with-git-url=python=https://github.com/python/cpython

     Diese Befehlszeilenoption kann auch mit ‘--with-branch’ oder
     ‘--with-commit’ kombiniert werden (siehe unten).

     Da es den neuesten Commit auf dem verwendeten Branch benutzt,
     ändert sich das Ergebnis natürlich mit der Zeit. Nichtsdestoweniger
     ist es eine bequeme Möglichkeit, ganze Softwarestapel auf dem
     neuesten Commit von einem oder mehr Paketen aufbauen zu lassen. Es
     ist besonders nützlich im Kontext Kontinuierlicher Integration
     (englisch „Continuous Integration“, kurz CI).

     Checkouts bleiben zwischengespeichert als
     ‘~/.cache/guix/checkouts’, damit danach schneller auf dasselbe
     Repository zugegriffen werden kann. Eventuell möchten Sie das
     Verzeichnis ab und zu bereinigen, um Plattenplatz zu sparen.

‘--with-branch=PAKET=BRANCH’
     Das PAKET aus dem neuesten Commit auf dem BRANCH erstellen. Wenn
     das ‘source’-Feld des PAKETs ein origin-Objekt mit der Methode
     ‘git-fetch’ (siehe *note „origin“-Referenz::) oder ein
     ‘git-checkout’-Objekt ist, wird die URL des Repositorys vom
     ‘source’-Feld genommen. Andernfalls müssen Sie die
     Befehlszeilenoption ‘--with-git-url’ benutzen, um die URL des
     Git-Repositorys anzugeben.

     Zum Beispiel wird mit dem folgenden Befehl ‘guile-sqlite3’ aus dem
     neuesten Commit seines ‘master’-Branches erstellt und anschließend
     ‘guix’ (was von ‘guile-sqlite3’ abhängt) und ‘cuirass’ (was von
     ‘guix’ abhängt) unter Nutzung genau dieser
     ‘guile-sqlite3’-Erstellung erstellt:

          guix build --with-branch=guile-sqlite3=master cuirass

‘--with-commit=PAKET=COMMIT’
     Dies verhält sich ähnlich wie ‘--with-branch’, außer dass es den
     angegebenen COMMIT benutzt statt die Spitze eines angegebenen
     Branches. Als COMMIT muss ein gültiger SHA1-Bezeichner oder ein Tag
     für einen Git-Commit angegeben werden.


File: guix.de.info,  Node: Zusätzliche Erstellungsoptionen,  Next: Fehlschläge beim Erstellen untersuchen,  Prev: Paketumwandlungsoptionen,  Up: Aufruf von guix build

7.1.3 Zusätzliche Erstellungsoptionen
-------------------------------------

Die unten aufgeführten Befehlszeilenoptionen funktionieren nur mit ‘guix
build’.

‘--quiet’
‘-q’
     Schweigend erstellen, ohne das Erstellungsprotokoll anzuzeigen —
     dies ist äquivalent zu ‘--verbosity=0’. Nach Abschluss der
     Erstellung ist das Protokoll in ‘/var’ (oder einem entsprechenden
     Ort) einsehbar und kann jederzeit mit der Befehlszeilenoption
     ‘--log-file’ gefunden werden.

‘--file=DATEI’
‘-f DATEI’
     Das Paket, die Ableitung oder das dateiähnliche Objekt erstellen,
     zu dem der Code in der DATEI ausgewertet wird (siehe *note
     dateiartige Objekte: G-Ausdrücke.).

     Zum Beispiel könnte in der DATEI so eine Paketdefinition stehen
     (siehe *note Pakete definieren::):

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     The FILE may also contain a JSON representation of one or more
     package definitions. Running ‘guix build -f’ on ‘hello.json’ with
     the following contents would result in building the packages
     ‘myhello’ and ‘greeter’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--manifest=MANIFEST’
‘-m MANIFEST’
     Alle Pakete erstellen, die im angegebenen MANIFEST stehen (siehe
     *note ‘--manifest’: profile-manifest.).

‘--expression=AUSDRUCK’
‘-e AUSDRUCK’
     Das Paket oder die Ableitung erstellen, zu der der AUSDRUCK
     ausgewertet wird.

     Zum Beispiel kann der AUSDRUCK ‘(@ (gnu packages guile) guile-1.8)’
     sein, was diese bestimmte Variante der Version 1.8 von Guile
     eindeutig bezeichnet.

     Alternativ kann der AUSDRUCK ein G-Ausdruck sein. In diesem Fall
     wird er als Erstellungsprogramm an ‘gexp->derivation’ übergeben
     (siehe *note G-Ausdrücke::).

     Zudem kann der AUSDRUCK eine monadische Prozedur mit null
     Argumenten bezeichnen (siehe *note Die Store-Monade::). Die
     Prozedur muss eine Ableitung als monadischen Wert zurückliefern,
     die dann durch ‘run-with-store’ laufen gelassen wird.

‘--source’
‘-S’
     Die Quellcode-Ableitung der Pakete statt die Pakete selbst
     erstellen.

     Zum Beispiel liefert ‘guix build -S gcc’ etwas in der Art von
     ‘/gnu/store/…-gcc-4.7.2.tar.bz2’, also den Tarball mit dem
     GCC-Quellcode.

     Der gelieferte Quell-Tarball ist das Ergebnis davon, alle Patches
     und Code-Schnipsel aufzuspielen, die im ‘origin’-Objekt des Pakets
     festgelegt wurden (siehe *note Pakete definieren::).

     Beachten Sie, dass ‘guix build -S’ nur für die angegebenen Pakete
     den Quellcode herunterlädt. Dazu gehört _nicht_ der Quellcode
     statisch gebundener Abhängigkeiten und der Quellcode alleine reicht
     nicht aus, um die Pakete zu reproduzieren.

‘--sources’
     Den Quellcode für PAKET-ODER-ABLEITUNG und alle Abhängigkeiten
     davon rekursiv herunterladen und zurückliefern. Dies ist eine
     praktische Methode, eine lokale Kopie des gesamten Quellcodes zu
     beziehen, der nötig ist, um die Pakete zu erstellen, damit Sie
     diese später auch ohne Netzwerkzugang erstellen lassen können. Es
     handelt sich um eine Erweiterung der Befehlszeilenoption
     ‘--source’, die jeden der folgenden Argumentwerte akzeptiert:

     ‘package’
          Mit diesem Wert verhält sich die Befehlszeilenoption
          ‘--sources’ auf genau die gleiche Weise wie die
          Befehlszeilenoption ‘--source’.

     ‘all’
          Erstellt die Quellcode-Ableitungen aller Pakete einschließlich
          allen Quellcodes, der als Teil der Eingaben im ‘inputs’-Feld
          aufgelistet ist. Dies ist der vorgegebene Wert, wenn sonst
          keiner angegeben wird.

               $ guix build --sources tzdata
               Folgende Ableitungen werden erstellt:
                  /gnu/store/…-tzdata2015b.tar.gz.drv
                  /gnu/store/…-tzcode2015b.tar.gz.drv

     ‘transitive’
          Die Quellcode-Ableitungen aller Pakete sowie aller transitiven
          Eingaben der Pakete erstellen. Damit kann z.B. Paket-Quellcode
          vorab heruntergeladen und später offline erstellt werden.

               $ guix build --sources=transitive tzdata
               Folgende Ableitungen werden erstellt:
                  /gnu/store/…-tzcode2015b.tar.gz.drv
                  /gnu/store/…-findutils-4.4.2.tar.xz.drv
                  /gnu/store/…-grep-2.21.tar.xz.drv
                  /gnu/store/…-coreutils-8.23.tar.xz.drv
                  /gnu/store/…-make-4.1.tar.xz.drv
                  /gnu/store/…-bash-4.3.tar.xz.drv
               …

‘--system=SYSTEM’
‘-s SYSTEM’
     Versuchen, für das angegebene SYSTEM — z.B. ‘i686-linux’ — statt
     für denselben Systemtyp wie auf dem Wirtssystem zu erstellen. Beim
     Befehl ‘guix build’ können Sie diese Befehlszeilenoption mehrmals
     wiederholen, wodurch für jedes angegebene System eine Erstellung
     durchgeführt wird; andere Befehle ignorieren überzählige
     ‘-s’-Befehlszeilenoptionen.

          Anmerkung: Die Befehlszeilenoption ‘--system’ dient der
          _nativen_ Kompilierung (nicht zu verwechseln mit
          Cross-Kompilierung). Siehe ‘--target’ unten für Informationen
          zur Cross-Kompilierung.

     Ein Beispiel sind Linux-basierte Systeme, die verschiedene
     Persönlichkeiten emulieren können. Zum Beispiel können Sie
     ‘--system=i686-linux’ auf einem ‘x86_64-linux’-System oder
     ‘--system=armhf-linux’ auf einem ‘aarch64-linux’-System angeben, um
     Pakete in einer vollständigen 32-Bit-Umgebung zu erstellen.

          Anmerkung: Das Erstellen für ein ‘armhf-linux’-System ist
          ungeprüft auf allen ‘aarch64-linux’-Maschinen aktiviert,
          obwohl bestimmte aarch64-Chipsätze diese Funktionalität nicht
          unterstützen, darunter auch ThunderX.

     Ebenso können Sie, wenn transparente Emulation mit QEMU und
     ‘binfmt_misc’ aktiviert sind (siehe *note
     ‘qemu-binfmt-service-type’: Virtualisierungsdienste.), für jedes
     System Erstellungen durchführen, für das ein
     QEMU-‘binfmt_misc’-Handler installiert ist.

     Erstellungen für ein anderes System, das nicht dem System der
     Maschine, die Sie benutzen, entspricht, können auch auf eine
     entfernte Maschine mit der richtigen Architektur ausgelagert
     werden. Siehe *note Auslagern des Daemons einrichten:: für mehr
     Informationen über das Auslagern.

‘--target=TRIPEL’
     Lässt für das angegebene TRIPEL cross-erstellen, dieses muss ein
     gültiges GNU-Tripel wie z.B. ‘"mips64el-linux-gnu"’ sein (siehe
     *note GNU configuration triplets: (autoconf)Specifying Target
     Triplets.).

‘--check’
     PAKET-ODER-ABLEITUNG erneut erstellen, wenn diese bereits im Store
     verfügbar ist, und einen Fehler melden, wenn die
     Erstellungsergebnisse nicht Bit für Bit identisch sind.

     Mit diesem Mechanismus können Sie überprüfen, ob zuvor installierte
     Substitute unverfälscht sind (siehe *note Substitute::) oder auch
     ob das Erstellungsergebnis eines Pakets deterministisch ist. Siehe
     *note Aufruf von guix challenge:: für mehr Hintergrundinformationen
     und Werkzeuge.

     Wenn dies zusammen mit ‘--keep-failed’ benutzt wird, bleiben die
     sich unterscheidenden Ausgaben im Store unter dem Namen
     ‘/gnu/store/…-check’. Dadurch können Unterschiede zwischen den
     beiden Ergebnissen leicht erkannt werden.

‘--repair’
     Versuchen, die angegebenen Store-Objekte zu reparieren, wenn sie
     beschädigt sind, indem sie neu heruntergeladen oder neu erstellt
     werden.

     Diese Operation ist nicht atomar und nur der Administratornutzer
     ‘root’ kann sie verwenden.

‘--derivations’
‘-d’
     Liefert die Ableitungspfade und _nicht_ die Ausgabepfade für die
     angegebenen Pakete.

‘--root=DATEI’
‘-r DATEI’
     Die DATEI zu einer symbolischen Verknüpfung auf das Ergebnis machen
     und als Müllsammlerwurzel registrieren.

     Dadurch wird das Ergebnis dieses Aufrufs von ‘guix build’ vor dem
     Müllsammler geschützt, bis die DATEI gelöscht wird. Wird diese
     Befehlszeilenoption _nicht_ angegeben, können Erstellungsergebnisse
     vom Müllsammler geholt werden, sobald die Erstellung abgeschlossen
     ist. Siehe *note Aufruf von guix gc:: für mehr Informationen zu
     Müllsammlerwurzeln.

‘--log-file’
     Liefert die Dateinamen oder URLs der Erstellungsprotokolle für das
     angegebene PAKET-ODER-ABLEITUNG oder meldet einen Fehler, falls
     Protokolldateien fehlen.

     Dies funktioniert, egal wie die Pakete oder Ableitungen angegeben
     werden. Zum Beispiel sind folgende Aufrufe alle äquivalent:

          guix build --log-file `guix build -d guile`
          guix build --log-file `guix build guile`
          guix build --log-file guile
          guix build --log-file -e '(@ (gnu packages guile) guile-2.0)'

     Wenn ein Protokoll lokal nicht verfügbar ist und sofern
     ‘--no-substitutes’ nicht übergeben wurde, sucht der Befehl nach
     einem entsprechenden Protokoll auf einem der Substitutserver (die
     mit ‘--substitute-urls’ angegeben werden können).

     Stellen Sie sich zum Beispiel vor, sie wollten das
     Erstellungsprotokoll von GDB auf einem MIPS-System sehen, benutzen
     aber selbst eine ‘x86_64’-Maschine:

          $ guix build --log-file gdb -s mips64el-linux
          https://ci.guix.gnu.org/log/…-gdb-7.10

     So haben Sie umsonst Zugriff auf eine riesige Bibliothek von
     Erstellungsprotokollen!


File: guix.de.info,  Node: Fehlschläge beim Erstellen untersuchen,  Prev: Zusätzliche Erstellungsoptionen,  Up: Aufruf von guix build

7.1.4 Fehlschläge beim Erstellen untersuchen
--------------------------------------------

Wenn Sie ein neues Paket definieren (siehe *note Pakete definieren::),
werden Sie sich vermutlich einige Zeit mit der Fehlersuche beschäftigen
und die Erstellung so lange anpassen, bis sie funktioniert. Dazu müssen
Sie die Erstellungsbefehle selbst in einer Umgebung benutzen, die der,
die der Erstellungsdaemon aufbaut, so ähnlich wie möglich ist.

   Das Erste, was Sie dafür tun müssen, ist die Befehlszeilenoption
‘--keep-failed’ oder ‘-K’ von ‘guix build’ einzusetzen, wodurch
Verzeichnisbäume fehlgeschlagener Erstellungen in ‘/tmp’ oder dem von
Ihnen als ‘TMPDIR’ ausgewiesenen Verzeichnis erhalten und nicht gelöscht
werden (siehe *note ‘--keep-failed’: Aufruf von guix build.).

   Im Anschluss können Sie mit ‘cd’ in die Verzeichnisse dieses
fehlgeschlagenen Erstellungsbaums wechseln und mit ‘source’ dessen
‘environment-variables’-Datei laden, die alle
Umgebungsvariablendefinitionen enthält, die zum Zeitpunkt des
Fehlschlags der Erstellung galten. Sagen wir, Sie suchen Fehler in einem
Paket ‘foo’, dann würde eine typische Sitzung so aussehen:

     $ guix build foo -K
     … Erstellung schlägt fehl
     $ cd /tmp/guix-build-foo.drv-0
     $ source ./environment-variables
     $ cd foo-1.2

   Nun können Sie Befehle (fast) so aufrufen, als wären Sie der Daemon,
und Fehlerursachen in Ihrem Erstellungsprozess ermitteln.

   Manchmal passiert es, dass zum Beispiel die Tests eines Pakets
erfolgreich sind, wenn Sie sie manuell aufrufen, aber scheitern, wenn
der Daemon sie ausführt. Das kann passieren, weil der Daemon
Erstellungen in isolierten Umgebungen („Containern“) durchführt, wo,
anders als in der obigen Umgebung, kein Netzwerkzugang möglich ist,
‘/bin/sh’ nicht exisiert usw. (siehe *note Einrichten der
Erstellungsumgebung::).

   In solchen Fällen müssen Sie den Erstellungsprozess womöglich aus
einer zu der des Daemons ähnlichen isolierten Umgebung heraus
ausprobieren:

     $ guix build -K foo
     …
     $ cd /tmp/guix-build-foo.drv-0
     $ guix environment --no-grafts -C foo --ad-hoc strace gdb
     [env]# source ./environment-variables
     [env]# cd foo-1.2

   Hierbei erzeugt ‘guix environment -C’ eine isolierte Umgebung und
öffnet darin eine Shell (siehe *note Aufruf von guix environment::). Der
Teil mit ‘--ad-hoc strace gdb’ fügt die Befehle ‘strace’ und ‘gdb’ zur
isolierten Umgebung hinzu, die Sie gut gebrauchen könnten, während Sie
Fehler suchen. Wegen der Befehlszeilenoption ‘--no-grafts’ bekommen Sie
haargenau dieselbe Umgebung ohne veredelte Pakete (siehe *note
Sicherheitsaktualisierungen:: für mehr Informationen zu Veredelungen).

   Um der isolierten Umgebung des Erstellungsdaemons noch näher zu
kommen, können wir ‘/bin/sh’ entfernen:

     [env]# rm /bin/sh

   (Keine Sorge, das ist harmlos: All dies passiert nur in der zuvor von
‘guix environment’ erzeugten Wegwerf-Umgebung.)

   Der Befehl ‘strace’ befindet sich wahrscheinlich nicht in Ihrem
Suchpfad, aber wir können ihn so benutzen:

     [env]# $GUIX_ENVIRONMENT/bin/strace -f -o log make check

   Auf diese Weise haben Sie nicht nur die Umgebungsvariablen, die der
Daemon benutzt, nachgebildet, sondern lassen auch den Erstellungsprozess
in einer isolierten Umgebung ähnlich der des Daemons laufen.


File: guix.de.info,  Node: Aufruf von guix edit,  Next: Aufruf von guix download,  Prev: Aufruf von guix build,  Up: Zubehör

7.2 ‘guix edit’ aufrufen
========================

So viele Pakete, so viele Quelldateien! Der Befehl ‘guix edit’
erleichtert das Leben von sowohl Nutzern als auch Paketentwicklern,
indem er Ihren Editor anweist, die Quelldatei mit der Definition des
jeweiligen Pakets zu bearbeiten. Zum Beispiel startet dies:

     guix edit gcc@4.9 vim

das mit der Umgebungsvariablen ‘VISUAL’ ode ‘EDITOR’ angegebene Programm
und lässt es das Rezept von GCC 4.9.3 und von Vim anzeigen.

   Wenn Sie ein Git-Checkout von Guix benutzen (siehe *note Erstellung
aus dem Git::) oder Ihre eigenen Pakete im ‘GUIX_PACKAGE_PATH’ erstellt
haben (siehe *note Paketmodule::), werden Sie damit die Paketrezepte
auch bearbeiten können. Andernfalls werden Sie zumindest in die Lage
versetzt, die nur lesbaren Rezepte für sich im Moment im Store
befindliche Pakete zu untersuchen.

   Statt ‘GUIX_PACKAGE_PATH’ zu benutzen, können Sie mit der
Befehlszeilenoption ‘--load-path=VERZEICHNIS’ (oder kurz ‘-L
VERZEICHNIS’) das VERZEICHNIS vorne an den Paketmodul-Suchpfad anhängen
und so Ihre eigenen Pakete sichtbar machen.


File: guix.de.info,  Node: Aufruf von guix download,  Next: Aufruf von guix hash,  Prev: Aufruf von guix edit,  Up: Zubehör

7.3 ‘guix download’ aufrufen
============================

Wenn Entwickler einer Paketdefinition selbige schreiben, müssen diese
normalerweise einen Quellcode-Tarball herunterladen, seinen SHA256-Hash
als Prüfsumme berechnen und diese in der Paketdefinition eintragen
(siehe *note Pakete definieren::). Das Werkzeug ‘guix download’ hilft
bei dieser Aufgabe: Damit wird eine Datei von der angegebenen URI
heruntergeladen, in den Store eingelagert und sowohl ihr Dateiname im
Store als auch ihr SHA256-Hash als Prüfsumme angezeigt.

   Dadurch, dass die heruntergeladene Datei in den Store eingefügt wird,
wird Bandbreite gespart: Wenn der Entwickler schließlich versucht, das
neu definierte Paket mit ‘guix build’ zu erstellen, muss der
Quell-Tarball nicht erneut heruntergeladen werden, weil er sich bereits
im Store befindet. Es ist auch eine bequeme Methode, Dateien temporär
aufzubewahren, die letztlich irgendwann gelöscht werden (siehe *note
Aufruf von guix gc::).

   Der Befehl ‘guix download’ unterstützt dieselben URIs, die in
Paketdefinitionen verwendet werden. Insbesondere unterstützt er
‘mirror://’-URIs. ‘https’-URIs (HTTP über TLS) werden unterstützt,
_vorausgesetzt_ die Guile-Anbindungen für GnuTLS sind in der Umgebung
des Benutzers verfügbar; wenn nicht, wird ein Fehler gemeldet. Siehe
*note how to install the GnuTLS bindings for Guile: (gnutls-guile)Guile
Preparations, hat mehr Informationen.

   Mit ‘guix download’ werden HTTPS-Serverzertifikate verifiziert, indem
die Zertifikate der X.509-Autoritäten in das durch die Umgebungsvariable
‘SSL_CERT_DIR’ bezeichnete Verzeichnis heruntergeladen werden (siehe
*note X.509-Zertifikate::), außer ‘--no-check-certificate’ wird benutzt.

   Folgende Befehlszeilenoptionen stehen zur Verfügung:

‘--format=FORMAT’
‘-f FORMAT’
     Die Hash-Prüfsumme im angegebenen FORMAT ausgeben. Für weitere
     Informationen, was gültige Werte für das FORMAT sind, siehe *note
     Aufruf von guix hash::.

‘--no-check-certificate’
     X.509-Zertifikate von HTTPS-Servern _nicht_ validieren.

     Wenn Sie diese Befehlszeilenoption benutzen, haben Sie _keinerlei
     Garantie_, dass Sie tatsächlich mit dem authentischen Server, der
     für die angegebene URL verantwortlich ist, kommunizieren. Das macht
     Sie anfällig gegen sogenannte „Man-in-the-Middle“-Angriffe.

‘--output=DATEI’
‘-o DATEI’
     Die heruntergeladene Datei _nicht_ in den Store, sondern in die
     angegebene DATEI abspeichern.


File: guix.de.info,  Node: Aufruf von guix hash,  Next: Aufruf von guix import,  Prev: Aufruf von guix download,  Up: Zubehör

7.4 ‘guix hash’ aufrufen
========================

Der Befehl ‘guix hash’ berechnet den SHA256-Hash einer Datei. Er ist
primär ein Werkzeug, dass es bequemer macht, etwas zur Distribution
beizusteuern: Damit wird die kryptografische Hash-Prüfsumme berechnet,
die bei der Definition eines Pakets benutzt werden kann (siehe *note
Pakete definieren::).

   Die allgemeine Syntax lautet:

     guix hash OPTION DATEI

   Wird als DATEI ein Bindestrich ‘-’ angegeben, berechnet ‘guix hash’
den Hash der von der Standardeingabe gelesenen Daten. ‘guix hash’
unterstützt die folgenden Optionen:

‘--format=FORMAT’
‘-f FORMAT’
     Gibt die Prüfsumme im angegebenen FORMAT aus.

     Unterstützte Formate: ‘nix-base32’, ‘base32’, ‘base16’ (‘hex’ und
     ‘hexadecimal’ können auch benutzt werden).

     Wird keine Befehlszeilenoption ‘--format’ angegeben, wird ‘guix
     hash’ die Prüfsumme im ‘nix-base32’-Format ausgeben. Diese
     Darstellung wird bei der Definition von Paketen benutzt.

‘--recursive’
‘-r’
     Die Prüfsumme der DATEI rekursiv berechnen.

     In diesem Fall wird die Prüfsumme eines Archivs berechnet, das die
     DATEI enthält, und auch ihre Kinder, wenn es sich um ein
     Verzeichnis handelt. Einige der Metadaten der DATEI sind Teil
     dieses Archivs. Zum Beispiel unterscheidet sich die berechnete
     Prüfsumme, wenn die DATEI eine reguläre Datei ist, je nachdem, ob
     die DATEI ausführbar ist oder nicht. Metadaten wie der Zeitstempel
     haben keinen Einfluss auf die Prüfsumme (siehe *note Aufruf von
     guix archive::).

‘--exclude-vcs’
‘-x’
     Wenn dies zusammen mit der Befehlszeilenoption ‘--recursive’
     angegeben wird, werden Verzeichnisse zur Versionskontrolle (‘.bzr’,
     ‘.git’, ‘.hg’, etc.) vom Archiv ausgenommen.

     Zum Beispiel würden Sie auf diese Art die Prüfsumme eines
     Git-Checkouts berechnen, was nützlich ist, wenn Sie die Prüfsumme
     für die Methode ‘git-fetch’ benutzen (siehe *note
     „origin“-Referenz::):

          $ git clone http://example.org/foo.git
          $ cd foo
          $ guix hash -rx .


File: guix.de.info,  Node: Aufruf von guix import,  Next: Aufruf von guix refresh,  Prev: Aufruf von guix hash,  Up: Zubehör

7.5 ‘guix import’ aufrufen
==========================

Der Befehl ‘guix import’ ist für Leute hilfreich, die ein Paket gerne
mit so wenig Arbeit wie möglich zur Distribution hinzufügen würden — ein
legitimer Anspruch. Der Befehl kennt ein paar Sammlungen, aus denen mit
ihm Paketmetadaten „importiert“ werden können. Das Ergebnis ist eine
Paketdefinition oder eine Vorlage dafür in dem uns bekannten Format
(siehe *note Pakete definieren::).

   Die allgemeine Syntax lautet:

     guix import IMPORTER OPTIONEN…

   Der IMPORTER gibt die Quelle an, aus der Paketmetadaten importiert
werden, und die OPTIONEN geben eine Paketbezeichnung und andere vom
IMPORTER abhängige Daten an.

   Manche Importer setzen voraus, dass der Befehl ‘gpgv’ ausgeführt
werden kann. Sie funktionieren nur, wenn GnuPG installiert und im
‘$PATH’ enthalten ist; falls nötig können Sie ‘guix install gnupg’
ausführen.

   Derzeit sind folgende „Importer“ verfügbar:

‘gnu’
     Metadaten für das angegebene GNU-Paket importieren. Damit wird eine
     Vorlage für die neueste Version dieses GNU-Pakets zur Verfügung
     gestellt, einschließlich der Prüfsumme seines Quellcode-Tarballs,
     seiner kanonischen Zusammenfassung und seiner Beschreibung.

     Zusätzliche Informationen wie Paketabhängigkeiten und seine Lizenz
     müssen noch manuell ermittelt werden.

     Zum Beispiel liefert der folgende Befehl eine Paketdefinition für
     GNU Hello:

          guix import gnu hello

     Speziell für diesen Importer stehen noch folgende
     Befehlszeilenoptionen zur Verfügung:

     ‘--key-download=RICHTLINIE’
          Die Richtlinie zum Umgang mit fehlenden OpenPGP-Schlüsseln
          beim Verifizieren der Paketsignatur (auch „Beglaubigung“
          genannt) festlegen, wie bei ‘guix refresh’. Siehe *note
          ‘--key-download’: Aufruf von guix refresh.

‘pypi’
     Metadaten aus dem Python Package Index (https://pypi.python.org/)
     importieren. Informationen stammen aus der JSON-formatierten
     Beschreibung, die unter ‘pypi.python.org’ verfügbar ist, und
     enthalten meistens alle relevanten Informationen einschließlich der
     Abhängigkeiten des Pakets. Für maximale Effizienz wird empfohlen,
     das Hilfsprogramm ‘unzip’ zu installieren, damit der Importer
     „Python Wheels“ entpacken und daraus Daten beziehen kann.

     Der folgende Befehl importiert Metadaten für das Python-Paket
     namens ‘itsdangerous’:

          guix import pypi itsdangerous

     ‘--recursive’
     ‘-r’
          Den Abhängigkeitsgraphen des angegebenen Pakets beim Anbieter
          rekursiv durchlaufen und Paketausdrücke für alle solchen
          Pakete erzeugen, die es in Guix noch nicht gibt.

‘gem’
     Metadaten von RubyGems (https://rubygems.org/) importieren.
     Informationen kommen aus der JSON-formatierten Beschreibung, die
     auf ‘rubygems.org’ verfügbar ist, und enthält die relevantesten
     Informationen einschließlich der Laufzeitabhängigkeiten. Dies hat
     aber auch Schattenseiten — die Metadaten unterscheiden nicht
     zwischen Zusammenfassungen und Beschreibungen, daher wird dieselbe
     Zeichenkette für beides eingesetzt. Zudem fehlen Informationen zu
     nicht in Ruby geschriebenen Abhängigkeiten, die benötigt werden, um
     native Erweiterungen zu in Ruby geschriebenem Code zu erstellen.
     Diese herauszufinden bleibt dem Paketentwickler überlassen.

     Der folgende Befehl importiert Metadaten aus dem Ruby-Paket
     ‘rails’.

          guix import gem rails

     ‘--recursive’
     ‘-r’
          Den Abhängigkeitsgraphen des angegebenen Pakets beim Anbieter
          rekursiv durchlaufen und Paketausdrücke für alle solchen
          Pakete erzeugen, die es in Guix noch nicht gibt.

‘cpan’
     Importiert Metadaten von MetaCPAN (https://www.metacpan.org/).
     Informationen werden aus den JSON-formatierten Metadaten genommen,
     die über die Programmierschnittstelle („API“) von MetaCPAN
     (https://fastapi.metacpan.org/) angeboten werden, und enthalten die
     relevantesten Informationen wie zum Beispiel Modulabhängigkeiten.
     Lizenzinformationen sollten genau nachgeprüft werden. Wenn Perl im
     Store verfügbar ist, wird das Werkzeug ‘corelist’ benutzt, um
     Kernmodule in der Abhängigkeitsliste wegzulassen.

     Folgender Befehl importiert Metadaten für das Perl-Modul
     ‘Acme::Boolean’:

          guix import cpan Acme::Boolean

‘cran’
     Metadaten aus dem CRAN (https://cran.r-project.org/) importieren,
     der zentralen Sammlung für die statistische und grafische Umgebung
     GNU R (https://r-project.org).

     Informationen werden aus der Datei namens ‘DESCRIPTION’ des Pakets
     extrahiert.

     Der folgende Befehl importiert Metadaten für das ‘Cairo’-R-Paket:

          guix import cran Cairo

     Wird zudem ‘--recursive’ angegeben, wird der Importer den
     Abhängigkeitsgraphen des angegebenen Pakets beim Anbieter rekursiv
     durchlaufen und Paketausdrücke für all die Pakete erzeugen, die
     noch nicht Teil von Guix sind.

     Wird ‘--archive=bioconductor’ angegeben, werden Metadaten vom
     Bioconductor (https://www.bioconductor.org/) importiert, einer
     Sammlung von R-Paketen zur Analyse und zum Verständnis von großen
     Mengen genetischer Daten in der Bioinformatik.

     Informationen werden aus der Datei namens ‘DESCRIPTION’ im Archiv
     des Pakets extrahiert.

     Der folgende Befehl importiert Metadaten für das R-Paket
     ‘GenomicRanges’:

          guix import cran --archive=bioconductor GenomicRanges

     Schließlich können Sie auch solche R-Pakete importieren, die noch
     nicht auf CRAN oder im Bioconductor veröffentlicht wurden, solange
     sie in einem Git-Repository stehen. Benutzen Sie ‘--archive=git’
     gefolgt von der URL des Git-Repositorys.

          guix import cran --archive=git https://github.com/immunogenomics/harmony

‘texlive’
     Metadaten aus CTAN (https://www.ctan.org/), dem umfassenden
     TeX-Archivnetzwerk, herunterladen, was für TeX-Pakete benutzt wird,
     die Teil der TeX-Live-Distribution (https://www.tug.org/texlive/)
     sind.

     Informationen über das Paket werden über die von CTAN angebotene
     XML-Programmierschnittstelle bezogen, wohingegen der Quellcode aus
     dem SVN-Repository des TeX-Live-Projekts heruntergeladen wird. Das
     wird so gemacht, weil CTAN keine versionierten Archive vorhält.

     Der folgende Befehl importiert Metadaten für das TeX-Paket
     ‘fontspec’:

          guix import texlive fontspec

     Wenn ‘--archive=VERZEICHNIS’ angegeben wird, wird der Quellcode
     _nicht_ aus dem Unterverzeichnis ‘latex’ des
     ‘texmf-dist/source’-Baums im SVN-Repository von TeX Live
     heruntergeladen, sondern aus dem angegebenen Schwesterverzeichnis
     im selben Wurzelverzeichnis.

     Der folgende Befehl importiert Metadaten für das Paket ‘ifxetex’
     aus CTAN und lädt die Quelldateien aus dem Verzeichnis
     ‘texmf/source/generic’:

          guix import texlive --archive=generic ifxetex

‘json’
     Paketmetadaten aus einer lokalen JSON-Datei importieren. Betrachten
     Sie folgende Beispiel-Paketdefinition im JSON-Format:

          {
            "name": "hello",
            "version": "2.10",
            "source": "mirror://gnu/hello/hello-2.10.tar.gz",
            "build-system": "gnu",
            "home-page": "https://www.gnu.org/software/hello/",
            "synopsis": "Hello, GNU world: An example GNU package",
            "description": "GNU Hello prints a greeting.",
            "license": "GPL-3.0+",
            "native-inputs": ["gettext"]
          }

     Die Felder sind genauso benannt wie bei einem
     ‘<package>’-Verbundstyp (siehe *note Pakete definieren::).
     Referenzen zu anderen Paketen stehen darin als JSON-Liste von mit
     Anführungszeichen quotierten Zeichenketten wie ‘guile’ oder
     ‘guile@2.0’.

     Der Importer unterstützt auch eine ausdrücklichere Definition der
     Quelldateien mit den üblichen Feldern eines ‘<origin>’-Verbunds:

          {
            …
            "source": {
              "method": "url-fetch",
              "uri": "mirror://gnu/hello/hello-2.10.tar.gz",
              "sha256": {
                "base32": "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"
              }
            }
            …
          }

     Der folgende Befehl liest Metadaten aus der JSON-Datei ‘hello.json’
     und gibt einen Paketausdruck aus:

          guix import json hello.json

‘nix’
     Metadaten aus einer lokalen Kopie des Quellcodes der
     Nixpkgs-Distribution (https://nixos.org/nixpkgs/) importieren(1).
     Paketdefinitionen in Nixpkgs werden typischerweise in einer
     Mischung aus der Sprache von Nix und aus Bash-Code geschrieben.
     Dieser Befehl wird nur die abstrakte Paketstruktur, die in der
     Nix-Sprache geschrieben ist, importieren. Dazu gehören
     normalerweise alle grundlegenden Felder einer Paketdefinition.

     Beim Importieren eines GNU-Pakets werden Zusammenfassung und
     Beschreibung stattdessen durch deren kanonische Variante bei GNU
     ersetzt.

     Normalerweise würden Sie zunächst dies ausführen:

          export NIX_REMOTE=daemon

     damit ‘nix-instantiate’ nicht versucht, die Nix-Datenbank zu
     öffnen.

     Zum Beispiel importiert der Befehl unten die Paketdefinition von
     LibreOffice (genauer gesagt importiert er die Definition des an das
     Attribut ‘libreoffice’ auf oberster Ebene gebundenen Pakets):

          guix import nix ~/path/to/nixpkgs libreoffice

‘hackage’
     Metadaten aus Hackage (https://hackage.haskell.org/), dem zentralen
     Paketarchiv der Haskell-Gemeinde, importieren. Informationen werden
     aus Cabal-Dateien ausgelesen. Darin sind alle relevanten
     Informationen einschließlich der Paketabhängigkeiten enthalten.

     Speziell für diesen Importer stehen noch folgende
     Befehlszeilenoptionen zur Verfügung:

     ‘--stdin’
     ‘-s’
          Eine Cabal-Datei von der Standardeingabe lesen.
     ‘--no-test-dependencies’
     ‘-t’
          Keine Abhängigkeiten übernehmen, die nur von Testkatalogen
          benötigt werden.
     ‘--cabal-environment=ALISTE’
     ‘-e ALISTE’
          ALISTE muss eine assoziative Liste der
          Scheme-Programmiersprache sein, die die Umgebung definiert, in
          der bedingte Ausdrücke von Cabal ausgewertet werden. Dabei
          werden folgende Schlüssel akzeptiert: ‘os’, ‘arch’, ‘impl’ und
          eine Zeichenkette, die dem Namen einer Option (einer „Flag“)
          entspricht. Der mit einer „Flag“ assoziierte Wert muss
          entweder das Symbol ‘true’ oder ‘false’ sein. Der anderen
          Schlüsseln zugeordnete Wert muss mit der Definition des
          Cabal-Dateiformats konform sein. Der vorgegebene Wert zu den
          Schlüsseln ‘os’, ‘arch’ and ‘impl’ ist jeweils ‘linux’,
          ‘x86_64’ bzw. ‘ghc’.
     ‘--recursive’
     ‘-r’
          Den Abhängigkeitsgraphen des angegebenen Pakets beim Anbieter
          rekursiv durchlaufen und Paketausdrücke für alle solchen
          Pakete erzeugen, die es in Guix noch nicht gibt.

     Der folgende Befehl importiert Metadaten für die neuste Version des
     Haskell-‘HTTP’-Pakets, ohne Testabhängigkeiten zu übernehmen und
     bei Übergabe von ‘false’ als Wert der Flag ‘network-uri’:

          guix import hackage -t -e "'((\"network-uri\" . false))" HTTP

     Eine ganz bestimmte Paketversion kann optional ausgewählt werden,
     indem man nach dem Paketnamen anschließend ein At-Zeichen und eine
     Versionsnummer angibt wie in folgendem Beispiel:

          guix import hackage mtl@2.1.3.1

‘stackage’
     Der ‘stackage’-Importer ist ein Wrapper um den ‘hackage’-Importer.
     Er nimmt einen Paketnamen und schaut dafür die Paketversion nach,
     die Teil einer Stackage-Veröffentlichung (https://www.stackage.org)
     mit Langzeitunterstützung (englisch „Long-Term Support“, kurz LTS)
     ist, deren Metadaten er dann mit dem ‘hackage’-Importer bezieht.
     Beachten Sie, dass es Ihre Aufgabe ist, eine LTS-Veröffentlichung
     auszuwählen, die mit dem von Guix benutzten GHC-Compiler kompatibel
     ist.

     Speziell für diesen Importer stehen noch folgende
     Befehlszeilenoptionen zur Verfügung:

     ‘--no-test-dependencies’
     ‘-t’
          Keine Abhängigkeiten übernehmen, die nur von Testkatalogen
          benötigt werden.
     ‘--lts-version=VERSION’
     ‘-l VERSION’
          VERSION ist die gewünschte Version der LTS-Veröffentlichung.
          Wird keine angegeben, wird die neueste benutzt.
     ‘--recursive’
     ‘-r’
          Den Abhängigkeitsgraphen des angegebenen Pakets beim Anbieter
          rekursiv durchlaufen und Paketausdrücke für alle solchen
          Pakete erzeugen, die es in Guix noch nicht gibt.

     Der folgende Befehl importiert Metadaten für dasjenige
     ‘HTTP’-Haskell-Paket, das in der LTS-Stackage-Veröffentlichung mit
     Version 7.18 vorkommt:

          guix import stackage --lts-version=7.18 HTTP

‘elpa’
     Metadaten aus der Paketsammlung „Emacs Lisp Package Archive“ (ELPA)
     importieren (siehe *note (emacs)Packages::).

     Speziell für diesen Importer stehen noch folgende
     Befehlszeilenoptionen zur Verfügung:

     ‘--archive=REPO’
     ‘-a REPO’
          Mit REPO wird die Archiv-Sammlung (ein „Repository“)
          bezeichnet, von dem die Informationen bezogen werden sollen.
          Derzeit sind die unterstützten Repositorys und ihre
          Bezeichnungen folgende:
             - GNU (https://elpa.gnu.org/packages), bezeichnet mit
               ‘gnu’. Dies ist die Vorgabe.

               Pakete aus ‘elpa.gnu.org’ wurden mit einem der Schlüssel
               im GnuPG-Schlüsselbund in
               ‘share/emacs/25.1/etc/package-keyring.gpg’ (oder einem
               ähnlichen Pfad) des ‘emacs’-Pakets signiert (siehe *note
               ELPA package signatures: (emacs)Package Installation.).

             - MELPA-Stable (https://stable.melpa.org/packages),
               bezeichnet mit ‘melpa-stable’.

             - MELPA (https://melpa.org/packages), bezeichnet mit
               ‘melpa’.

     ‘--recursive’
     ‘-r’
          Den Abhängigkeitsgraphen des angegebenen Pakets beim Anbieter
          rekursiv durchlaufen und Paketausdrücke für alle solchen
          Pakete erzeugen, die es in Guix noch nicht gibt.

‘crate’
     Metadaten aus der Paketsammlung crates.io für Rust importieren
     crates.io (https://crates.io), wie Sie in diesem Beispiel sehen:

          guix import crate blake2-rfc

     Mit dem Crate-Importer können Sie auch eine Version als
     Zeichenkette angeben:

          guix import crate constant-time-eq@0.1.0

     Zu den zusätzlichen Optionen gehören:

     ‘--recursive’
     ‘-r’
          Den Abhängigkeitsgraphen des angegebenen Pakets beim Anbieter
          rekursiv durchlaufen und Paketausdrücke für alle solchen
          Pakete erzeugen, die es in Guix noch nicht gibt.

‘opam’
     Metadaten aus der Paketsammlung OPAM (https://opam.ocaml.org/) der
     OCaml-Gemeinde importieren.

   ‘guix import’ verfügt über eine modulare Code-Struktur. Mehr Importer
für andere Paketformate zu haben, wäre nützlich, und Ihre Hilfe ist
hierbei gerne gesehen (siehe *note Mitwirken::).

   ---------- Footnotes ----------

   (1) Dazu wird der Befehl ‘nix-instantiate’ von Nix
(https://nixos.org/nix/) verwendet.


File: guix.de.info,  Node: Aufruf von guix refresh,  Next: Aufruf von guix lint,  Prev: Aufruf von guix import,  Up: Zubehör

7.6 ‘guix refresh’ aufrufen
===========================

Die Zielgruppe des Befehls ‘guix refresh’ zum Auffrischen von Paketen
sind in erster Linie Entwickler der GNU-Software-Distribution. Nach
Vorgabe werden damit alle Pakete in der Distribution gemeldet, die nicht
der neuesten Version des Anbieters entsprechen, indem Sie dies
ausführen:

     $ guix refresh
     gnu/packages/gettext.scm:29:13: gettext would be upgraded from 0.18.1.1 to 0.18.2.1
     gnu/packages/glib.scm:77:12: glib would be upgraded from 2.34.3 to 2.37.0

   Alternativ können die zu betrachtenden Pakete dabei angegeben werden,
was zur Ausgabe einer Warnung führt, wenn es für Pakete kein
Aktualisierungsprogramm gibt:

     $ guix refresh coreutils guile guile-ssh
     gnu/packages/ssh.scm:205:2: warning: no updater for guile-ssh
     gnu/packages/guile.scm:136:12: guile would be upgraded from 2.0.12 to 2.0.13

   ‘guix refresh’ durchsucht die Paketsammlung beim Anbieter jedes
Pakets und bestimmt, was die höchste Versionsnummer ist, zu der es dort
eine Veröffentlichung gibt. Zum Befehl gehören Aktualisierungsprogramme,
mit denen bestimmte Typen von Paketen automatisch aktualisiert werden
können: GNU-Pakete, ELPA-Pakete usw. — siehe die Dokumentation von
‘--type’ unten. Es gibt jedoch auch viele Pakete, für die noch keine
Methode enthalten ist, um das Vorhandensein einer neuen Veröffentlichung
zu prüfen. Der Mechanismus ist aber erweiterbar, also können Sie gerne
mit uns in Kontakt treten, wenn Sie eine neue Methode hinzufügen
möchten!

‘--recursive’
     Hiermit werden die angegebenen Pakete betrachtet und außerdem alle
     Pakete, von denen sie abhängen.

          $ guix refresh --recursive coreutils
          gnu/packages/acl.scm:35:2: warning: no updater for acl
          gnu/packages/m4.scm:30:12: info: 1.4.18 is already the latest version of m4
          gnu/packages/xml.scm:68:2: warning: no updater for expat
          gnu/packages/multiprecision.scm:40:12: info: 6.1.2 is already the latest version of gmp
          …

   Manchmal unterscheidet sich der vom Anbieter benutzte Name von dem
Paketnamen, der in Guix verwendet wird, so dass ‘guix refresh’ etwas
Unterstützung braucht. Die meisten Aktualisierungsprogramme folgen der
Eigenschaft ‘upstream-name’ in Paketdefinitionen, die diese
Unterstützung bieten kann.

     (define-public network-manager
       (package
         (name "network-manager")
         ;; …
         (properties '((upstream-name . "NetworkManager")))))

   Wenn ‘--update’ übergeben wird, werden die Quelldateien der
Distribution verändert, so dass für diese Paketrezepte die aktuelle
Version und die aktuelle Hash-Prüfsumme des Quellcode-Tarballs
eingetragen wird (siehe *note Pakete definieren::). Dazu werden der
neueste Quellcode-Tarball jedes Pakets sowie die jeweils zugehörige
OpenPGP-Signatur heruntergeladen; mit Letzterer wird der
heruntergeladene Tarball gegen seine Signatur mit ‘gpgv’ authentifiziert
und schließlich dessen Hash berechnet. Beachten Sie, dass GnuPG dazu
installiert sein und in ‘$PATH’ vorkommen muss. Falls dies nicht der
Fall ist, führen Sie ‘guix install gnupg’ aus.

   Wenn der öffentliche Schlüssel, mit dem der Tarball signiert wurde,
im Schlüsselbund des Benutzers fehlt, wird versucht, ihn automatisch von
einem Schlüssel-Server zu holen. Wenn das klappt, wird der Schlüssel zum
Schlüsselbund des Benutzers hinzugefügt, ansonsten meldet ‘guix refresh’
einen Fehler.

   Die folgenden Befehlszeilenoptionen werden unterstützt:

‘--expression=AUSDRUCK’
‘-e AUSDRUCK’
     Als Paket benutzen, wozu der AUSDRUCK ausgewertet wird.

     Dies ist nützlich, um genau ein bestimmtes Paket zu referenzieren,
     wie in diesem Beispiel:

          guix refresh -l -e '(@@ (gnu packages commencement) glibc-final)'

     Dieser Befehls listet auf, was alles von der „endgültigen“
     Erstellung von libc abhängt (praktisch alle Pakete).

‘--update’
‘-u’
     Die Quelldateien der Distribution (die Paketrezepte) werden direkt
     „in place“ verändert. Normalerweise führen Sie dies aus einem
     Checkout des Guix-Quellbaums heraus aus (siehe *note Guix vor der
     Installation ausführen::):

          $ ./pre-inst-env guix refresh -s non-core -u

     Siehe *note Pakete definieren:: für mehr Informationen zu
     Paketdefinitionen.

‘--select=[TEILMENGE]’
‘-s TEILMENGE’
     Wählt alle Pakete aus der TEILMENGE aus, die entweder ‘core’ oder
     ‘non-core’ sein muss.

     Die ‘core’-Teilmenge bezieht sich auf alle Pakete, die den Kern der
     Distribution ausmachen, d.h. Pakete, aus denen heraus „alles
     andere“ erstellt wird. Dazu gehören GCC, libc, Binutils, Bash und
     so weiter. In der Regel ist die Folge einer Änderung an einem
     dieser Pakete in der Distribution, dass alle anderen neu erstellt
     werden müssen. Daher sind solche Änderungen unangenehm für Nutzer,
     weil sie einiges an Erstellungszeit oder Bandbreite investieren
     müssen, um die Aktualisierung abzuschließen.

     Die ‘non-core’-Teilmenge bezieht sich auf die übrigen Pakete. Sie
     wird typischerweise dann benutzt, wenn eine Aktualisierung der
     Kernpakete zu viele Umstände machen würde.

‘--manifest=DATEI’
‘-m DATEI’
     Wählt alle Pakete im in der DATEI stehenden Manifest aus. Das ist
     nützlich, um zu überprüfen, welche Pakete aus dem Manifest des
     Nutzers aktualisiert werden können.

‘--type=AKTUALISIERUNGSPROGRAMM’
‘-t AKTUALISIERUNGSPROGRAMM’
     Nur solche Pakete auswählen, die vom angegebenen
     AKTUALISIERUNGSPROGRAMM behandelt werden. Es darf auch eine
     kommagetrennte Liste mehrerer Aktualisierungsprogramme angegeben
     werden. Zur Zeit kann als AKTUALISIERUNGSPROGRAMM eines der
     folgenden angegeben werden:

     ‘gnu’
          Aktualisierungsprogramm für GNU-Pakete,
     ‘gnome’
          Aktualisierungsprogramm für GNOME-Pakete,
     ‘kde’
          Aktualisierungsprogramm für KDE-Pakete,
     ‘xorg’
          Aktualisierungsprogramm für X.org-Pakete,
     ‘kernel.org’
          Aktualisierungsprogramm auf kernel.org angebotener Pakete,
     ‘elpa’
          Aktualisierungsprogramm für ELPA-Pakete
          (https://elpa.gnu.org/),
     ‘cran’
          Aktualisierungsprogramm für CRAN-Pakete
          (https://cran.r-project.org/),
     ‘bioconductor’
          Aktualisierungsprogramm für R-Pakete vom Bioconductor
          (https://www.bioconductor.org/),
     ‘cpan’
          Aktualisierungsprogramm für CPAN-Pakete
          (https://www.cpan.org/),
     ‘pypi’
          Aktualisierungsprogramm für PyPI-Pakete
          (https://pypi.python.org),
     ‘gem’
          Aktualisierungsprogramm für RubyGems-Pakete
          (https://rubygems.org).
     ‘github’
          Aktualisierungsprogramm für GitHub-Pakete
          (https://github.com).
     ‘hackage’
          Aktualisierungsprogramm für Hackage-Pakete
          (https://hackage.haskell.org).
     ‘stackage’
          Aktualisierungsprogramm für Stackage-Pakete
          (https://www.stackage.org).
     ‘crate’
          Aktualisierungsprogramm für Crates-Pakete (https://crates.io).
     ‘launchpad’
          Aktualisierungsprogramm für Launchpad (https://launchpad.net).

     Zum Beispiel prüft folgender Befehl nur auf mögliche
     Aktualisierungen von auf ‘elpa.gnu.org’ angebotenen Emacs-Paketen
     und von CRAN-Paketen:

          $ guix refresh --type=elpa,cran
          gnu/packages/statistics.scm:819:13: r-testthat would be upgraded from 0.10.0 to 0.11.0
          gnu/packages/emacs.scm:856:13: emacs-auctex would be upgraded from 11.88.6 to 11.88.9

   An ‘guix refresh’ können auch ein oder mehrere Paketnamen übergeben
werden wie in diesem Beispiel:

     $ ./pre-inst-env guix refresh -u emacs idutils gcc@4.8

Der Befehl oben aktualisiert speziell das ‘emacs’- und das
‘idutils’-Paket. Eine Befehlszeilenoption ‘--select’ hätte dann keine
Wirkung.

   Wenn Sie sich fragen, ob ein Paket aktualisiert werden sollte oder
nicht, kann es helfen, sich anzuschauen, welche Pakete von der
Aktualisierung betroffen wären und auf Kompatibilität hin geprüft werden
sollten. Dazu kann die folgende Befehlszeilenoption zusammen mit einem
oder mehreren Paketnamen an ‘guix refresh’ übergeben werden:

‘--list-updaters’
‘-L’
     Eine Liste verfügbarer Aktualisierungsprogramme anzeigen und
     terminieren (siehe ‘--type’ oben).

     Für jedes Aktualisierungsprogramm den Anteil der davon betroffenen
     Pakete anzeigen; zum Schluss wird der Gesamtanteil von irgendeinem
     Aktualisierungsprogramm betroffener Pakete angezeigt.

‘--list-dependent’
‘-l’
     Auflisten, welche abhängigen Pakete auf oberster Ebene neu erstellt
     werden müssten, wenn eines oder mehrere Pakete aktualisiert würden.

     Siehe *note den ‘reverse-package’-Typ von ‘guix graph’: Aufruf von
     guix graph. für Informationen dazu, wie Sie die Liste der
     Abhängigen eines Pakets visualisieren können.

   Bedenken Sie, dass die Befehlszeilenoption ‘--list-dependent’ das
Ausmaß der nach einer Aktualisierungen benötigten Neuerstellungen nur
_annähert_. Es könnten auch unter Umständen mehr Neuerstellungen
anfallen.

     $ guix refresh --list-dependent flex
     Building the following 120 packages would ensure 213 dependent packages are rebuilt:
     hop@2.4.0 geiser@0.4 notmuch@0.18 mu@0.9.9.5 cflow@1.4 idutils@4.6 …

   Der oben stehende Befehl gibt einen Satz von Paketen aus, die Sie
erstellen wollen könnten, um die Kompatibilität einer Aktualisierung des
‘flex’-Pakets beurteilen zu können.

‘--list-transitive’
     Die Pakete auflisten, von denen eines oder mehrere Pakete abhängen.

          $ guix refresh --list-transitive flex
          flex@2.6.4 depends on the following 25 packages: perl@5.28.0 help2man@1.47.6
          bison@3.0.5 indent@2.2.10 tar@1.30 gzip@1.9 bzip2@1.0.6 xz@5.2.4 file@5.33 …

   Der oben stehende Befehl gibt einen Satz von Paketen aus, die, wenn
sie geändert würden, eine Neuerstellung des ‘flex’-Pakets auslösen
würden.

   Mit den folgenden Befehlszeilenoptionen können Sie das Verhalten von
GnuPG anpassen:

‘--gpg=BEFEHL’
     Den BEFEHL als GnuPG-2.x-Befehl einsetzen. Der BEFEHL wird im
     ‘$PATH’ gesucht.

‘--keyring=DATEI’
     Die DATEI als Schlüsselbund mit Anbieterschlüsseln verwenden. Die
     DATEI muss im “Keybox-Format” vorliegen. Keybox-Dateien haben
     normalerweise einen Namen, der auf ‘.kbx’ endet. Sie können mit
     Hilfe von GNU Privacy Guard (GPG) bearbeitet werden (siehe *note
     ‘kbxutil’: (gnupg)kbxutil. für Informationen über ein Werkzeug zum
     Bearbeiten von Keybox-Dateien).

     Wenn diese Befehlszeilenoption nicht angegeben wird, benutzt ‘guix
     refresh’ die Keybox-Datei ‘~/.config/guix/upstream/trustedkeys.kbx’
     als Schlüsselbund für Signierschlüssel von Anbietern.
     OpenPGP-Signaturen werden mit Schlüsseln aus diesem Schlüsselbund
     überprüft; fehlende Schlüssel werden auch in diesen Schlüsselbund
     heruntergeladen (siehe ‘--key-download’ unten).

     Sie können Schlüssel aus Ihrem normalerweise benutzten
     GPG-Schlüsselbund in eine Keybox-Datei exportieren, indem Sie
     Befehle wie diesen benutzen:

          gpg --export rms@gnu.org | kbxutil --import-openpgp >> mykeyring.kbx

     Ebenso können Sie wie folgt Schlüssel in eine bestimmte
     Keybox-Datei herunterladen:

          gpg --no-default-keyring --keyring mykeyring.kbx \
            --recv-keys 3CE464558A84FDC69DB40CFB090B11993D9AEBB5

     Siehe *note ‘--keyring’: (gnupg)GPG Configuration Options. für mehr
     Informationen zur Befehlszeilenoption ‘--keyring’ von GPG.

‘--key-download=RICHTLINIE’
     Fehlende OpenPGP-Schlüssel gemäß dieser RICHTLINIE behandeln, für
     die eine der Folgenden angegeben werden kann:

     ‘always’
          Immer fehlende OpenPGP-Schlüssel herunterladen und zum
          GnuPG-Schlüsselbund des Nutzers hinzufügen.

     ‘never’
          Niemals fehlende OpenPGP-Schlüssel herunterladen, sondern
          einfach abbrechen.

     ‘interactive’
          Ist ein Paket mit einem unbekannten OpenPGP-Schlüssel
          signiert, wird der Nutzer gefragt, ob der Schlüssel
          heruntergeladen werden soll oder nicht. Dies entspricht dem
          vorgegebenen Verhalten.

‘--key-server=HOST’
     Den mit HOST bezeichneten Rechner als Schlüsselserver für OpenPGP
     benutzen, wenn ein öffentlicher Schlüssel importiert wird.

‘--load-path=VERZEICHNIS’
     Das VERZEICHNIS vorne an den Suchpfad für Paketmodule anfügen
     (siehe *note Paketmodule::).

     Damit können Nutzer dafür sorgen, dass ihre eigenen
     selbstdefinierten Pakete für die Befehlszeilenwerkzeuge sichtbar
     sind.

   Das ‘github’-Aktualisierungsprogramm benutzt die
GitHub-Programmierschnittstelle (https://developer.github.com/v3/) (die
„Github-API“), um Informationen über neue Veröffentlichungen einzuholen.
Geschieht dies oft, z.B. beim Auffrischen aller Pakete, so wird GitHub
irgendwann aufhören, weitere API-Anfragen zu beantworten. Normalerweise
sind 60 API-Anfragen pro Stunde erlaubt, für eine vollständige
Auffrischung aller GitHub-Pakete in Guix werden aber mehr benötigt. Wenn
Sie sich bei GitHub mit Ihrem eigenen API-Token authentisieren, gelten
weniger einschränkende Grenzwerte. Um einen API-Token zu benutzen,
setzen Sie die Umgebungsvariable ‘GUIX_GITHUB_TOKEN’ auf einen von
<https://github.com/settings/tokens> oder anderweitig bezogenen
API-Token.


File: guix.de.info,  Node: Aufruf von guix lint,  Next: Aufruf von guix size,  Prev: Aufruf von guix refresh,  Up: Zubehör

7.7 ‘guix lint’ aufrufen
========================

Den Befehl ‘guix lint’ gibt es, um Paketentwicklern beim Vermeiden
häufiger Fehler und bei der Einhaltung eines konsistenten Code-Stils zu
helfen. Er führt eine Reihe von Prüfungen auf einer angegebenen Menge
von Paketen durch, um in deren Definition häufige Fehler aufzuspüren. Zu
den verfügbaren “Prüfern” gehören (siehe ‘--list-checkers’ für eine
vollständige Liste):

‘synopsis’
‘description’
     Überprüfen, ob bestimmte typografische und stilistische Regeln in
     Paketbeschreibungen und -zusammenfassungen eingehalten wurden.

‘inputs-should-be-native’
     Eingaben identifizieren, die wahrscheinlich native Eingaben sein
     sollten.

‘source’
‘home-page’
‘mirror-url’
‘github-url’
‘source-file-name’
     Die URLs für die Felder ‘home-page’ und ‘source’ anrufen und nicht
     erreichbare URLs melden. Wenn passend, wird eine ‘mirror://’-URL
     vorgeschlagen. Wenn die Quell-URL auf eine GitHub-URL weiterleitet,
     wird eine Empfehlung ausgegeben, direkt letztere zu verwenden. Es
     wird geprüft, dass der Quell-Dateiname aussagekräftig ist, dass er
     also z.B. nicht nur aus einer Versionsnummer besteht oder als
     „git-checkout“ angegeben wurde, ohne dass ein ‘Dateiname’
     deklariert wurde (siehe *note „origin“-Referenz::).

‘source-unstable-tarball’
     Analysiert die ‘source’-URL, um zu bestimmen, ob der Tarball von
     GitHub automatisch generiert wurde oder zu einer Veröffentlichung
     gehört. Leider werden GitHubs automatisch generierte Tarballs
     manchmal neu generiert.

‘archival’
     Überprüft, ob der Quellcode des Pakets bei der Software Heritage
     (https://www.softwareheritage.org) archiviert ist.

     Wenn der noch nicht archivierte Quellcode aus einem
     Versionskontrollsystem („Version Control System“, VCS) stammt, wenn
     er also z.B. mit ‘git-fetch’ bezogen wird, wird eine Anfrage an
     Software Heritage gestellt, diesen zu speichern („Save“), damit sie
     ihn irgendwann in deren Archiv aufnehmen. So wird gewährleistet,
     dass der Quellcode langfristig verfügbar bleibt und Guix notfalls
     auf Software Heritage zurückgreifen kann, falls der Quellcode bei
     seinem ursprünglichen Anbieter verschwindet. Der Status kürzlicher
     Archivierungsanfragen kann online eingesehen werden
     (https://archive.softwareheritage.org/save/#requests).

     Wenn der Quellcode in Form eines über ‘url-fetch’ zu beziehenden
     Tarballs vorliegt, wird bloß eine Nachricht ausgegeben, wenn er
     nicht archiviert ist. Zum Zeitpunkt, wo dies geschrieben wurde,
     ermöglicht Software Heritage keine Anfragen, beliebige Tarballs zu
     archivieren; wir arbeiten an Möglichkeiten wie auch _nicht_
     versionskontrollierter Quellcode archiviert werden kann.

     Software Heritage beschränkt
     (https://archive.softwareheritage.org/api/#rate-limiting), wie
     schnell dieselbe IP-Adresse Anfragen stellen kann. Ist das Limit
     erreicht, gibt ‘guix lint’ eine Mitteilung aus und der
     ‘archival’-Prüfer steht so lange still, bis die Beschränkung wieder
     zurückgesetzt wurde.

‘cve’
     Bekannte Sicherheitslücken melden, die in den Datenbanken der
     „Common Vulnerabilities and Exposures“ (CVE) aus diesem und dem
     letzten Jahr vorkommen, wie sie von der US-amerikanischen NIST
     veröffentlicht werden (https://nvd.nist.gov/vuln/data-feeds).

     Um Informationen über eine bestimmte Sicherheitslücke angezeigt zu
     bekommen, besuchen Sie Webseiten wie:

        • 
          ‘https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-YYYY-ABCD’
        • ‘https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-YYYY-ABCD’

     wobei Sie statt ‘CVE-YYYY-ABCD’ die CVE-Kennnummer angeben — z.B.
     ‘CVE-2015-7554’.

     Paketentwickler können in ihren Paketrezepten den Namen und die
     Version des Pakets in der Common Platform Enumeration (CPE)
     (https://nvd.nist.gov/products/cpe) angeben, falls sich diese von
     dem in Guix benutzten Namen und der Version unterscheiden, zum
     Beispiel so:

          (package
            (name "grub")
            ;; …
            ;; CPE bezeichnet das Paket als "grub2".
            (properties '((cpe-name . "grub2")
                          (cpe-version . "2.3"))))

     Manche Einträge in der CVE-Datenbank geben die Version des Pakets
     nicht an, auf das sie sich beziehen, und würden daher bis in alle
     Ewigkeit Warnungen auslösen. Paketentwickler, die CVE-Warnmeldungen
     gefunden und geprüft haben, dass diese ignoriert werden können,
     können sie wie in diesem Beispiel deklarieren:

          (package
            (name "t1lib")
            ;; …
            ;; Diese CVEs treffen nicht mehr zu und können bedenkenlos ignoriert
            ;; werden.
            (properties `((lint-hidden-cve . ("CVE-2011-0433"
                                              "CVE-2011-1553"
                                              "CVE-2011-1554"
                                              "CVE-2011-5244")))))

‘Formatierung’
     Offensichtliche Fehler bei der Formatierung von Quellcode melden,
     z.B. Leerraum-Zeichen am Zeilenende oder Nutzung von
     Tabulatorzeichen.

   Die allgemeine Syntax lautet:

     guix lint OPTIONEN PAKETE…

   Wird kein Paket auf der Befehlszeile angegeben, dann werden alle
Pakete geprüft, die es gibt. Als OPTIONEN können null oder mehr der
folgenden Befehlszeilenoptionen übergeben werden:

‘--list-checkers’
‘-l’
     Alle verfügbaren Prüfer für die Pakete auflisten und beschreiben.

‘--checkers’
‘-c’
     Nur die Prüfer aktivieren, die hiernach in einer kommagetrennten
     Liste aus von ‘--list-checkers’ aufgeführten Prüfern vorkommen.

‘--load-path=VERZEICHNIS’
‘-L VERZEICHNIS’
     Das VERZEICHNIS vorne an den Suchpfad für Paketmodule anfügen
     (siehe *note Paketmodule::).

     Damit können Nutzer dafür sorgen, dass ihre eigenen
     selbstdefinierten Pakete für die Befehlszeilenwerkzeuge sichtbar
     sind.


File: guix.de.info,  Node: Aufruf von guix size,  Next: Aufruf von guix graph,  Prev: Aufruf von guix lint,  Up: Zubehör

7.8 ‘guix size’ aufrufen
========================

Der Befehl ‘guix size’ hilft Paketentwicklern dabei, den
Plattenplatzverbrauch von Paketen zu profilieren. Es ist leicht, die
Auswirkungen zu unterschätzen, die das Hinzufügen zusätzlicher
Abhängigkeiten zu einem Paket hat oder die das Verwenden einer einzelnen
Ausgabe für ein leicht aufteilbares Paket ausmacht (siehe *note Pakete
mit mehreren Ausgaben.::). Das sind typische Probleme, auf die ‘guix
size’ aufmerksam machen kann.

   Dem Befehl können eine oder mehrere Paketspezifikationen wie
‘gcc@4.8’ oder ‘guile:debug’ übergeben werden, oder ein Dateiname im
Store. Betrachten Sie dieses Beispiel:

     $ guix size coreutils
     Store-Objekt                            Gesamt   Selbst
     /gnu/store/…-gcc-5.5.0-lib           60.4    30.1  38.1%
     /gnu/store/…-glibc-2.27              30.3    28.8  36.6%
     /gnu/store/…-coreutils-8.28          78.9    15.0  19.0%
     /gnu/store/…-gmp-6.1.2               63.1     2.7   3.4%
     /gnu/store/…-bash-static-4.4.12       1.5     1.5   1.9%
     /gnu/store/…-acl-2.2.52              61.1     0.4   0.5%
     /gnu/store/…-attr-2.4.47             60.6     0.2   0.3%
     /gnu/store/…-libcap-2.25             60.5     0.2   0.2%
     Gesamt: 78.9 MiB

   Die hier aufgelisteten Store-Objekte bilden den “transitiven
Abschluss” der Coreutils — d.h. die Coreutils und all ihre
Abhängigkeiten und deren Abhängigkeiten, rekursiv —, wie sie hiervon
angezeigt würden:<f

     $ guix gc -R /gnu/store/…-coreutils-8.23

   Hier zeigt die Ausgabe neben den Store-Objekten noch drei Spalten.
Die erste Spalte namens „Gesamt“ gibt wieder, wieviele Mebibytes (MiB)
der Abschluss des Store-Objekts groß ist — das heißt, dessen eigene
Größe plus die Größe all seiner Abhängigkeiten. Die nächste Spalte,
bezeichnet mit „Selbst“, zeigt die Größe nur dieses Objekts an. Die
letzte Spalte zeigt das Verhältnis der Größe des Objekts zur Gesamtgröße
aller hier aufgelisteten Objekte an.

   In diesem Beispiel sehen wir, dass der Abschluss der Coreutils 79 MiB
schwer ist, wovon das meiste durch libc und die Bibliotheken zur
Laufzeitunterstützung von GCC ausgemacht wird. (Dass libc und die
Bibliotheken vom GCC einen großen Anteil am Abschluss ausmachen, ist
aber an sich noch kein Problem, weil es Bibliotheken sind, die auf dem
System sowieso immer verfügbar sein müssen.)

   Wenn das oder die Paket(e), die an ‘guix size’ übergeben wurden, im
Store verfügbar sind(1), beauftragen Sie mit ‘guix size’ den Daemon, die
Abhängigkeiten davon zu bestimmen und deren Größe im Store zu messen,
ähnlich wie es mit ‘du -ms --apparent-size’ geschehen würde (siehe *note
(coreutils)du invocation::).

   Wenn die übergebenen Pakete _nicht_ im Store liegen, erstattet ‘guix
size’ Bericht mit Informationen, die aus verfügbaren Substituten
herausgelesen werden (siehe *note Substitute::). Dadurch kann die
Plattenausnutzung von Store-Objekten profiliert werden, die gar nicht
auf der Platte liegen und nur auf entfernten Rechnern vorhanden sind.

   Sie können auch mehrere Paketnamen angeben:

     $ guix size coreutils grep sed bash
     Store-Objekt                            Gesamt   Selbst
     /gnu/store/…-coreutils-8.24          77.8    13.8  13.4%
     /gnu/store/…-grep-2.22               73.1     0.8   0.8%
     /gnu/store/…-bash-4.3.42             72.3     4.7   4.6%
     /gnu/store/…-readline-6.3            67.6     1.2   1.2%
     …
     Gesamt: 102.3 MiB

In diesem Beispiel sehen wir, dass die Kombination der vier Pakete
insgesamt 102,3 MiB Platz verbraucht, was wesentlich weniger als die
Summe der einzelnen Abschlüsse ist, weil diese viele Abhängigkeiten
gemeinsam verwenden.

   Die verfügbaren Befehlszeilenoptionen sind:

‘--substitute-urls=URLS’
     Substitutinformationen von den URLS benutzen. Siehe *note dieselbe
     Option bei ‘guix build’: client-substitute-urls.

‘--sort=SCHLÜSSEL’
     Zeilen anhand des SCHLÜSSELs sortieren, der eine der folgenden
     Alternativen sein muss:

     ‘self’
          die Größe jedes Objekts (die Vorgabe),
     ‘Abschluss’
          die Gesamtgröße des Abschlusses des Objekts.

‘--map-file=DATEI’
     Eine grafische Darstellung des Plattenplatzverbrauchs als eine
     PNG-formatierte Karte in die DATEI schreiben.

     Für das Beispiel oben sieht die Karte so aus:

 [image src="images/coreutils-size-map.png" alt="Karte der Plattenausnutzung der
Coreutils" ]

     Diese Befehlszeilenoption setzt voraus, dass Guile-Charting
     (https://wingolog.org/software/guile-charting/) installiert und im
     Suchpfad für Guile-Module sichtbar ist. Falls nicht, schlägt ‘guix
     size’ beim Versuch fehl, dieses Modul zu laden.

‘--system=SYSTEM’
‘-s SYSTEM’
     Pakete für dieses SYSTEM betrachten — z.B. für ‘x86_64-linux’.

‘--load-path=VERZEICHNIS’
‘-L VERZEICHNIS’
     Das VERZEICHNIS vorne an den Suchpfad für Paketmodule anfügen
     (siehe *note Paketmodule::).

     Damit können Nutzer dafür sorgen, dass ihre eigenen
     selbstdefinierten Pakete für die Befehlszeilenwerkzeuge sichtbar
     sind.

   ---------- Footnotes ----------

   (1) Genauer gesagt braucht ‘guix size’ die _nicht veredelte_ Variante
des angegebenen Pakets bzw. der Pakete, wie ‘guix build PAKET
--no-grafts’ sie liefert. Siehe *note Sicherheitsaktualisierungen:: für
Informationen über Veredelungen.


File: guix.de.info,  Node: Aufruf von guix graph,  Next: Aufruf von guix publish,  Prev: Aufruf von guix size,  Up: Zubehör

7.9 ‘guix graph’ aufrufen
=========================

Pakete und ihre Abhängigkeiten bilden einen “Graphen”, genauer gesagt
einen gerichteten azyklischen Graphen (englisch „Directed Acyclic
Graph“, kurz DAG). Es kann schnell schwierig werden, ein Modell eines
Paket-DAGs vor dem geistigen Auge zu behalten, weshalb der Befehl ‘guix
graph’ eine visuelle Darstellung des DAGs bietet. Das vorgegebene
Verhalten von ‘guix graph’ ist, eine DAG-Darstellung im Eingabeformat
von Graphviz (https://www.graphviz.org/) auszugeben, damit die Ausgabe
direkt an den Befehl ‘dot’ aus Graphviz weitergeleitet werden kann. Es
kann aber auch eine HTML-Seite mit eingebettetem JavaScript-Code
ausgegeben werden, um ein Sehnendiagramm (englisch „Chord Diagram“) in
einem Web-Browser anzuzeigen, mit Hilfe der Bibliothek d3.js
(https://d3js.org/), oder es können Cypher-Anfragen ausgegeben werden,
mit denen eine die Anfragesprache openCypher
(https://www.opencypher.org/) unterstützende Graph-Datenbank einen
Graphen konstruieren kann. Die allgemeine Syntax ist:

     guix graph OPTIONEN PAKETE…

   Zum Beispiel erzeugt der folgende Befehl eine PDF-Datei, die den
Paket-DAG für die GNU Core Utilities darstellt, welcher ihre
Abhängigkeiten zur Erstellungszeit anzeigt:

     guix graph coreutils | dot -Tpdf > dag.pdf

   Die Ausgabe sieht so aus:

 [image src="images/coreutils-graph.png" alt="Abhängigkeitsgraph der GNU Coreutils" ]

   Ein netter, kleiner Graph, oder?

   Aber es gibt mehr als eine Art von Graph! Der Graph oben ist kurz und
knapp: Es ist der Graph der Paketobjekte, ohne implizite Eingaben wie
GCC, libc, grep und so weiter. Oft möchte man einen knappen Graphen
sehen, aber manchmal will man auch mehr Details sehen. ‘guix graph’
unterstützt mehrere Typen von Graphen; Sie können den Detailgrad
auswählen.

‘package’
     Der vorgegebene Typ aus dem Beispiel oben. Er zeigt den DAG der
     Paketobjekte ohne implizite Abhängigkeiten. Er ist knapp, filtert
     aber viele Details heraus.

‘reverse-package’
     Dies zeigt den _umgekehrten_ DAG der Pakete. Zum Beispiel liefert

          guix graph --type=reverse-package ocaml

     … den Graphen der Pakete, die _explizit_ von OCaml abhängen (wenn
     Sie auch an Fällen interessiert sind, bei denen OCaml eine
     implizite Abhängigkeit ist, siehe ‘reverse-bag’ weiter unten).

     Beachten Sie, dass für Kernpakete damit gigantische Graphen
     entstehen können. Wenn Sie nur die Anzahl der Pakete wissen wollen,
     die von einem gegebenen Paket abhängen, benutzen Sie ‘guix refresh
     --list-dependent’ (siehe *note ‘--list-dependent’: Aufruf von guix
     refresh.).

‘bag-emerged’
     Dies ist der Paket-DAG _einschließlich_ impliziter Eingaben.

     Zum Beispiel liefert der folgende Befehl

          guix graph --type=bag-emerged coreutils | dot -Tpdf > dag.pdf

     … diesen größeren Graphen:

 [image src="images/coreutils-bag-graph.png" alt="Detaillierter Abhängigkeitsgraph der
GNU Coreutils" ]

     Am unteren Rand des Graphen sehen wir alle impliziten Eingaben des
     GNU-BUILD-SYSTEM (siehe *note ‘gnu-build-system’:
     Erstellungssysteme.).

     Beachten Sie dabei aber, dass auch hier die Abhängigkeiten dieser
     impliziten Eingaben — d.h. die “Bootstrap-Abhängigkeiten” (siehe
     *note Bootstrapping::) — nicht gezeigt werden, damit der Graph
     knapper bleibt.

‘bag’
     Ähnlich wie ‘bag-emerged’, aber diesmal mit allen
     Bootstrap-Abhängigkeiten.

‘bag-with-origins’
     Ähnlich wie ‘bag’, aber auch mit den Ursprüngen und deren
     Abhängigkeiten.

‘reverse-bag’
     Dies zeigt den _umgekehrten_ DAG der Pakete. Anders als
     ‘reverse-package’ werden auch implizite Abhängigkeiten
     berücksichtigt. Zum Beispiel liefert

          guix graph -t reverse-bag dune

     … den Graphen aller Pakete, die von Dune direkt oder indirekt
     abhängen. Weil Dune eine _implizite_ Abhängigkeit von vielen
     Paketen über das ‘dune-build-system’ ist, zeigt er eine große Zahl
     von Paketen, während bei ‘reverse-package’ nur sehr wenige bis gar
     keine zu sehen sind.

‘Ableitung’
     Diese Darstellung ist am detailliertesten: Sie zeigt den DAG der
     Ableitungen (siehe *note Ableitungen::) und der einfachen
     Store-Objekte. Verglichen mit obiger Darstellung sieht man viele
     zusätzliche Knoten einschließlich Erstellungs-Skripts, Patches,
     Guile-Module usw.

     Für diesen Typ Graph kann auch der Name einer ‘.drv’-Datei anstelle
     eines Paketnamens angegeben werden, etwa so:

          guix graph -t derivation `guix system build -d my-config.scm`

‘module’
     Dies ist der Graph der “Paketmodule” (siehe *note Paketmodule::).
     Zum Beispiel zeigt der folgende Befehl den Graphen für das
     Paketmodul an, das das ‘guile’-Paket definiert:

          guix graph -t module guile | dot -Tpdf > modul-graph.pdf

   Alle oben genannten Typen entsprechen _Abhängigkeiten zur
Erstellungszeit_. Der folgende Graphtyp repräsentiert die
_Abhängigkeiten zur Laufzeit_:

‘references’
     Dies ist der Graph der “Referenzen” einer Paketausgabe, wie ‘guix
     gc --references’ sie liefert (siehe *note Aufruf von guix gc::).

     Wenn die angegebene Paketausgabe im Store nicht verfügbar ist,
     versucht ‘guix graph’, die Abhängigkeitsinformationen aus
     Substituten zu holen.

     Hierbei können Sie auch einen Store-Dateinamen statt eines
     Paketnamens angeben. Zum Beispiel generiert der Befehl unten den
     Referenzgraphen Ihres Profils (der sehr groß werden kann!):

          guix graph -t references `readlink -f ~/.guix-profile`

‘referrers’
     Dies ist der Graph der ein Store-Objekt “referenzierenden” Objekte,
     wie ‘guix gc --referrers’ sie liefern würde (siehe *note Aufruf von
     guix gc::).

     Er basiert ausschließlich auf lokalen Informationen aus Ihrem
     Store. Nehmen wir zum Beispiel an, dass das aktuelle Inkscape in 10
     Profilen verfügbar ist, dann wird ‘guix graph -t referrers
     inkscape’ einen Graph zeigen, der bei Inkscape gewurzelt ist und
     Kanten zu diesen 10 Profilen hat.

     Ein solcher Graph kann dabei helfen, herauszufinden, weshalb ein
     Store-Objekt nicht vom Müllsammler abgeholt werden kann.

   Folgendes sind die verfügbaren Befehlszeilenoptionen:

‘--type=TYP’
‘-t TYP’
     Eine Graph-Ausgabe dieses TYPs generieren. Dieser TYP muss einer
     der oben genannten Werte sein.

‘--list-types’
     Die unterstützten Graph-Typen auflisten.

‘--backend=BACKEND’
‘-b BACKEND’
     Einen Graph mit Hilfe des ausgewählten BACKENDs generieren.

‘--list-backends’
     Die unterstützten Graph-Backends auflisten.

     Derzeit sind die verfügbaren Backends Graphviz und d3.js.

‘--expression=AUSDRUCK’
‘-e AUSDRUCK’
     Als Paket benutzen, wozu der AUSDRUCK ausgewertet wird.

     Dies ist nützlich, um genau ein bestimmtes Paket zu referenzieren,
     wie in diesem Beispiel:

          guix graph -e '(@@ (gnu packages commencement) gnu-make-final)'

‘--system=SYSTEM’
‘-s SYSTEM’
     Den Graphen für das SYSTEM anzeigen — z.B. ‘i686-linux’.

     Der Abhängigkeitsgraph ist größtenteils von der Systemarchitektur
     unabhängig, aber ein paar architekturabhängige Teile können Ihnen
     mit dieser Befehlszeilenoption visualisiert werden.

‘--load-path=VERZEICHNIS’
‘-L VERZEICHNIS’
     Das VERZEICHNIS vorne an den Suchpfad für Paketmodule anfügen
     (siehe *note Paketmodule::).

     Damit können Nutzer dafür sorgen, dass ihre eigenen
     selbstdefinierten Pakete für die Befehlszeilenwerkzeuge sichtbar
     sind.

   Hinzu kommt, dass ‘guix graph’ auch all die üblichen
Paketumwandlungsoptionen unterstützt (siehe *note
Paketumwandlungsoptionen::). Somit ist es kein Problem, die Folgen einer
den Paketgraphen umschreibenden Umwandlung wie ‘--with-input’ zu
erkennen. Zum Beispiel gibt der folgende Befehl den Graphen von ‘git’
aus, nachdem ‘openssl’ an allen Stellen im Graphen durch ‘libressl’
ersetzt wurde:

     guix graph git --with-input=openssl=libressl

   Ihrem Vergnügen sind keine Grenzen gesetzt!


File: guix.de.info,  Node: Aufruf von guix publish,  Next: Aufruf von guix challenge,  Prev: Aufruf von guix graph,  Up: Zubehör

7.10 ‘guix publish’ aufrufen
============================

Der Zweck von ‘guix publish’ ist, es Nutzern zu ermöglichen, ihren Store
auf einfache Weise mit anderen zu teilen, die ihn dann als
Substitutserver einsetzen können (siehe *note Substitute::).

   Wenn ‘guix publish’ ausgeführt wird, wird dadurch ein HTTP-Server
gestartet, so dass jeder mit Netzwerkzugang davon Substitute beziehen
kann. Das bedeutet, dass jede Maschine, auf der Guix läuft, auch als
Erstellungsfarm fungieren kann, weil die HTTP-Schnittstelle mit Cuirass,
der Software, mit der die offizielle Erstellungsfarm ‘ci.guix.gnu.org’
betrieben wird, kompatibel ist.

   Um Sicherheit zu gewährleisten, wird jedes Substitut signiert, so
dass Empfänger dessen Authentizität und Integrität nachprüfen können
(siehe *note Substitute::). Weil ‘guix publish’ den Signierschlüssel des
Systems benutzt, der nur vom Systemadministrator gelesen werden kann,
muss es als der Administratornutzer „root“ gestartet werden. Mit der
Befehlszeilenoption ‘--user’ werden Administratorrechte bald nach dem
Start wieder abgelegt.

   Das Schlüsselpaar zum Signieren muss erzeugt werden, bevor ‘guix
publish’ gestartet wird. Dazu können Sie ‘guix archive --generate-key’
ausführen (siehe *note Aufruf von guix archive::).

   Die allgemeine Syntax lautet:

     guix publish OPTIONEN…

   Wird ‘guix publish’ ohne weitere Argumente ausgeführt, wird damit ein
HTTP-Server gestartet, der auf Port 8080 lauscht:

     guix publish

   Sobald ein Server zum Veröffentlichen autorisiert wurde (siehe *note
Aufruf von guix archive::), kann der Daemon davon Substitute
herunterladen:

     guix-daemon --substitute-urls=http://example.org:8080

   Nach den Voreinstellungen komprimiert ‘guix publish’ Archive erst
dann, wenn sie angefragt werden. Dieser „dynamische“ Modus bietet sich
an, weil so nichts weiter eingerichtet werden muss und er direkt
verfügbar ist. Wenn Sie allerdings viele Clients bedienen wollen,
empfehlen wir, dass Sie die Befehlszeilenoption ‘--cache’ benutzen, die
das Zwischenspeichern der komprimierten Archive aktiviert, bevor diese
an die Clients geschickt werden — siehe unten für Details. Mit dem
Befehl ‘guix weather’ haben Sie eine praktische Methode zur Hand, zu
überprüfen, was so ein Server anbietet (siehe *note Aufruf von guix
weather::).

   Als Bonus dient ‘guix publish’ auch als inhaltsadressierbarer
Spiegelserver für Quelldateien, die in ‘origin’-Verbundsobjekten
eingetragen sind (siehe *note „origin“-Referenz::). Wenn wir zum
Beispiel annehmen, dass ‘guix publish’ auf ‘example.org’ läuft, liefert
folgende URL die rohe ‘hello-2.10.tar.gz’-Datei mit dem angegebenen
SHA256-Hash als ihre Prüfsumme (dargestellt im ‘nix-base32’-Format,
siehe *note Aufruf von guix hash::):

     http://example.org/file/hello-2.10.tar.gz/sha256/0ssi1…ndq1i

   Offensichtlich funktionieren diese URLs nur mit solchen Dateien, die
auch im Store vorliegen; in anderen Fällen werden sie 404 („Nicht
gefunden“) zurückliefern.

   Erstellungsprotokolle sind unter ‘/log’-URLs abrufbar:

     http://example.org/log/gwspk…-guile-2.2.3

Ist der ‘guix-daemon’ so eingestellt, dass er Erstellungsprotokolle
komprimiert abspeichert, wie es voreingestellt ist (siehe *note Aufruf
des guix-daemon::), liefern ‘/log’-URLs das unveränderte komprimierte
Protokoll, mit einer entsprechenden ‘Content-Type’- und/oder
‘Content-Encoding’-Kopfzeile. Wir empfehlen dabei, dass Sie den
‘guix-daemon’ mit ‘--log-compression=gzip’ ausführen, weil Web-Browser
dieses Format automatisch dekomprimieren können, was bei
bzip2-Kompression nicht der Fall ist.

   Folgende Befehlszeilenoptionen stehen zur Verfügung:

‘--port=PORT’
‘-p PORT’
     Auf HTTP-Anfragen auf diesem PORT lauschen.

‘--listen=HOST’
     Auf der Netzwerkschnittstelle für den angegebenen HOST, also der
     angegebenen Rechneradresse, lauschen. Vorgegeben ist, Verbindungen
     mit jeder Schnittstelle zu akzeptieren.

‘--user=BENUTZER’
‘-u BENUTZER’
     So früh wie möglich alle über die Berechtigungen des BENUTZERs
     hinausgehenden Berechtigungen ablegen — d.h. sobald der
     Server-Socket geöffnet und der Signierschlüssel gelesen wurde.

‘--compression[=METHODE[:STUFE]]’
‘-C [METHODE[:STUFE]]’
     Daten auf der angegebenen Kompressions-STUFE mit der angegebenen
     METHODE komprimieren. Als METHODE kann entweder ‘lzip’ oder ‘gzip’
     angegeben werden. Wird keine METHODE angegeben, wird ‘gzip’
     benutzt.

     Daten auf der angegebenen Kompressions-STUFE komprimieren. Wird als
     STUFE null angegeben, wird Kompression deaktiviert. Der Bereich von
     1 bis 9 entspricht unterschiedlichen Kompressionsstufen: 1 ist am
     schnellsten, während 9 am besten komprimiert (aber den Prozessor
     mehr auslastet). Der Vorgabewert ist 3.

     Normalerweise ist die Kompression mit ‘lzip’ wesentlich besser als
     bei ‘gzip’, dafür wird der Prozessor geringfügig stärker
     ausgelastet; siehe Vergleichswerte auf dem Webauftritt von lzip
     (https://nongnu.org/lzip/lzip_benchmark.html).

     Wenn ‘--cache’ nicht übergeben wird, werden Daten dynamisch immer
     erst dann komprimiert, wenn sie abgeschickt werden; komprimierte
     Datenströme landen in keinem Zwischenspeicher. Um also die
     Auslastung der Maschine, auf der ‘guix publish’ läuft, zu
     reduzieren, kann es eine gute Idee sein, eine niedrige
     Kompressionsstufe zu wählen, ‘guix publish’ einen Proxy mit
     Zwischenspeicher (einen „Caching Proxy“) voranzuschalten, oder
     ‘--cache’ zu benutzen. ‘--cache’ zu benutzen, hat den Vorteil, dass
     ‘guix publish’ damit eine ‘Content-Length’-HTTP-Kopfzeile seinen
     Antworten beifügen kann.

     Wenn diese Befehlszeilenoption mehrfach angegeben wird, wird jedes
     Substitut mit allen ausgewählten Methoden komprimiert und jede
     davon wird bei Anfragen mitgeteilt. Das ist nützlich, weil
     Benutzer, bei denen nicht alle Kompressionsmethoden unterstützt
     werden, die passende wählen können.

‘--cache=VERZEICHNIS’
‘-c VERZEICHNIS’
     Archive und Metadaten (‘.narinfo’-URLs) in das VERZEICHNIS
     zwischenspeichern und nur solche Archive versenden, die im
     Zwischenspeicher vorliegen.

     Wird diese Befehlszeilenoption weggelassen, dann werden Archive und
     Metadaten „dynamisch“ erst auf eine Anfrage hin erzeugt. Dadurch
     kann die verfügbare Bandbreite reduziert werden, besonders wenn
     Kompression aktiviert ist, weil die Operation dann durch die
     Prozessorleistung beschränkt sein kann. Noch ein Nachteil des
     voreingestellten Modus ist, dass die Länge der Archive nicht im
     Voraus bekannt ist, ‘guix publish’ also keine
     ‘Content-Length’-HTTP-Kopfzeile an seine Antworten anfügt, wodurch
     Clients nicht wissen können, welche Datenmenge noch heruntergeladen
     werden muss.

     Im Gegensatz dazu liefert, wenn ‘--cache’ benutzt wird, die erste
     Anfrage nach einem Store-Objekt (über dessen ‘.narinfo’-URL) den
     Fehlercode 404, und im Hintergrund wird ein Prozess gestartet, der
     das Archiv in den Zwischenspeicher einlagert (auf Englisch sagen
     wir „“bake” the archive“), d.h. seine ‘.narinfo’ wird berechnet und
     das Archiv, falls nötig, komprimiert. Sobald das Archiv im
     VERZEICHNIS zwischengespeichert wurde, werden nachfolgende Anfragen
     erfolgreich sein und direkt aus dem Zwischenspeicher bedient, der
     garantiert, dass Clients optimale Bandbreite genießen.

     Der Prozess zum Einlagern wird durch Worker-Threads umgesetzt. Der
     Vorgabe entsprechend wird dazu pro Prozessorkern ein Thread
     erzeugt, aber dieses Verhalten kann angepasst werden. Siehe
     ‘--workers’ weiter unten.

     Wird ‘--ttl’ verwendet, werden zwischengespeicherte Einträge
     automatisch gelöscht, sobald die dabei angegebene Zeit abgelaufen
     ist.

‘--workers=N’
     Wird ‘--cache’ benutzt, wird die Reservierung von N Worker-Threads
     angefragt, um Archive einzulagern.

‘--ttl=TTL’
     ‘Cache-Control’-HTTP-Kopfzeilen erzeugen, die eine Time-to-live
     (TTL) von TTL signalisieren. Für TTL muss eine Dauer (mit dem
     Anfangsbuchstaben der Maßeinheit der Dauer im Englischen) angegeben
     werden: ‘5d’ bedeutet 5 Tage, ‘1m’ bedeutet 1 Monat und so weiter.

     Das ermöglicht es Guix, Substitutinformationen TTL lang
     zwischenzuspeichern. Beachten Sie allerdings, dass ‘guix publish’
     selbst _nicht_ garantiert, dass die davon angebotenen Store-Objekte
     so lange verfügbar bleiben, wie es die TTL vorsieht.

     Des Weiteren können bei Nutzung von ‘--cache’ die
     zwischengespeicherten Einträge gelöscht werden, wenn auf sie TTL
     lang nicht zugegriffen wurde und kein ihnen entsprechendes Objekt
     mehr im Store existiert.

‘--nar-path=PFAD’
     Den PFAD als Präfix für die URLs von „nar“-Dateien benutzen (siehe
     *note normalized archives: Aufruf von guix archive.).

     Vorgegeben ist, dass Nars unter einer URL mit
     ‘/nar/gzip/…-coreutils-8.25’ angeboten werden. Mit dieser
     Befehlszeilenoption können Sie den ‘/nar’-Teil durch den
     angegebenen PFAD ersetzen.

‘--public-key=DATEI’
‘--private-key=DATEI’
     Die angegebenen DATEIen als das Paar aus öffentlichem und privatem
     Schlüssel zum Signieren veröffentlichter Store-Objekte benutzen.

     Die Dateien müssen demselben Schlüsselpaar entsprechen (der private
     Schlüssel wird zum Signieren benutzt, der öffentliche Schlüssel
     wird lediglich in den Metadaten der Signatur aufgeführt). Die
     Dateien müssen Schlüssel im kanonischen („canonical“)
     S-Ausdruck-Format enthalten, wie es von ‘guix archive
     --generate-key’ erzeugt wird (siehe *note Aufruf von guix
     archive::). Vorgegeben ist, dass ‘/etc/guix/signing-key.pub’ und
     ‘/etc/guix/signing-key.sec’ benutzt werden.

‘--repl[=PORT]’
‘-r [PORT]’
     Einen Guile-REPL-Server (siehe *note (guile)REPL Servers::) auf
     diesem PORT starten (37146 ist voreingestellt). Dies kann zur
     Fehlersuche auf einem laufenden „‘guix publish’“-Server benutzt
     werden.

   ‘guix publish’ auf einem „Guix System“-System zu aktivieren ist ein
Einzeiler: Instanziieren Sie einfach einen
‘guix-publish-service-type’-Dienst im ‘services’-Feld Ihres
‘operating-system’-Objekts zur Betriebssystemdeklaration (siehe *note
‘guix-publish-service-type’: guix-publish-service-type.).

   Falls Sie Guix aber auf einer „Fremddistribution“ laufen lassen,
folgen Sie folgenden Anweisungen:

   • Wenn Ihre Wirtsdistribution systemd als „init“-System benutzt:

          # ln -s ~root/.guix-profile/lib/systemd/system/guix-publish.service \
                  /etc/systemd/system/
          # systemctl start guix-publish && systemctl enable guix-publish

   • Wenn Ihre Wirts-Distribution als „init“-System Upstart verwendet:

          # ln -s ~root/.guix-profile/lib/upstart/system/guix-publish.conf /etc/init/
          # start guix-publish

   • Verfahren Sie andernfalls auf die gleiche Art für das
     „init“-System, das Ihre Distribution verwendet.


File: guix.de.info,  Node: Aufruf von guix challenge,  Next: Aufruf von guix copy,  Prev: Aufruf von guix publish,  Up: Zubehör

7.11 ‘guix challenge’ aufrufen
==============================

Entsprechen die von diesem Server gelieferten Binärdateien tatsächlich
dem Quellcode, aus dem sie angeblich erzeugt wurden? Ist ein
Paketerstellungsprozess deterministisch? Diese Fragen versucht ‘guix
challenge’ zu beantworten.

   Die erste Frage ist offensichtlich wichtig: Bevor man einen
Substitutserver benutzt (siehe *note Substitute::), _verifiziert_ man
besser, dass er die richtigen Binärdateien liefert, d.h. man _fechtet
sie an_. Die letzte Frage macht die erste möglich: Wenn
Paketerstellungen deterministisch sind, müssten voneinander unabhängige
Erstellungen genau dasselbe Ergebnis liefern, Bit für Bit; wenn ein
Server mit einer anderen Binärdatei als der lokal erstellten Binärdatei
antwortet, ist diese entweder beschädigt oder bösartig.

   Wir wissen, dass die in ‘/gnu/store’-Dateinamen auftauchende
Hash-Prüfsumme der Hash aller Eingaben des Prozesses ist, mit dem die
Datei oder das Verzeichnis erstellt wurde — Compiler, Bibliotheken,
Erstellungsskripts und so weiter (siehe *note Einführung::). Wenn wir
von deterministischen Erstellungen ausgehen, sollte ein Store-Dateiname
also auf genau eine Erstellungsausgabe abgebildet werden. Mit ‘guix
challenge’ prüft man, ob es tatsächlich eine eindeutige Abbildung gibt,
indem die Erstellungsausgaben mehrerer unabhängiger Erstellungen jedes
angegebenen Store-Objekts verglichen werden.

   Die Ausgabe des Befehls sieht so aus:

     $ guix challenge --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"
     Liste der Substitute von „https://ci.guix.gnu.org“ wird aktualisiert … 100.0%
     Liste der Substitute von „https://guix.example.org“ wird aktualisiert … 100.0%
     Inhalt von /gnu/store/…-openssl-1.0.2d verschieden:
       lokale Prüfsumme: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://ci.guix.gnu.org/nar/…-openssl-1.0.2d: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://guix.example.org/nar/…-openssl-1.0.2d: 1zy4fmaaqcnjrzzajkdn3f5gmjk754b43qkq47llbyak9z0qjyim
       Diese Dateien unterscheiden sich:
         /lib/libcrypto.so.1.1
         /lib/libssl.so.1.1

     Inhalt von /gnu/store/…-git-2.5.0 verschieden:
       lokale Prüfsumme: 00p3bmryhjxrhpn2gxs2fy0a15lnip05l97205pgbk5ra395hyha
       https://ci.guix.gnu.org/nar/…-git-2.5.0: 069nb85bv4d4a6slrwjdy8v1cn4cwspm3kdbmyb81d6zckj3nq9f
       https://guix.example.org/nar/…-git-2.5.0: 0mdqa9w1p6cmli6976v4wi0sw9r4p5prkj7lzfd1877wk11c9c73
       Diese Datei unterscheidet sich:
         /libexec/git-core/git-fsck

     Inhalt von /gnu/store/…-pius-2.1.1 verschieden:
       lokale Prüfsumme: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://ci.guix.gnu.org/nar/…-pius-2.1.1: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://guix.example.org/nar/…-pius-2.1.1: 1cy25x1a4fzq5rk0pmvc8xhwyffnqz95h2bpvqsz2mpvlbccy0gs
       Diese Datei unterscheidet sich:
         /share/man/man1/pius.1.gz

     …

     6,406 Store-Objekte wurden analysiert:
       — 4,749 (74.1%) waren identisch
       — 525 (8.2%) unterscheiden sich
       — 1,132 (17.7%) blieben ergebnislos

In diesem Beispiel wird mit ‘guix challenge’ zuerst die Menge lokal
erstellter Ableitungen im Store ermittelt — im Gegensatz zu von einem
Substitserver heruntergeladenen Store-Objekten — und dann werden alle
Substitutserver angefragt. Diejenigen Store-Objekte, bei denen der
Server ein anderes Ergebnis berechnet hat als die lokale Erstellung,
werden gemeldet.

   Nehmen wir zum Beispiel an, ‘guix.example.org’ gibt uns immer eine
verschiedene Antwort, aber ‘ci.guix.gnu.org’ stimmt mit lokalen
Erstellungen überein, _außer_ im Fall von Git. Das könnte ein Hinweis
sein, dass der Erstellungsprozess von Git nichtdeterministisch ist; das
bedeutet, seine Ausgabe variiert abhängig von verschiedenen Umständen,
die Guix nicht vollends kontrollieren kann, obwohl es Pakete in
isolierten Umgebungen erstellt (siehe *note Funktionalitäten::). Zu den
häufigsten Quellen von Nichtdeterminismus gehören das Einsetzen von
Zeitstempeln innerhalb der Erstellungsgebnisse, das Einsetzen von
Zufallszahlen und von Auflistungen eines Verzeichnisinhalts sortiert
nach der Inode-Nummer. Siehe <https://reproducible-builds.org/docs/> für
mehr Informationen.

   Um herauszufinden, was mit dieser Git-Binärdatei nicht stimmt, ist es
am leichtesten, einfach diesen Befehl auszuführen:

     guix challenge git \
       --diff=diffoscope \
       --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"

   Dadurch wird ‘diffoscope’ automatisch aufgerufen, um detaillierte
Informationen über sich unterscheidende Dateien anzuzeigen.

   Alternativ können wir so etwas machen (siehe *note Aufruf von guix
archive::):

     $ wget -q -O - https://ci.guix.gnu.org/nar/lzip/...-git-2.5.0 \
        | lzip -d | guix archive -x /tmp/git
     $ diff -ur --no-dereference /gnu/store/...-git.2.5.0 /tmp/git

   Dieser Befehl zeigt die Unterschiede zwischen den Dateien, die sich
aus der lokalen Erstellung ergeben, und den Dateien, die sich aus der
Erstellung auf ‘ci.guix.gnu.org’ ergeben (siehe *note Comparing and
Merging Files: (diffutils)Overview.). Der Befehl ‘diff’ funktioniert
großartig für Textdateien. Wenn sich Binärdateien unterscheiden, ist
Diffoscope (https://diffoscope.org/) die bessere Wahl: Es ist ein
hilfreiches Werkzeug, das Unterschiede in allen Arten von Dateien
visualisiert.

   Sobald Sie mit dieser Arbeit fertig sind, können Sie erkennen, ob die
Unterschiede aufgrund eines nichtdeterministischen Erstellungsprozesses
oder wegen einem bösartigen Server zustande kommen. Wir geben uns Mühe,
Quellen von Nichtdeterminismus in Paketen zu entfernen, damit Substitute
leichter verifiziert werden können, aber natürlich ist an diesem Prozess
nicht nur Guix, sondern ein großer Teil der Freie-Software-Gemeinschaft
beteiligt. In der Zwischenzeit ist ‘guix challenge’ eines der Werkzeuge,
die das Problem anzugehen helfen.

   Wenn Sie ein Paket für Guix schreiben, ermutigen wir Sie, zu
überprüfen, ob ‘ci.guix.gnu.org’ und andere Substitutserver dasselbe
Erstellungsergebnis bekommen, das Sie bekommen haben. Das geht so:

     $ guix challenge PAKET

Dabei wird mit PAKET eine Paketspezifikation wie ‘guile@2.0’ oder
‘glibc:debug’ bezeichnet.

   Die allgemeine Syntax lautet:

     guix challenge OPTIONEN [PAKETE…]

   Wird ein Unterschied zwischen der Hash-Prüfsumme des lokal erstellten
Objekts und dem vom Server gelieferten Substitut festgestellt, oder
zwischen den Substituten von unterschiedlichen Servern, dann wird der
Befehl dies wie im obigen Beispiel anzeigen und mit dem Exit-Code 2
terminieren (andere Exit-Codes außer null stehen für andere Arten von
Fehlern).

   Die eine, wichtige Befehlszeilenoption ist:

‘--substitute-urls=URLS’
     Die URLS als durch Leerraumzeichen getrennte Liste von
     Substitut-Quell-URLs benutzen. mit denen verglichen wird.

‘--diff=MODUS’
     Wenn sich Dateien unterscheiden, diese Unterschiede entsprechend
     dem MODUS anzeigen. Dieser kann einer der folgenden sein:

     ‘simple’ (die Vorgabe)
          Zeige die Liste sich unterscheidender Dateien.

     ‘diffoscope’
     BEFEHL
          Diffoscope (https://diffoscope.org/) aufrufen und ihm zwei
          Verzeichnisse mit verschiedenem Inhalt übergeben.

          Wenn der BEFEHL ein absoluter Dateiname ist, wird der BEFEHL
          anstelle von Diffoscope ausgeführt.

     ‘none’
          Keine näheren Details zu Unterschieden anzeigen.

     Solange kein ‘--diff=none’ angegeben wird, werden durch ‘guix
     challenge’ also Store-Objekte von den festgelegten Substitutservern
     heruntergeladen, damit diese verglichen werden können.

‘--verbose’
‘-v’
     Details auch zu Übereinstimmungen (deren Inhalt identisch ist)
     ausgeben, zusätzlich zu Informationen über Unterschiede.


File: guix.de.info,  Node: Aufruf von guix copy,  Next: Aufruf von guix container,  Prev: Aufruf von guix challenge,  Up: Zubehör

7.12 ‘guix copy’ aufrufen
=========================

Der Befehl ‘guix copy’ kopiert Objekte aus dem Store einer Maschine in
den Store einer anderen Maschine mittels einer Secure-Shell-Verbindung
(kurz SSH-Verbindung)(1). Zum Beispiel kopiert der folgende Befehl das
Paket ‘coreutils’, das Profil des Benutzers und all deren Abhängigkeiten
auf den anderen RECHNER, dazu meldet sich Guix als BENUTZER an:

     guix copy --to=BENUTZER@RECHNER \
               coreutils `readlink -f ~/.guix-profile`

   Wenn manche der zu kopierenden Objekte schon auf dem anderen RECHNER
vorliegen, werden sie tatsächlich _nicht_ übertragen.

   Der folgende Befehl bezieht ‘libreoffice’ und ‘gimp’ von dem RECHNER,
vorausgesetzt sie sind dort verfügbar:

     guix copy --from=HOST libreoffice gimp

   Die SSH-Verbindung wird mit dem Guile-SSH-Client hergestellt, der mit
OpenSSH kompatibel ist: Er berücksichtigt ‘~/.ssh/known_hosts’ und
‘~/.ssh/config’ und verwendet den SSH-Agenten zur Authentifizierung.

   Der Schlüssel, mit dem gesendete Objekte signiert sind, muss von der
entfernten Maschine akzeptiert werden. Ebenso muss der Schlüssel, mit
dem die Objekte signiert sind, die Sie von der entfernten Maschine
empfangen, in Ihrer Datei ‘/etc/guix/acl’ eingetragen sein, damit Ihr
Daemon sie akzeptiert. Siehe *note Aufruf von guix archive:: für mehr
Informationen über die Authentifizierung von Store-Objekten.

   Die allgemeine Syntax lautet:

     guix copy [--to=SPEZIFIKATION|--from=SPEZIFIKATION] OBJEKTE…

   Sie müssen immer eine der folgenden Befehlszeilenoptionen angeben:

‘--to=SPEZIFIKATION’
‘--from=SPEZIFIKATION’
     Gibt den Rechner (den „Host“) an, an den oder von dem gesendet bzw.
     empfangen wird. Die SPEZIFIKATION muss eine SSH-Spezifikation sein
     wie ‘example.org’, ‘charlie@example.org’ oder
     ‘charlie@example.org:2222’.

   Die OBJEKTE können entweder Paketnamen wie ‘gimp’ oder Store-Objekte
wie ‘/gnu/store/…-idutils-4.6’ sein.

   Wenn ein zu sendendes Paket mit Namen angegeben wird, wird es erst
erstellt, falls es nicht im Store vorliegt, außer ‘--dry-run’ wurde
angegeben wurde. Alle gemeinsamen Erstellungsoptionen werden unterstützt
(siehe *note Gemeinsame Erstellungsoptionen::).

   ---------- Footnotes ----------

   (1) Dieser Befehl steht nur dann zur Verfügung, wenn Guile-SSH
gefunden werden kann. Siehe *note Voraussetzungen:: für Details.


File: guix.de.info,  Node: Aufruf von guix container,  Next: Aufruf von guix weather,  Prev: Aufruf von guix copy,  Up: Zubehör

7.13 ‘guix container’ aufrufen
==============================

     Anmerkung: Dieses Werkzeug ist noch experimentell, Stand Version
     1.1.0.411-5c10d. Die Schnittstelle wird sich in Zukunft grundlegend
     verändern.

   Der Zweck von ‘guix container’ ist, in einer isolierten Umgebung
(gemeinhin als „Container“ bezeichnet) laufende Prozesse zu
manipulieren, die typischerweise durch die Befehle ‘guix environment’
(siehe *note Aufruf von guix environment::) und ‘guix system container’
(siehe *note Aufruf von guix system::) erzeugt werden.

   Die allgemeine Syntax lautet:

     guix container AKTION OPTIONEN…

   Mit AKTION wird die Operation angegeben, die in der isolierten
Umgebung durchgeführt werden soll, und mit OPTIONEN werden die
kontextabhängigen Argumente an die Aktion angegeben.

   Folgende Aktionen sind verfügbar:

‘exec’
     Führt einen Befehl im Kontext der laufenden isolierten Umgebung
     aus.

     Die Syntax ist:

          guix container exec PID PROGRAMM ARGUMENTE…

     PID gibt die Prozess-ID der laufenden isolierten Umgebung an. Als
     PROGRAMM muss eine ausführbare Datei im Wurzeldateisystem der
     isolierten Umgebung angegeben werden. Die ARGUMENTE sind die
     zusätzlichen Befehlszeilenoptionen, die an das PROGRAMM übergeben
     werden.

     Der folgende Befehl startet eine interaktive Anmelde-Shell
     innerhalb einer isolierten Guix-Systemumgebung, gestartet durch
     ‘guix system container’, dessen Prozess-ID 9001 ist:

          guix container exec 9001 /run/current-system/profile/bin/bash --login

     Beachten Sie, dass die PID nicht der Elternprozess der isolierten
     Umgebung sein darf, sondern PID 1 in der isolierten Umgebung oder
     einer seiner Kindprozesse sein muss.


File: guix.de.info,  Node: Aufruf von guix weather,  Next: Aufruf von guix processes,  Prev: Aufruf von guix container,  Up: Zubehör

7.14 ‘guix weather’ aufrufen
============================

Manchmal werden Sie schlecht gelaunt sein, weil es zu wenige Substitute
gibt und die Pakete bei Ihnen selbst erstellt werden müssen (siehe *note
Substitute::). Der Befehl ‘guix weather’ zeigt einen Bericht über die
Verfügbarkeit von Substituten auf den angegebenen Servern an, damit Sie
sich eine Vorstellung davon machen können, wie es heute um Ihre Laune
bestellt sein wird. Manchmal bekommt man als Nutzer so hilfreiche
Informationen, aber in erster Linie nützt der Befehl den Leuten, die
‘guix publish’ benutzen (siehe *note Aufruf von guix publish::).

   Hier ist ein Beispiel für einen Aufruf davon:

     $ guix weather --substitute-urls=https://guix.example.org
     5.872 Paketableitungen für x86_64-linux berechnen …
     Nach 6.128 Store-Objekten von https://guix.example.org suchen …
     updating list of substitutes from 'https://guix.example.org'... 100.0%
     https://guix.example.org
       43,4% Substitute verfügbar (2.658 von 6.128)
       7.032,5 MiB an Nars (komprimiert)
       19.824,2 MiB auf der Platte (unkomprimiert)
       0,030 Sekunden pro Anfrage (182,9 Sekunden insgesamt)
       33,5 Anfragen pro Sekunde

       9,8% (342 von 3.470) der fehlenden Objekte sind in der Warteschlange
       Mindestens 867 Erstellungen in der Warteschlange
           x86_64-linux: 518 (59,7%)
           i686-linux: 221 (25,5%)
           aarch64-linux: 128 (14,8%)
       Erstellungsgeschwindigkeit: 23,41 Erstellungen pro Stunde
           x86_64-linux: 11,16 Erstellungen pro Stunde
           i686-linux: 6,03 Erstellungen pro Stunde
           aarch64-linux: 6,41 Erstellungen pro Stunde

   Wie Sie sehen können, wird der Anteil unter allen Paketen angezeigt,
für die auf dem Server Substitute verfügbar sind — unabhängig davon, ob
Substitute aktiviert sind, und unabhängig davon, ob der signierende
Schlüssel des Servers autorisiert ist. Es wird auch über die Größe der
komprimierten Archive (die „Nars“) berichtet, die vom Server angeboten
werden, sowie über die Größe, die die zugehörigen Store-Objekte im Store
belegen würden (unter der Annahme, dass Deduplizierung abgeschaltet ist)
und über den Durchsatz des Servers. Der zweite Teil sind Statistiken zur
Kontinuierlichen Integration (englisch „Continuous Integration“, kurz
CI), wenn der Server dies unterstützt. Des Weiteren kann ‘guix weather’,
wenn es mit der Befehlszeilenoption ‘--coverage’ aufgerufen wird,
„wichtige“ Paketsubstitute, die auf dem Server fehlen, auflisten (siehe
unten).

   Dazu werden mit ‘guix weather’ Anfragen über HTTP(S) zu Metadaten
(“Narinfos”) für alle relevanten Store-Objekte gestellt. Wie ‘guix
challenge’ werden die Signaturen auf den Substituten ignoriert, was
harmlos ist, weil der Befehl nur Statistiken sammelt und keine
Substitute installieren kann.

   Die allgemeine Syntax lautet:

     guix weather OPTIONEN… [PAKETE…]

   Wenn keine PAKETE angegeben werden, prüft ‘guix weather’ für _alle_
Pakete bzw. für die Pakete mit ‘--manifest’ angegebenen Manifest, ob
Substitute zur Verfügung stehen. Ansonsten wird es nur für die
angegebenen Pakete geprüft. Es ist auch möglich, die Suche mit
‘--system’ auf bestimmte Systemtypen einzuschränken. Der Rückgabewert
von ‘guix weather’ ist _nicht_ null, wenn weniger als 100% Substitute
verfügbar sind.

   Die verfügbaren Befehlszeilenoptionen folgen.

‘--substitute-urls=URLS’
     URLS ist eine leerzeichengetrennte Liste anzufragender
     Substitutserver-URLs. Wird diese Befehlszeilenoption weggelassen,
     wird die vorgegebene Menge an Substitutservern angefragt.

‘--system=SYSTEM’
‘-s SYSTEM’
     Substitute für das SYSTEM anfragen — z.B. für ‘aarch64-linux’.
     Diese Befehlszeilenoption kann mehrmals angegeben werden, wodurch
     ‘guix weather’ die Substitute für mehrere Systemtypen anfragt.

‘--manifest=DATEI’
     Anstatt die Substitute für alle Pakete anzufragen, werden nur die
     in der DATEI angegebenen Pakete erfragt. Die DATEI muss ein
     “Manifest” enthalten, wie bei der Befehlszeilenoption ‘-m’ von
     ‘guix package’ (siehe *note Aufruf von guix package::).

     Wenn diese Befehlszeilenoption mehrmals wiederholt angegeben wird,
     werden die Manifeste aneinandergehängt.

‘--coverage[=ANZAHL]’
‘-c [ANZAHL]’
     Einen Bericht über die Substitutabdeckung für Pakete ausgeben, d.h.
     Pakete mit mindestens ANZAHL-vielen Abhängigen (voreingestellt
     mindestens null) anzeigen, für die keine Substitute verfügbar sind.
     Die abhängigen Pakete werden selbst nicht aufgeführt: Wenn B von A
     abhängt und Substitute für A fehlen, wird nur A aufgeführt, obwohl
     dann in der Regel auch die Substitute für B fehlen. Das Ergebnis
     sieht so aus:

          $ guix weather --substitute-urls=https://ci.guix.gnu.org -c 10
          8.983 Paketableitungen für x86_64-linux berechnen …
          Nach 9.343 Store-Objekten von https://ci.guix.gnu.org suchen …
          Liste der Substitute von „https://ci.guix.gnu.org“ wird aktualisiert … 100.0%
          https://ci.guix.gnu.org
            64.7% Substitute verfügbar (6.047 von 9.343)
          …
          2502 Pakete fehlen auf „https://ci.guix.de.info“ für „x86_64-linux“, darunter sind:
              58  kcoreaddons@5.49.0      /gnu/store/…-kcoreaddons-5.49.0
              46  qgpgme@1.11.1           /gnu/store/…-qgpgme-1.11.1
              37  perl-http-cookiejar@0.008  /gnu/store/…-perl-http-cookiejar-0.008
              …

     Was man hier in diesem Beispiel sehen kann, ist, dass es für
     ‘kcoreaddons’ und vermutlich die 58 Pakete, die davon abhängen, auf
     ‘ci.guix.de.info’ keine Substitute gibt; Gleiches gilt für ‘qgpgme’
     und die 46 Pakete, die davon abhängen.

     Wenn Sie ein Guix-Entwickler sind oder sich um diese
     Erstellungsfarm kümmern, wollen Sie sich diese Pakete vielleicht
     genauer anschauen. Es kann sein, dass sie schlicht nie erfolgreich
     erstellt werden können.

‘--display-missing’
     Eine Liste derjenigen Store-Objekte anzeigen, für die _keine_
     Substitute verfügbar sind.


File: guix.de.info,  Node: Aufruf von guix processes,  Prev: Aufruf von guix weather,  Up: Zubehör

7.15 ‘guix processes’ aufrufen
==============================

Der Befehl ‘guix processes’ kann sich für Entwickler und
Systemadministratoren als nützlich erweisen, besonders auf Maschinen mit
mehreren Nutzern und auf Erstellungsfarmen. Damit werden die aktuellen
Sitzungen (also Verbindungen zum Daemon) sowie Informationen über die
beteiligten Prozesse aufgelistet(1). Hier ist ein Beispiel für die davon
gelieferten Informationen:

     $ sudo guix processes
     SessionPID: 19002
     ClientPID: 19090
     ClientCommand: guix environment --ad-hoc python

     SessionPID: 19402
     ClientPID: 19367
     ClientCommand: guix publish -u guix-publish -p 3000 -C 9 …

     SessionPID: 19444
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass …
     LockHeld: /gnu/store/…-perl-ipc-cmd-0.96.lock
     LockHeld: /gnu/store/…-python-six-bootstrap-1.11.0.lock
     LockHeld: /gnu/store/…-libjpeg-turbo-2.0.0.lock
     ChildProcess: 20495: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27733: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27793: guix offload x86_64-linux 7200 1 28800

   In diesem Beispiel sehen wir, dass ‘guix-daemon’ drei Clients hat:
‘guix environment’, ‘guix publish’ und das Werkzeug Cuirass zur
Kontinuierlichen Integration. Deren Prozesskennung (PID) ist jeweils im
‘ClientPID’-Feld zu sehen. Das Feld ‘SessionPID’ zeigt die PID des
‘guix-daemon’-Unterprozesses dieser bestimmten Sitzung.

   Das Feld ‘LockHeld’ zeigt an, welche Store-Objekte derzeit durch die
Sitzung gesperrt sind, d.h. welche Store-Objekte zur Zeit erstellt oder
substituiert werden (das ‘LockHeld’-Feld wird nicht angezeigt, wenn
‘guix processes’ nicht als Administratornutzer root ausgeführt wird).
Letztlich sehen wir am ‘ChildProcess’-Feld oben, dass diese drei
Erstellungen hier ausgelagert (englisch „offloaded“) werden (siehe *note
Auslagern des Daemons einrichten::).

   Die Ausgabe ist im Recutils-Format, damit wir den praktischen
‘recsel’-Befehl benutzen können, um uns interessierende Sitzungen
auszuwählen (siehe *note (recutils)Selection Expressions::). Zum
Beispiel zeigt dieser Befehl die Befehlszeile und PID des Clients an,
der die Erstellung des Perl-Pakets ausgelöst hat:

     $ sudo guix processes | \
         recsel -p ClientPID,ClientCommand -e 'LockHeld ~ "perl"'
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass …

   ---------- Footnotes ----------

   (1) Entfernte Sitzungen, wenn ‘guix-daemon’ mit ‘--listen’ unter
Angabe eines TCP-Endpunkts gestartet wurde, werden _nicht_ aufgelistet.


File: guix.de.info,  Node: Systemkonfiguration,  Next: Dokumentation,  Prev: Zubehör,  Up: Top

8 Systemkonfiguration
*********************

Guix System unterstützt einen Mechanismus zur konsistenten Konfiguration
des gesamten Systems. Damit meinen wir, dass alle Aspekte der globalen
Systemkonfiguration an einem Ort stehen, d.h. die zur Verfügung
gestellten Systemdienste, die Zeitzone und Einstellungen zur Locale
(also die Anpassung an regionale Gepflogenheiten und Sprachen) sowie
Benutzerkonten. Sie alle werden an derselben Stelle deklariert. So eine
“Systemkonfiguration” kann “instanziiert”, also umgesetzt, werden.

   Einer der Vorteile, die ganze Systemkonfiguration unter die Kontrolle
von Guix zu stellen, ist, dass so transaktionelle Systemaktualisierungen
möglich werden und dass diese rückgängig gemacht werden können, wenn das
aktualisierte System nicht richtig funktioniert (siehe *note
Funktionalitäten::). Ein anderer Vorteil ist, dass dieselbe
Systemkonfiguration leicht auf einer anderen Maschine oder zu einem
späteren Zeitpunkt benutzt werden kann, ohne dazu eine weitere Schicht
administrativer Werkzeuge über den systemeigenen Werkzeugen einsetzen zu
müssen.

   In diesem Abschnitt wird dieser Mechanismus beschrieben. Zunächst
betrachten wir ihn aus der Perspektive eines Administrators. Dabei wird
erklärt, wie das System konfiguriert und instanziiert werden kann. Dann
folgt eine Demonstration, wie der Mechanismus erweitert werden kann,
etwa um neue Systemdienste zu unterstützen.

* Menu:

* Das Konfigurationssystem nutzen::  Ihr GNU-System anpassen.
* „operating-system“-Referenz::  Details der
                                       Betriebssystem-Deklarationen.
* Dateisysteme::             Die Dateisystemeinbindungen konfigurieren.
* Zugeordnete Geräte::      Näheres zu blockorientierten Speichermedien.
* Benutzerkonten::           Benutzerkonten festlegen.
* Tastaturbelegung::         Wie das System Tastendrücke interpretiert.
* Locales::                  Sprache und kulturelle Konventionen.
* Dienste::                  Systemdienste festlegen.
* Setuid-Programme::         Mit Administratorrechten startende Programme.
* X.509-Zertifikate::        HTTPS-Server authentifizieren.
* Name Service Switch::      Den Name Service Switch von libc konfigurieren.
* Initiale RAM-Disk::        Linux-libre hochfahren.
* Bootloader-Konfiguration::  Den Bootloader konfigurieren.
* Aufruf von guix system::   Instanziierung einer Systemkonfiguration.
* Aufruf von guix deploy::   Eine Systemkonfiguration auf einen entfernten
                               Rechner aufspielen.
* Guix in einer VM starten::  Wie man „Guix System“ in einer virtuellen
                                Maschine startet.
* Dienste definieren::       Neue Dienstdefinitionen hinzufügen.


File: guix.de.info,  Node: Das Konfigurationssystem nutzen,  Next: „operating-system“-Referenz,  Up: Systemkonfiguration

8.1 Das Konfigurationssystem nutzen
===================================

Das Betriebssystem können Sie konfigurieren, indem Sie eine
‘operating-system’-Deklaration in einer Datei speichern, die Sie dann
dem Befehl ‘guix system’ übergeben (siehe *note Aufruf von guix
system::). Eine einfache Konfiguration mit den vorgegebenen
Systemdiensten und dem vorgegebenen Linux-Libre als Kernel und mit einer
initialen RAM-Disk und einem Bootloader sieht so aus:

     ;; This is an operating system configuration template
     ;; for a "bare bones" setup, with no X11 display server.

     (use-modules (gnu))
     (use-service-modules networking ssh)
     (use-package-modules screen)

     (operating-system
       (host-name "komputilo")
       (timezone "Europe/Berlin")
       (locale "en_US.utf8")

       ;; Boot in "legacy" BIOS mode, assuming /dev/sdX is the
       ;; target hard disk, and "my-root" is the label of the target
       ;; root file system.
       (bootloader (bootloader-configuration
                     (bootloader grub-bootloader)
                     (target "/dev/sdX")))
       (file-systems (cons (file-system
                             (device (file-system-label "my-root"))
                             (mount-point "/")
                             (type "ext4"))
                           %base-file-systems))

       ;; This is where user accounts are specified.  The "root"
       ;; account is implicit, and is initially created with the
       ;; empty password.
       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")

                     ;; Adding the account to the "wheel" group
                     ;; makes it a sudoer.  Adding it to "audio"
                     ;; and "video" allows the user to play sound
                     ;; and access the webcam.
                     (supplementary-groups '("wheel"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Globally-installed packages.
       (packages (cons screen %base-packages))

       ;; Add services to the baseline: a DHCP client and
       ;; an SSH server.
       (services (append (list (service dhcp-client-service-type)
                               (service openssh-service-type
                                        (openssh-configuration
                                         (port-number 2222))))
                         %base-services)))

   Dieses Beispiel sollte selbsterklärend sein. Manche der Felder oben,
wie etwa ‘host-name’ und ‘bootloader’, müssen angegeben werden. Andere
sind optional, wie etwa ‘packages’ und ‘services’, sind optional; werden
sie nicht angegeben, nehmen sie einen Vorgabewert an.

   Im Folgenden werden die Effekte von einigen der wichtigsten Feldern
erläutert (siehe *note „operating-system“-Referenz:: für Details zu
allen verfügbaren Feldern), dann wird beschrieben, wie man das
Betriebssystem mit ‘guix system’ “instanziieren” kann.

Bootloader
----------

Das ‘bootloader’-Feld beschreibt, mit welcher Methode Ihr System
„gebootet“ werden soll. Maschinen, die auf Intel-Prozessoren basieren,
können im alten „Legacy“-BIOS-Modus gebootet werden, wie es im obigen
Beispiel der Fall wäre. Neuere Maschinen benutzen stattdessen das
“Unified Extensible Firmware Interface” (UEFI) zum Booten. In diesem
Fall sollte das ‘bootloader’-Feld in etwa so aussehen:

     (bootloader-configuration
       (bootloader grub-efi-bootloader)
       (target "/boot/efi"))

   Siehe den Abschnitt *note Bootloader-Konfiguration:: für weitere
Informationen zu den verfügbaren Konfigurationsoptionen.

global sichtbare Pakete
-----------------------

Im Feld ‘packages’ werden Pakete aufgeführt, die auf dem System für alle
Benutzerkonten global sichtbar sein sollen, d.h. in der
‘PATH’-Umgebungsvariablen jedes Nutzers, zusätzlich zu den nutzereigenen
Profilen (siehe *note Aufruf von guix package::). Die Variable
‘%base-packages’ bietet alle Werkzeuge, die man für grundlegende Nutzer-
und Administratortätigkeiten erwarten würde, einschließlich der GNU Core
Utilities, der GNU Networking Utilities, des leichtgewichtigen
Texteditors GNU Zile, ‘find’, ‘grep’ und so weiter. Obiges Beispiel fügt
zu diesen noch das Programm GNU Screen hinzu, welches aus dem Modul
‘(gnu packages screen)’ genommen wird (siehe *note Paketmodule::). Die
Syntax ‘(list package output)’ kann benutzt werden, um eine bestimmte
Ausgabe eines Pakets auszuwählen:

     (use-modules (gnu packages))
     (use-modules (gnu packages dns))

     (operating-system
       ;; …
       (packages (cons (list bind "utils")
                       %base-packages)))

   Sich auf Pakete anhand ihres Variablennamens zu beziehen, wie oben
bei ‘bind’, hat den Vorteil, dass der Name eindeutig ist; Tippfehler
werden direkt als „unbound variables“ gemeldet. Der Nachteil ist, dass
man wissen muss, in welchem Modul ein Paket definiert wird, um die Zeile
mit ‘use-package-modules’ entsprechend zu ergänzen. Um dies zu
vermeiden, kann man auch die Prozedur ‘specification->package’ aus dem
Modul ‘(gnu packages)’ aufrufen, welche das einem angegebenen Namen oder
Name-Versions-Paar zu Grunde liegende Paket liefert:

     (use-modules (gnu packages))

     (operating-system
       ;; …
       (packages (append (map specification->package
                              '("tcpdump" "htop" "gnupg@2.0"))
                         %base-packages)))

Systemdienste
-------------

Das Feld ‘services’ listet “Systemdienste” auf, die zur Verfügung stehen
sollen, wenn das System startet (siehe *note Dienste::). Die
‘operating-system’-Deklaration oben legt fest, dass wir neben den
grundlegenden Basis-Diensten auch wollen, dass der
OpenSSH-Secure-Shell-Daemon auf Port 2222 lauscht (siehe *note
‘openssh-service-type’: Netzwerkdienste.). Intern sorgt der
‘openssh-service-type’ dafür, dass ‘sshd’ mit den richtigen
Befehlszeilenoptionen aufgerufen wird, je nach Systemkonfiguration
werden auch für dessen Betrieb nötige Konfigurationsdateien erstellt
(siehe *note Dienste definieren::).

   Gelegentlich werden Sie die Basis-Dienste nicht einfach so, wie sie
sind, benutzen, sondern anpassen wollen. Benutzen Sie ‘modify-services’
(siehe *note ‘modify-services’: Service-Referenz.), um die Liste der
Basis-Dienste zu modifizieren.

   Wenn Sie zum Beispiel ‘guix-daemon’ und Mingetty (das Programm, womit
Sie sich auf der Konsole anmelden) in der ‘%base-services’-Liste
modifizieren möchten (siehe *note ‘%base-services’: Basisdienste.),
schreiben Sie das Folgende in Ihre Betriebssystemdeklaration:

     (define %my-services
       ;; Meine ganz eigene Liste von Diensten.
       (modify-services %base-services
         (guix-service-type config =>
                            (guix-configuration
                             (inherit config)
                             (use-substitutes? #f)
                             (extra-options '("--gc-keep-derivations"))))
         (mingetty-service-type config =>
                                (mingetty-configuration
                                 (inherit config)))))

     (operating-system
       ;; …
       (services %my-services))

   Dadurch ändert sich die Konfiguration — d.h. die Dienst-Parameter —
der ‘guix-service-type’-Instanz und die aller
‘mingetty-service-type’-Instanzen in der ‘%base-services’-Liste. Das
funktioniert so: Zunächst arrangieren wir, dass die ursprüngliche
Konfiguration an den Bezeichner ‘config’ im RUMPF gebunden wird, dann
schreiben wir den RUMPF, damit er zur gewünschten Konfiguration
ausgewertet wird. Beachten Sie insbesondere, wie wir mit ‘inherit’ eine
neue Konfiguration erzeugen, die dieselben Werte wie die alte
Konfiguration hat, aber mit ein paar Modifikationen.

   Die Konfiguration für typische Nutzung auf Heim- und Arbeitsrechnern,
mit einer verschlüsselten Partition für das Wurzeldateisystem, einem
X11-Anzeigeserver, GNOME und Xfce (Benutzer können im Anmeldebildschirm
auswählen, welche dieser Arbeitsumgebungen sie möchten, indem sie die
Taste ‘F1’ drücken), Netzwerkverwaltung, Verwaltungswerkzeugen für den
Energieverbrauch, und Weiteres, würde so aussehen:

     ;; This is an operating system configuration template
     ;; for a "desktop" setup with GNOME and Xfce where the
     ;; root partition is encrypted with LUKS.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop xorg)
     (use-package-modules certs gnome)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Choose US English keyboard layout.  The "altgr-intl"
       ;; variant provides dead keys for accented characters.
       (keyboard-layout (keyboard-layout "us" "altgr-intl"))

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout)))

       ;; Specify a mapped device for the encrypted root partition.
       ;; The UUID is that returned by 'cryptsetup luksUUID'.
       (mapped-devices
        (list (mapped-device
               (source (uuid "12345678-1234-1234-1234-123456789abc"))
               (target "my-root")
               (type luks-device-mapping))))

       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4")
                              (dependencies mapped-devices))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "bob")
                     (comment "Alice's brother")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; This is where we specify system-wide packages.
       (packages (append (list
                          ;; for HTTPS access
                          nss-certs
                          ;; for user mounts
                          gvfs)
                         %base-packages))

       ;; Add GNOME and Xfce---we can choose at the log-in screen
       ;; by clicking the gear.  Use the "desktop" services, which
       ;; include the X11 log-in service, networking with
       ;; NetworkManager, and more.
       (services (append (list (service gnome-desktop-service-type)
                               (service xfce-desktop-service-type)
                               (set-xorg-configuration
                                (xorg-configuration
                                 (keyboard-layout keyboard-layout))))
                         %desktop-services))

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   Ein grafisches System mit einer Auswahl an leichtgewichtigen
Fenster-Managern statt voll ausgestatteten Arbeitsumgebungen würde so
aussehen:

     ;; This is an operating system configuration template
     ;; for a "desktop" setup without full-blown desktop
     ;; environments.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop)
     (use-package-modules bootloaders certs ratpoison suckless wm)
     (use-package-modules bootloaders certs ratpoison suckless wm xorg)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")))

       ;; Assume the target root file system is labelled "my-root",
       ;; and the EFI System Partition has UUID 1234-ABCD.
       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4"))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Add a bunch of window managers; we can choose one at
       ;; the log-in screen with F1.
       (packages (append (list
                          ;; window managers
                          ratpoison i3-wm i3status dmenu
                          ;; terminal emulator
                          xterm
                          ;; for HTTPS access
                          nss-certs)
                         %base-packages))

       ;; Use the "desktop" services, which include the X11
       ;; log-in service, networking with NetworkManager, and more.
       (services %desktop-services)

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   Dieses Beispiel bezieht sich auf das Dateisystem hinter ‘/boot/efi’
über dessen UUID, ‘1234-ABCD’. Schreiben Sie statt dieser UUID die
richtige UUID für Ihr System, wie sie der Befehl ‘blkid’ liefert.

   Im Abschnitt *note Desktop-Dienste:: finden Sie eine genaue Liste der
unter ‘%desktop-services’ angebotenen Dienste. Der Abschnitt *note
X.509-Zertifikate:: hat Hintergrundinformationen über das
‘nss-certs’-Paket, das hier benutzt wird.

   Beachten Sie, dass ‘%desktop-services’ nur eine Liste von die Dienste
repräsentierenden service-Objekten ist. Wenn Sie Dienste daraus
entfernen möchten, können Sie dazu die Prozeduren zum Filtern von Listen
benutzen (siehe *note (guile)SRFI-1 Filtering and Partitioning::).
Beispielsweise liefert der folgende Ausdruck eine Liste mit allen
Diensten von ‘%desktop-services’ außer dem Avahi-Dienst.

     (remove (lambda (service)
               (eq? (service-kind service) avahi-service-type))
             %desktop-services)

Das System instanziieren
------------------------

Angenommen, Sie haben die ‘operating-system’-Deklaration in einer Datei
‘my-system-config.scm’ gespeichert, dann instanziiert der Befehl ‘guix
system reconfigure my-system-config.scm’ diese Konfiguration und macht
sie zum voreingestellten GRUB-Boot-Eintrag (siehe *note Aufruf von guix
system::).

   Der normale Weg, die Systemkonfiguration nachträglich zu ändern, ist,
die Datei zu aktualisieren und ‘guix system reconfigure’ erneut
auszuführen. Man sollte nie die Dateien in ‘/etc’ bearbeiten oder den
Systemzustand mit Befehlen wie ‘useradd’ oder ‘grub-install’ verändern.
Tatsächlich müssen Sie das ausdrücklich vermeiden, sonst verfällt nicht
nur Ihre Garantie, sondern Sie können Ihr System auch nicht mehr auf
eine alte Version des Systems zurücksetzen, falls das jemals notwendig
wird.

   Zurücksetzen bezieht sich hierbei darauf, dass jedes Mal, wenn Sie
‘guix system reconfigure’ ausführen, eine neue “Generation” des Systems
erzeugt wird — ohne vorherige Generationen zu verändern. Alte
Systemgenerationen bekommen einen Eintrag im Boot-Menü des Bootloaders,
womit Sie alte Generationen beim Starten des Rechners auswählen können,
wenn mit der neuesten Generation etwas nicht stimmt. Eine beruhigende
Vorstellung, oder? Der Befehl ‘guix system list-generations’ führt die
auf der Platte verfügbaren Systemgenerationen auf. Es ist auch möglich,
das System mit den Befehlen ‘guix system roll-back’ und ‘guix system
switch-generation’ zurückzusetzen.

   Obwohl der Befehl ‘guix system reconfigure’ vorherige Generationen
nicht verändern wird, müssen Sie Acht geben, dass wenn die momentan
aktuelle Generation nicht die neueste ist (z.B. nach einem Aufruf von
‘guix system roll-back’), weil ‘guix system reconfigure’ alle neueren
Generationen überschreibt (siehe *note Aufruf von guix system::).

Die Programmierschnittstelle
----------------------------

Auf der Ebene von Scheme wird der Großteil der
‘operating-system’-Deklaration mit der folgenden monadischen Prozedur
instanziiert (siehe *note Die Store-Monade::):

 -- Monadische Prozedur: operating-system-derivation os
     Liefert eine Ableitung, mit der ein ‘operating-system’-Objekt OS
     erstellt wird (siehe *note Ableitungen::).

     Die Ausgabe der Ableitung ist ein einzelnes Verzeichnis mit
     Verweisen auf alle Pakete, Konfigurationsdateien und andere
     unterstützenden Dateien, die nötig sind, um OS zu instanziieren.

   Diese Prozedur wird vom Modul ‘(gnu system)’ angeboten. Zusammen mit
‘(gnu services)’ (siehe *note Dienste::) deckt dieses Modul den Kern von
„Guix System“ ab. Schauen Sie es sich mal an!


File: guix.de.info,  Node: „operating-system“-Referenz,  Next: Dateisysteme,  Prev: Das Konfigurationssystem nutzen,  Up: Systemkonfiguration

8.2 ‘operating-system’-Referenz
===============================

Dieser Abschnitt fasst alle Optionen zusammen, die für
‘operating-system’-Deklarationen zur Verfügung stehen (siehe *note Das
Konfigurationssystem nutzen::).

 -- Datentyp: operating-system
     Der die Betriebssystemkonfiguration repräsentierende Datentyp.
     Damit meinen wir die globale Konfiguration des Systems und nicht
     die, die sich nur auf einzelne Nutzer bezieht (siehe *note Das
     Konfigurationssystem nutzen::).

     ‘kernel’ (default: ‘linux-libre’)
          Das Paket für den zu nutzenden Betriebssystem-Kernel als
          „package“-Objekt(1).

     ‘kernel-loadable-modules’ (Vorgabe: ’())
          Eine Liste von Objekten (normalerweise Pakete), aus denen
          Kernel-Module geladen werden können, zum Beispiel ‘(list
          ddcci-driver-linux)’.

     ‘kernel-arguments’ (Vorgabe: ‘'("quiet")’)
          Eine Liste aus Zeichenketten oder G-Ausdrücken, die für
          zusätzliche Argumente an den Kernel stehen, die ihm auf seiner
          Befehlszeile übergeben werden — wie z.B. ‘("console=ttyS0")’.

     ‘bootloader’
          Das Konfigurationsobjekt für den Bootloader, mit dem das
          System gestartet wird. Siehe *note Bootloader-Konfiguration::.

     ‘label’
          Diese Bezeichnung (eine Zeichenkette) wird für den Menüeintrag
          im Bootloader verwendet. Die Vorgabe ist eine Bezeichnung, die
          den Namen des Kernels und seine Version enthält.

     ‘keyboard-layout’ (Vorgabe: ‘#f’)
          Dieses Feld gibt an, welche Tastaturbelegung auf der Konsole
          benutzt werden soll. Es kann entweder auf ‘#f’ gesetzt sein,
          damit die voreingestellte Tastaturbelegung benutzt wird (in
          der Regel ist diese „US English“), oder ein
          ‘<keyboard-layout>’-Verbundsobjekt sein.

          Diese Tastaturbelegung wird benutzt, sobald der Kernel
          gebootet wurde. Diese Tastaturbelegung wird zum Beispiel auch
          verwendet, wenn Sie eine Passphrase eintippen, falls sich Ihr
          Wurzeldateisystem auf einem mit ‘luks-device-mapping’
          zugeordneten Gerät befindet (siehe *note Zugeordnete
          Geräte::).

               Anmerkung: Damit wird _nicht_ angegeben, welche
               Tastaturbelegung der Bootloader benutzt, und auch nicht,
               welche der grafische Anzeigeserver verwendet. Siehe *note
               Bootloader-Konfiguration:: für Informationen darüber, wie
               Sie die Tastaturbelegung des Bootloaders angeben können.
               Siehe *note X Window:: für Informationen darüber, wie Sie
               die Tastaturbelegung angeben können, die das
               X-Fenstersystem verwendet.

     ‘initrd-modules’ (Vorgabe: ‘%base-initrd-modules’)
          Die Liste der Linux-Kernel-Module, die in der initialen
          RAM-Disk zur Verfügung stehen sollen. Siehe *note Initiale
          RAM-Disk::.

     ‘initrd’ (Vorgabe: ‘base-initrd’)
          Eine Prozedur, die eine initiale RAM-Disk für den Linux-Kernel
          liefert. Dieses Feld gibt es, damit auch sehr systemnahe
          Anpassungen vorgenommen werden können, aber für die normale
          Nutzung sollte man es kaum brauchen. Siehe *note Initiale
          RAM-Disk::.

     ‘firmware’ (Vorgabe: ‘%base-firmware’)
          Eine Liste der Firmware-Pakete, die vom Betriebssystem-Kernel
          geladen werden können.

          Vorgegeben ist, dass für Atheros- und Broadcom-basierte
          WLAN-Geräte nötige Firmware geladen werden kann (genauer
          jeweils die Linux-libre-Module ‘ath9k’ und ‘b43-open’). Siehe
          den Abschnitt *note Hardware-Überlegungen:: für mehr
          Informationen zu unterstützter Hardware.

     ‘host-name’
          Der Hostname

     ‘hosts-file’
          Ein dateiartiges Objekt (siehe *note dateiartige Objekte:
          G-Ausdrücke.), das für ‘/etc/hosts’ benutzt werden soll (siehe
          *note (libc)Host Names::). Der Vorgabewert ist eine Datei mit
          Einträgen für ‘localhost’ und HOST-NAME.

     ‘mapped-devices’ (Vorgabe: ‘'()’)
          Eine Liste zugeordneter Geräte („mapped devices“). Siehe *note
          Zugeordnete Geräte::.

     ‘file-systems’
          Eine Liste von Dateisystemen. Siehe *note Dateisysteme::.

     ‘swap-devices’ (Vorgabe: ‘'()’)
          Eine Liste von Zeichenketten, die Geräte identifizieren oder
          als „Swap-Speicher“ genutzte Dateien identifizieren (siehe
          *note (libc)Memory Concepts::). Beispiele wären etwa
          ‘'("/dev/sda3")’ oder ‘'("/swapdatei")’. Es ist möglich, eine
          Swap-Datei auf dem Dateisystem eines zugeordneten Geräts
          anzugeben, sofern auch die Gerätezuordnung und das Dateisystem
          mit angegeben werden. Siehe *note Zugeordnete Geräte:: und
          *note Dateisysteme::.

     ‘users’ (Vorgabe: ‘%base-user-accounts’)
     ‘groups’ (Vorgabe: ‘%base-groups’)
          Liste der Benutzerkonten und Benutzergruppen. Siehe *note
          Benutzerkonten::.

          Wenn in der ‘users’-Liste kein Benutzerkonto mit der
          UID-Kennung 0 aufgeführt wird, wird automatisch für den
          Administrator ein „root“-Benutzerkonto mit UID-Kennung 0
          hinzugefügt.

     ‘skeletons’ (Vorgabe: ‘(default-skeletons)’)
          Eine Liste von Tupeln aus je einem Ziel-Dateinamen und einem
          dateiähnlichen Objekt (siehe *note dateiartige Objekte:
          G-Ausdrücke.). Diese Objekte werden als Skeleton-Dateien im
          Persönlichen Verzeichnis („Home“-Verzeichnis) jedes neuen
          Benutzerkontos angelegt.

          Ein gültiger Wert könnte zum Beispiel so aussehen:

               `((".bashrc" ,(plain-file "bashrc" "echo Hallo\n"))
                 (".guile" ,(plain-file "guile"
                                        "(use-modules (ice-9 readline))
                                         (activate-readline)")))

     ‘issue’ (Vorgabe: ‘%default-issue’)
          Eine Zeichenkette, die als Inhalt der Datei ‘/etc/issue’
          verwendet werden soll, der jedes Mal angezeigt wird, wenn sich
          ein Nutzer auf einer Textkonsole anmeldet.

     ‘packages’ (Vorgabe: ‘%base-packages’)
          Die Menge der Pakete, die ins globale Profil installiert
          werden sollen, welches unter ‘/run/current-system/profile’ zu
          finden ist.

          Die vorgegebene Paketmenge umfasst zum Kern des Systems
          gehörende Werkzeuge („core utilities“). Es ist empfehlenswert,
          nicht zum Kern gehörende Werkzeuge („non-core“) stattdessen in
          Nutzerprofile zu installieren (siehe *note Aufruf von guix
          package::).

     ‘timezone’
          Eine Zeichenkette, die die Zeitzone bezeichnet, wie z.B.
          ‘"Europe/Berlin"’.

          Mit dem Befehl ‘tzselect’ können Sie herausfinden, welche
          Zeichenkette der Zeitzone Ihrer Region entspricht. Wenn Sie
          eine ungültige Zeichenkette angeben, schlägt ‘guix system’
          fehl.

     ‘locale’ (Vorgabe: ‘"en_US.utf8"’)
          Der Name der als Voreinstellung zu verwendenden Locale (siehe
          *note (libc)Locale Names::). Siehe *note Locales:: für weitere
          Informationen.

     ‘locale-definitions’ (Vorgabe: ‘%default-locale-definitions’)
          Die Liste der Locale-Definitionen, die kompiliert werden
          sollen und dann im laufenden System benutzt werden können.
          Siehe *note Locales::.

     ‘locale-libcs’ (Vorgabe: ‘(list GLIBC)’)
          Die Liste der GNU-libc-Pakete, deren Locale-Daten und
          -Werkzeuge zum Erzeugen der Locale-Definitionen verwendet
          werden sollen. Siehe *note Locales:: für eine Erläuterung der
          Kompatibilitätsauswirkungen, deretwegen man diese Option
          benutzen wollen könnte.

     ‘name-service-switch’ (Vorgabe: ‘%default-nss’)
          Die Konfiguration des Name Service Switch (NSS) der libc — ein
          ‘<name-service-switch>’-Objekt. Siehe *note Name Service
          Switch:: für Details.

     ‘services’ (Vorgabe: ‘%base-services’)
          Eine Liste von „service“-Objekten, die die Systemdienste
          repräsentieren. Siehe *note Dienste::.

     ‘essential-services’ (Vorgabe: …)
          Die Liste „essenzieller Dienste“ — d.h. Dinge wie Instanzen
          von ‘system-service-type’ und ‘host-name-service-type’ (siehe
          *note Service-Referenz::), die aus der
          Betriebssystemdefinition an sich abgeleitet werden. Als
          normaler Benutzer sollten Sie dieses Feld _niemals_ ändern
          müssen.

     ‘pam-services’ (Vorgabe: ‘(base-pam-services)’)
          Dienste für “Pluggable Authentication Modules” (PAM) von
          Linux.

     ‘setuid-programs’ (default: ‘%setuid-programs’)
          Eine Liste von Zeichenketten liefernden G-Ausdrücken, die
          setuid-Programme bezeichnen. Siehe *note Setuid-Programme::.

     ‘sudoers-file’ (default: ‘%sudoers-specification’)
          Der Inhalt der Datei ‘/etc/sudoers’ als ein dateiähnliches
          Objekt (siehe *note ‘local-file’ und ‘plain-file’:
          G-Ausdrücke.).

          Diese Datei gibt an, welche Nutzer den Befehl ‘sudo’ benutzen
          dürfen, was sie damit tun und welche Berechtigungen sie so
          erhalten können. Die Vorgabe ist, dass nur der
          Administratornutzer ‘root’ und Mitglieder der Benutzergruppe
          ‘wheel’ den ‘sudo’-Befehl verwenden dürfen.

      -- Scheme-Syntax: this-operating-system
          Wenn dies im _lexikalischen Geltungsbereich_ der Definition
          eines Feldes im Betriebssystem steht, bezieht sich dieser
          Bezeichner auf das Betriebssystem, das gerade definiert wird.

          Das folgende Beispiel zeigt, wie man auf das Betriebssystem,
          das gerade definiert wird, verweist, während man die
          Definition des ‘label’-Felds schreibt:

               (use-modules (gnu) (guix))

               (operating-system
                 ;; …
                 (label (package-full-name
                         (operating-system-kernel this-operating-system))))

          Es ist ein Fehler, außerhalb einer Betriebssystemdefinition
          auf ‘this-operating-system’ zu verweisen.

   ---------- Footnotes ----------

   (1) Derzeit wird nur der Kernel Linux-libre unterstützt. In der
Zukunft wird man auch GNU Hurd benutzen können.


File: guix.de.info,  Node: Dateisysteme,  Next: Zugeordnete Geräte,  Prev: „operating-system“-Referenz,  Up: Systemkonfiguration

8.3 Dateisysteme
================

Die Liste der Dateisysteme, die eingebunden werden sollen, steht im
‘file-systems’-Feld der Betriebssystemdeklaration (siehe *note Das
Konfigurationssystem nutzen::). Jedes Dateisystem wird mit der
‘file-system’-Form deklariert, etwa so:

     (file-system
       (mount-point "/home")
       (device "/dev/sda3")
       (type "ext4"))

   Wie immer müssen manche Felder angegeben werden — die, die im
Beispiel oben stehen —, während andere optional sind. Die Felder werden
nun beschrieben.

 -- Datentyp: file-system
     Objekte dieses Typs repräsentieren einzubindende Dateisysteme. Sie
     weisen folgende Komponenten auf:

     ‘type’
          Eine Zeichenkette, die den Typ des Dateisystems spezifiziert,
          z.B. ‘"ext4"’.

     ‘mount-point’
          Der Einhängepunkt, d.h. der Pfad, an dem das Dateisystem
          eingebunden werden soll.

     ‘device’
          Hiermit wird die „Quelle“ des Dateisystems bezeichnet. Sie
          kann eines von drei Dingen sein: die Bezeichnung („Labels“)
          eines Dateisystems, die UUID-Kennung des Dateisystems oder der
          Name eines ‘/dev’-Knotens. Mit Bezeichnungen und UUIDs kann
          man Dateisysteme benennen, ohne den Gerätenamen
          festzuschreiben(1).

          Dateisystem-Bezeichnungen („Labels“) werden mit der Prozedur
          ‘file-system-label’ erzeugt und UUID-Kennungen werden mit
          ‘uuid’ erzeugt, während Knoten in ‘/dev’ mit ihrem Pfad als
          einfache Zeichenketten aufgeführt werden. Hier ist ein
          Beispiel, wie wir ein Dateisystem anhand seiner Bezeichnung
          aufführen, wie sie vom Befehl ‘e2label’ angezeigt wird:

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (file-system-label "my-home")))

          UUID-Kennungen werden mit der ‘uuid’-Form von ihrer
          Darstellung als Zeichenkette (wie sie vom Befehl ‘tune2fs -l’
          angezeigt wird) konvertiert(2) wie hier:

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (uuid "4dab5feb-d176-45de-b287-9b0a6e4c01cb")))

          Wenn die Quelle eines Dateisystems ein zugeordnetes Gerät
          (siehe *note Zugeordnete Geräte::) ist, _muss_ sich das
          ‘device’-Feld auf den zugeordneten Gerätenamen beziehen — z.B.
          ‘"/dev/mapper/root-partition"’. Das ist nötig, damit das
          System weiß, dass das Einbinden des Dateisystems davon
          abhängt, die entsprechende Gerätezuordnung hergestellt zu
          haben.

     ‘flags’ (Vorgabe: ‘'()’)
          Eine Liste von Symbolen, die Einbinde-Flags („mount flags“)
          bezeichnen. Erkannt werden unter anderem ‘read-only’,
          ‘bind-mount’, ‘no-dev’ (Zugang zu besonderen Dateien
          verweigern), ‘no-suid’ (setuid- und setgid-Bits ignorieren),
          ‘no-atime’ (Dateizugriffs-Zeitstempel _nicht_ aktualisieren),
          ‘strict-atime’ (Dateizugriffs-Zeitstempel immer
          aktualisieren), ‘lazy-time’ (Zeitstempel nur auf
          zwischengespeicherten Datei-Inodes im Arbeitsspeicher
          aktualisieren) und ‘no-exec’ (Programmausführungen
          verweigern). Siehe *note (libc)Mount-Unmount-Remount:: für
          mehr Informationen zu diesen Einbinde-Optionen.

     ‘options’ (Vorgabe: ‘#f’)
          Entweder ‘#f’ oder eine Zeichenkette mit Einbinde-Optionen
          („mount options“), die an den Dateisystemtreiber übergeben
          werden. Siehe *note (libc)Mount-Unmount-Remount:: für Details;
          führen Sie ‘man 8 mount’ aus, um die Einbinde-Optionen
          verschiedener Dateisysteme zu sehen.

     ‘mount?’ (Vorgabe: ‘#t’)
          Dieser Wert zeigt an, ob das Dateisystem automatisch
          eingebunden werden soll, wenn das System gestartet wird. Ist
          der Wert ‘#f’, dann erhält das Dateisystem nur einen Eintrag
          in der Datei ‘/etc/fstab’ (welche vom ‘mount’-Befehl zum
          Einbinden gelesen wird), es wird aber nicht automatisch
          eingebunden.

     ‘needed-for-boot?’ (Vorgabe: ‘#f’)
          Dieser boolesche Wert gibt an, ob das Dateisystem zum
          Hochfahren des Systems notwendig ist. In diesem Fall wird das
          Dateisystem eingebunden, wenn die initiale RAM-Disk (initrd)
          geladen wird. Für zum Beispiel das Wurzeldateisystem ist dies
          ohnehin immer der Fall.

     ‘check?’ (Vorgabe: ‘#t’)
          Dieser boolesche Wert sagt aus, ob das Dateisystem vor dem
          Einbinden auf Fehler hin geprüft werden soll.

     ‘create-mount-point?’ (Vorgabe: ‘#f’)
          Steht dies auf wahr, wird der Einhängepunkt vor dem Einbinden
          erstellt, wenn er noch nicht existiert.

     ‘dependencies’ (Vorgabe: ‘'()’)
          Dies ist eine Liste von ‘<file-system>’- oder
          ‘<mapped-device>’-Objekten, die Dateisysteme repräsentieren,
          die vor diesem Dateisystem eingebunden oder zugeordnet werden
          müssen (und nach diesem ausgehängt oder geschlossen werden
          müssen).

          Betrachten Sie zum Beispiel eine Hierarchie von Einbindungen:
          ‘/sys/fs/cgroup’ ist eine Abhängigkeit von
          ‘/sys/fs/cgroup/cpu’ und ‘/sys/fs/cgroup/memory’.

          Ein weiteres Beispiel ist ein Dateisystem, was von einem
          zugeordneten Gerät abhängt, zum Beispiel zur Verschlüsselung
          einer Partition (siehe *note Zugeordnete Geräte::).

   Das Modul ‘(gnu system file-systems)’ exportiert die folgenden
nützlichen Variablen.

 -- Scheme-Variable: %base-file-systems
     These are essential file systems that are required on normal
     systems, such as ‘%pseudo-terminal-file-system’ and
     ‘%immutable-store’ (see below.) Operating system declarations
     should always contain at least these.

 -- Scheme-Variable: %pseudo-terminal-file-system
     Das als ‘/dev/pts’ einzubindende Dateisystem. Es unterstützt über
     ‘openpty’ und ähnliche Funktionen erstellte “Pseudo-Terminals”
     (siehe *note (libc)Pseudo-Terminals::). Pseudo-Terminals werden von
     Terminal-Emulatoren wie ‘xterm’ benutzt.

 -- Scheme-Variable: %shared-memory-file-system
     Dieses Dateisystem wird als ‘/dev/shm’ eingebunden, um Speicher
     zwischen Prozessen teilen zu können (siehe *note ‘shm_open’:
     (libc)Memory-mapped I/O.).

 -- Scheme-Variable: %immutable-store
     Dieses Dateisystem vollzieht einen „bind mount“ des ‘/gnu/store’,
     um ihn für alle Nutzer einschließlich des Administratornutzers
     ‘root’ nur lesbar zu machen, d.h. Schreibrechte zu entziehen.
     Dadurch kann als ‘root’ ausgeführte Software, oder der
     Systemadministrator, nicht aus Versehen den Store modifizieren.

     Der Daemon kann weiterhin in den Store schreiben, indem er ihn
     selbst mit Schreibrechten in seinem eigenen „Namensraum“ einbindet.

 -- Scheme-Variable: %binary-format-file-system
     Das ‘binfmt_misc’-Dateisystem, durch das beliebige Dateitypen als
     ausführbare Dateien auf der Anwendungsebene (dem User Space)
     zugänglich gemacht werden können. Es setzt voraus, dass das
     Kernel-Modul ‘binfmt.ko’ geladen wurde.

 -- Scheme-Variable: %fuse-control-file-system
     Das ‘fusectl’-Dateisystem, womit „unprivilegierte“ Nutzer ohne
     besondere Berechtigungen im User Space FUSE-Dateisysteme einbinden
     und aushängen können. Dazu muss das Kernel-Modul ‘fuse.ko’ geladen
     sein.

   ---------- Footnotes ----------

   (1) Beachten Sie: Obwohl es verführerisch ist, mit
‘/dev/disk/by-uuid’ und ähnlichen Gerätenamen dasselbe Resultat bekommen
zu wollen, raten wir davon ab: Diese speziellen Gerätenamen werden erst
vom udev-Daemon erzeugt und sind, wenn die Geräte eingebunden werden,
vielleicht noch nicht verfügbar.

   (2) Die ‘uuid’-Form nimmt 16-Byte-UUIDs entgegen, wie sie in RFC 4122
(https://tools.ietf.org/html/rfc4122) definiert sind. Diese Form der
UUID wird unter anderem von der ext2-Familie von Dateisystemen
verwendet, sie unterscheidet sich jedoch zum Beispiel von den „UUID“
genannten Kennungen, wie man sie bei FAT-Dateisystemen findet.


File: guix.de.info,  Node: Zugeordnete Geräte,  Next: Benutzerkonten,  Prev: Dateisysteme,  Up: Systemkonfiguration

8.4 Zugeordnete Geräte
======================

Der Linux-Kernel unterstützt das Konzept der “Gerätezuordnung”: Ein
blockorientiertes Gerät wie eine Festplattenpartition kann einem neuen
Gerät “zugeordnet” werden, gewöhnlich unter ‘/dev/mapper/’, wobei das
neue Gerät durchlaufende Daten zusätzlicher Verarbeitung unterzogen
werden(1). Ein typisches Beispiel ist eine Gerätezuordnung zur
Verschlüsselung: Jeder Schreibzugriff auf das zugeordnete Gerät wird
transparent verschlüsselt und jeder Lesezugriff ebenso entschlüsselt.
Guix erweitert dieses Konzept, indem es darunter jedes Gerät und jede
Menge von Geräten versteht, die auf irgendeine Weise “umgewandelt” wird,
um ein neues Gerät zu bilden; zum Beispiel entstehen auch RAID-Geräte
aus einem “Verbund” mehrerer anderer Geräte, wie etwa Festplatten oder
Partition zu einem einzelnen Gerät, das sich wie eine Partition verhält.
Ein weiteres Beispiel, das noch nicht in Guix implementiert wurde, sind
„LVM logical volumes“.

   Zugeordnete Geräte werden mittels einer ‘mapped-device’-Form
deklariert, die wie folgt definiert ist; Beispiele folgen weiter unten.

 -- Datentyp: mapped-device
     Objekte dieses Typs repräsentieren Gerätezuordnungen, die gemacht
     werden, wenn das System hochfährt.

     ‘source’
          Es handelt sich entweder um eine Zeichenkette, die den Namen
          eines zuzuordnenden blockorientierten Geräts angibt, wie
          ‘"/dev/sda3"’, oder um eine Liste solcher Zeichenketten,
          sofern mehrere Geräts zu einem neuen Gerät verbunden werden.

     ‘target’
          Diese Zeichenkette gibt den Namen des neuen zugeordneten
          Geräts an. Bei Kernel-Zuordnern, wie verschlüsselten Geräten
          vom Typ ‘luks-device-mapping’, wird durch Angabe von
          ‘"my-partition"’ ein Gerät ‘"/dev/mapper/my-partition"’
          erzeugt. Bei RAID-Geräten vom Typ ‘raid-device-mapping’ muss
          der Gerätename als voller Pfad wie zum Beispiel ‘"/dev/md0"’
          angegeben werden.

     ‘type’
          Dies muss ein ‘mapped-device-kind’-Objekt sein, das angibt,
          wie die Quelle SOURCE dem Ziel TARGET zugeordnet wird.

 -- Scheme-Variable: luks-device-mapping
     Hiermit wird ein blockorientiertes Gerät mit LUKS verschlüsselt,
     mit Hilfe des Befehls ‘cryptsetup’ aus dem gleichnamigen Paket.
     Dazu wird das Linux-Kernel-Modul ‘dm-crypt’ vorausgesetzt.

 -- Scheme-Variable: raid-device-mapping
     Dies definiert ein RAID-Gerät, das mit dem Befehl ‘mdadm’ aus dem
     gleichnamigen Paket als Verbund zusammengestellt wird. Es setzt
     voraus, dass das Linux-Kernel-Modul für das entsprechende
     RAID-Level geladen ist, z.B. ‘raid456’ für RAID-4, RAID-5 oder
     RAID-6, oder ‘raid10’ für RAID-10.

   Das folgende Beispiel gibt eine Zuordnung von ‘/dev/sda3’ auf
‘/dev/mapper/home’ mit LUKS an — dem Linux Unified Key Setup
(https://gitlab.com/cryptsetup/cryptsetup), einem Standardmechanismus
zur Plattenverschlüsselung. Das Gerät ‘/dev/mapper/home’ kann dann als
‘device’ einer ‘file-system’-Deklaration benutzt werden (siehe *note
Dateisysteme::).

     (mapped-device
       (source "/dev/sda3")
       (target "home")
       (type luks-device-mapping))

   Um nicht davon abhängig zu sein, wie Ihre Geräte nummeriert werden,
können Sie auch die LUKS-UUID (“unique identifier”, d.h. den eindeutigen
Bezeichner) des Quellgeräts auf der Befehlszeile ermitteln:

     cryptsetup luksUUID /dev/sda3

   und wie folgt benutzen:

     (mapped-device
       (source (uuid "cb67fc72-0d54-4c88-9d4b-b225f30b0f44"))
       (target "home")
       (type luks-device-mapping))

   Es ist auch wünschenswert, Swap-Speicher zu verschlüsseln, da in den
Swap-Speicher sensible Daten ausgelagert werden können. Eine Möglichkeit
ist, eine Swap-Datei auf einem mit LUKS-Verschlüsselung zugeordneten
Dateisystem zu verwenden. Dann wird die Swap-Datei verschlüsselt, weil
das ganze Gerät verschlüsselt wird. Ein Beispiel finden Sie im Abschnitt
*note Disk Partitioning: Vor der Installation.

   Ein RAID-Gerät als Verbund der Partitionen ‘/dev/sda1’ und
‘/dev/sdb1’ kann wie folgt deklariert werden:

     (mapped-device
       (source (list "/dev/sda1" "/dev/sdb1"))
       (target "/dev/md0")
       (type raid-device-mapping))

   Das Gerät ‘/dev/md0’ kann als ‘device’ in einer
‘file-system’-Deklaration dienen (siehe *note Dateisysteme::). Beachten
Sie, dass das RAID-Level dabei nicht angegeben werden muss; es wird
während der initialen Erstellung und Formatierung des RAID-Geräts
festgelegt und später automatisch bestimmt.

   ---------- Footnotes ----------

   (1) Beachten Sie, dass mit GNU Hurd kein Unterschied zwischen dem
Konzept eines „zugeordneten Geräts“ und dem eines Dateisystems besteht:
Dort werden bei beiden Ein- und Ausgabeoperationen auf eine Datei in
Operationen auf dessen Hintergrundspeicher _übersetzt_. Hurd
implementiert zugeordnete Geräte genau wie Dateisysteme mit dem
generischen “Übersetzer”-Mechanismus (siehe *note (hurd)Translators::).


File: guix.de.info,  Node: Benutzerkonten,  Next: Tastaturbelegung,  Prev: Zugeordnete Geräte,  Up: Systemkonfiguration

8.5 Benutzerkonten
==================

Benutzerkonten und Gruppen werden allein durch die
‘operating-system’-Deklaration des Betriebssystems verwaltet. Sie werden
mit den ‘user-account’- und ‘user-group’-Formen angegeben:

     (user-account
       (name "alice")
       (group "users")
       (supplementary-groups '("wheel"   ;zur sudo-Nutzung usw. berechtigen
                               "audio"   ;Soundkarte
                               "video"   ;Videogeräte wie Webcams
                               "cdrom")) ;die gute alte CD-ROM
       (comment "Bobs Schwester")
       (home-directory "/home/alice"))

   Beim Hochfahren oder nach Abschluss von ‘guix system reconfigure’
stellt das System sicher, dass nur die in der
‘operating-system’-Deklaration angegebenen Benutzerkonten und Gruppen
existieren, mit genau den angegebenen Eigenschaften. Daher gehen durch
direkten Aufruf von Befehlen wie ‘useradd’ erwirkte Erstellungen oder
Modifikationen von Konten oder Gruppen verloren, sobald rekonfiguriert
oder neugestartet wird. So wird sichergestellt, dass das System genau so
funktioniert, wie es deklariert wurde.

 -- Datentyp: user-account
     Objekte dieses Typs repräsentieren Benutzerkonten. Darin können
     folgende Komponenten aufgeführt werden:

     ‘name’
          Der Name des Benutzerkontos.

     ‘group’
          Dies ist der Name (als Zeichenkette) oder die Bezeichnung (als
          Zahl) der Benutzergruppe, zu der dieses Konto gehört.

     ‘supplementary-groups’ (Vorgabe: ‘'()’)
          Dies kann optional als Liste von Gruppennamen angegeben
          werden, zu denen dieses Konto auch gehört.

     ‘uid’ (Vorgabe: ‘#f’)
          Dies ist entweder der Benutzeridentifikator dieses Kontos
          (seine „User ID“) als Zahl oder ‘#f’. Bei Letzterem wird vom
          System automatisch eine Zahl gewählt, wenn das Benutzerkonto
          erstellt wird.

     ‘comment’ (Vorgabe: ‘""’)
          Ein Kommentar zu dem Konto, wie etwa der vollständige Name des
          Kontoinhabers.

     ‘home-directory’
          Der Name des Persönlichen Verzeichnisses („Home“-Verzeichnis)
          für dieses Konto.

     ‘create-home-directory?’ (Vorgabe: ‘#t’)
          Zeigt an, ob das Persönliche Verzeichnis für das Konto
          automatisch erstellt werden soll, falls es noch nicht
          existiert.

     ‘shell’ (Vorgabe: Bash)
          Ein G-Ausdruck, der den Dateinamen des Programms angibt, das
          dem Benutzer als Shell dienen soll (siehe *note
          G-Ausdrücke::).

     ‘system?’ (Vorgabe: ‘#f’)
          Dieser boolesche Wert zeigt an, ob das Konto ein
          „System“-Benutzerkonto ist. Systemkonten werden manchmal
          anders behandelt, zum Beispiel werden sie auf grafischen
          Anmeldebildschirmen nicht aufgeführt.

     ‘password’ (Vorgabe: ‘#f’)
          Normalerweise lassen Sie dieses Feld auf ‘#f’ und
          initialisieren Benutzerpasswörter als ‘root’ mit dem
          ‘passwd’-Befehl. Die Benutzer lässt man ihr eigenes Passwort
          dann mit ‘passwd’ ändern. Mit ‘passwd’ festgelegte Passwörter
          bleiben natürlich beim Neustarten und beim Rekonfigurieren
          erhalten.

          Wenn Sie aber _doch_ ein anfängliches Passwort für ein Konto
          voreinstellen möchten, muss dieses Feld hier das
          verschlüsselte Passwort als Zeichenkette enthalten. Sie können
          dazu die Prozedur ‘crypt’ benutzen.

               (user-account
                 (name "charlie")
                 (group "users")

                 ;; Ein mit SHA-512 gehashtes initiales Passwort.
                 (password (crypt "InitialPassword!" "$6$abc")))

               Anmerkung: Der Hash dieses initialen Passworts wird in
               einer Datei im ‘/gnu/store’ abgelegt, auf die alle
               Benutzer Lesezugriff haben, daher ist Vorsicht geboten,
               wenn Sie diese Methode verwenden.

          Siehe *note (libc)Passphrase Storage:: für weitere
          Informationen über Passwortverschlüsselung und *note
          (guile)Encryption:: für Informationen über die Prozedur
          ‘crypt’ in Guile.

   Benutzergruppen-Deklarationen sind noch einfacher aufgebaut:

     (user-group (name "students"))

 -- Datentyp: user-group
     Dieser Typ gibt, nun ja, eine Benutzergruppe an. Es gibt darin nur
     ein paar Felder:

     ‘name’
          Der Name der Gruppe.

     ‘id’ (Vorgabe: ‘#f’)
          Der Gruppenbezeichner (eine Zahl). Wird er als ‘#f’ angegeben,
          wird automatisch eine neue Zahl reserviert, wenn die Gruppe
          erstellt wird.

     ‘system?’ (Vorgabe: ‘#f’)
          Dieser boolesche Wert gibt an, ob es sich um eine
          „System“-Gruppe handelt. Systemgruppen sind solche mit einer
          kleinen Zahl als Bezeichner.

     ‘password’ (Vorgabe: ‘#f’)
          Wie, Benutzergruppen können ein Passwort haben? Nun ja,
          anscheinend schon. Wenn es nicht auf ‘#f’ steht, gibt dieses
          Feld das Passwort der Gruppe an.

   Um Ihnen das Leben zu erleichtern, gibt es eine Variable, worin alle
grundlegenden Benutzergruppen aufgeführt sind, die man erwarten könnte:

 -- Scheme-Variable: %base-groups
     Die Liste von Basis-Benutzergruppen, von denen Benutzer und/oder
     Pakete erwarten könnten, dass sie auf dem System existieren. Dazu
     gehören Gruppen wie „root“, „wheel“ und „users“, sowie Gruppen, um
     den Zugriff auf bestimmte Geräte einzuschränken, wie „audio“,
     „disk“ und „cdrom“.

 -- Scheme-Variable: %base-user-accounts
     Diese Liste enthält Basis-Systembenutzerkonten, von denen Programme
     erwarten können, dass sie auf einem GNU/Linux-System existieren,
     wie das Konto „nobody“.

     Beachten Sie, dass das Konto „root“ für den Administratornutzer
     nicht dazugehört. Es ist ein Sonderfall und wird automatisch
     erzeugt, egal ob es spezifiziert wurde oder nicht.


File: guix.de.info,  Node: Tastaturbelegung,  Next: Locales,  Prev: Benutzerkonten,  Up: Systemkonfiguration

8.6 Tastaturbelegung
====================

Um anzugeben, was jede Taste auf Ihrer Tastatur tut, müssen Sie angeben,
welche “Tastaturbelegung” das Betriebssystem benutzen soll. Wenn nichts
angegeben wird, ist die „US English“-QWERTY-Tastaturbelegung für
PC-Tastaturen mit 105 Tasten voreingestellt. Allerdings bevorzugen
Deutsch sprechende Nutzer meistens die deutsche QWERTZ-Tastaturbelegung,
Französisch sprechende haben lieber die AZERTY-Belegung und so weiter;
Hacker wollen vielleicht Dvorak oder Bépo als Tastaturbelegung benutzen
oder sogar eigene Anpassungen bei manchen Tasten vornehmen. Dieser
Abschnitt erklärt, wie das geht.

   Die Informationen über Ihre Tastaturbelegung werden an drei Stellen
gebraucht:

   • Der _Bootloader_ muss auslesen können, welche Tastaturbelegung Sie
     benutzen möchten (siehe *note ‘keyboard-layout’:
     Bootloader-Konfiguration.). Das ist praktisch, wenn Sie zum
     Beispiel die Passphrase Ihrer verschlüsselten Wurzelpartition mit
     der richtigen Tastaturbelegung eintippen wollen.

   • Der _Kernel des Betriebssystems_, Linux, braucht die Information,
     damit die Konsole richtig eingestellt ist (siehe *note
     ‘keyboard-layout’: „operating-system“-Referenz.).

   • Der _grafische Anzeigeserver_, meistens ist das Xorg, hat auch
     seine eigene Konfiguration der Tastaturbelegung (siehe *note
     ‘keyboard-layout’: X Window.).

   Mit Guix können Sie alle drei Komponenten separat konfigurieren, aber
zum Glück können Sie damit auch dieselbe Konfiguration der
Tastaturbelegung für alle drei benutzen.

   Tastaturbelegungen werden durch Verbundsobjekte repräsentiert, die
mit der Prozedur ‘keyboard-layout’ aus dem Modul ‘(gnu system keyboard)’
angelegt werden. Entsprechend der „X-Keyboard“-Erweiterung (XKB) verfügt
jede Tastaturbelegung über vier Attribute: einen Namen (oft ist das ein
Sprachkürzel wie „fi“ für Finnisch oder „jp“ für Japanisch), ein
optionaler Variantenname, ein optionaler Tastaturmodellname und eine
möglicherweise leere Liste zusätzlicher Optionen. In den meisten Fällen
interessiert Sie nur der Name der Tastaturbelegung. Hier sind ein paar
Beispiele:

     ;; Die deutsche QWERTZ-Belegung. Hierbei nehmen wir
     ;; ein Standard-"pc105"-Tastaturmodell an.
     (keyboard-layout "de")

     ;; Die Bépo-Variante der französischen Belegung.
     (keyboard-layout "fr" "bepo")

     ;; Die katalanische Tastaturbelegung.
     (keyboard-layout "es" "cat")

     ;; Arabische Tastaturbelegung. "Alt-Umschalt" wechselt auf US-Amerikanisch.
     (keyboard-layout "ar,us" #:options '("grp:alt_shift_toggle"))

     ;; Die lateinamerikanisch-spanische Tastaturbelegung. Des Weiteren
     ;; wird die Feststelltaste (auf Englisch "Caps Lock") als eine
     ;; weitere Steuerungstaste (auf Englisch "Ctrl") festgelegt und
     ;; die Menütaste soll als eine "Compose"-Taste herhalten, mit der
     ;; Buchstaben mit Diakritika geschrieben werden können.
     (keyboard-layout "latam"
                      #:options '("ctrl:nocaps" "compose:menu"))

     ;; Die russische Tastaturbelegung für eine ThinkPad-Tastatur.
     (keyboard-layout "ru" #:model "thinkpad")

     ;; Die Tastaturbelegung "US international", d.h. die US-Belegung
     ;; mit Tottasten zur Eingabe von Buchstaben mit Diakritika. Hier
     ;; wird die Belegung für eine Apple-MacBook-Tastatur gewählt.
     (keyboard-layout "us" "intl" #:model "macbook78")

   Im Verzeichnis ‘share/X11/xkb’ des ‘xkeyboard-config’-Pakets finden
Sie eine vollständige Liste der unterstützten Tastaturbelegungen,
Varianten und Modelle.

   Sagen wir, Sie würden gerne die türkische Tastaturbelegung für Ihr
gesamtes System — Bootloader, Konsole und Xorg — verwenden. Dann würde
Ihre Systemkonfiguration so aussehen:

     ;; Die türkische Tastaturbelegung für Bootloader, Konsole und Xorg
     ;; benutzen.

     (operating-system
       ;; …
       (keyboard-layout (keyboard-layout "tr"))  ;für die Konsole
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout))) ;für GRUB
       (services (cons (set-xorg-configuration
                         (xorg-configuration             ;für Xorg
                           (keyboard-layout keyboard-layout)))
                       %desktop-services)))

   Im obigen Beispiel beziehen wir uns für GRUB und Xorg einfach auf das
‘keyboard-layout’-Feld, was wir darüber definiert haben, wir könnten
aber auch eine andere Tastaturbelegung angeben. Die Prozedur
‘set-xorg-configuration’ kommuniziert an die grafische Anmeldeverwaltung
(d.h. nach Vorgabe an GDM), welche Xorg-Konfiguration verwendet werden
soll.

   Wir haben uns bisher damit auseinandergesetzt, wie die
_Voreinstellung_ für die Tastaturbelegung ausgewählt werden kann, die
das System annimmt, wenn es startet, aber zur Laufzeit kann sie geändert
werden:

   • Wenn Sie GNOME benutzen, können Sie in den Einstellungen dazu einen
     Eintrag „Region und Sprache“ finden, in dem Sie eine oder mehrere
     Tastaturbelegungen auswählen können.

   • Unter Xorg können Sie den Befehl ‘setxkbmap’ (aus dem gleichnamigen
     Paket) zum Anpassen der momentan aktiven Tastaturbelegung benutzen.
     Zum Beispiel würden Sie so die Belegung auf US Dvorak wechseln:

          setxkbmap us dvorak

   • Mit dem Befehl ‘loadkeys’ ändern Sie die für die Linux-Konsole
     geltende Tastaturbelegung. Allerdings ist zu beachten, dass
     ‘loadkeys’ _nicht_ die Kategorisierung der Tastaturbelegungen von
     XKB benutzt. Der Befehl, um die französische Bépo-Belegung zu
     laden, wäre folgender:

          loadkeys fr-bepo


File: guix.de.info,  Node: Locales,  Next: Dienste,  Prev: Tastaturbelegung,  Up: Systemkonfiguration

8.7 Locales
===========

Eine “Locale” legt die kulturellen Konventionen einer bestimmten Sprache
und Region auf der Welt fest (siehe *note (libc)Locales::). Jede Locale
hat einen Namen, der typischerweise von der Form
‘SPRACHE_GEBIET.KODIERUNG’ — z.B. benennt ‘fr_LU.utf8’ die Locale für
französische Sprache mit den kulturellen Konventionen aus Luxemburg
unter Verwendung der UTF-8-Kodierung.

   Normalerweise werden Sie eine standardmäßig zu verwendende Locale für
die Maschine vorgeben wollen, indem Sie das ‘locale’-Feld der
‘operating-system’-Deklaration verwenden (siehe *note ‘locale’:
„operating-system“-Referenz.).

   Die ausgewählte Locale wird automatisch zu den dem System bekannten
“Locale-Definitionen” hinzugefügt, falls nötig, und ihre Kodierung wird
aus dem Namen hergeleitet — z.B. wird angenommen, dass ‘bo_CN.utf8’ als
Kodierung ‘UTF-8’ verwendet. Zusätzliche Locale-Definitionen können im
Feld ‘locale-definitions’ vom ‘operating-system’ festgelegt werden — das
ist zum Beispiel dann nützlich, wenn die Kodierung nicht aus dem
Locale-Namen hergeleitet werden konnte. Die vorgegebene Menge an
Locale-Definitionen enthält manche weit verbreiteten Locales, aber um
Platz zu sparen, nicht alle verfügbaren Locales.

   Um zum Beispiel die nordfriesische Locale für Deutschland
hinzuzufügen, könnte der Wert des Feldes wie folgt aussehen:

     (cons (locale-definition
             (name "fy_DE.utf8") (source "fy_DE"))
           %default-locale-definitions)

   Um Platz zu sparen, könnte man auch wollen, dass ‘locale-definitions’
nur die tatsächlich benutzen Locales aufführt, wie etwa:

     (list (locale-definition
             (name "ja_JP.eucjp") (source "ja_JP")
             (charset "EUC-JP")))

   Die kompilierten Locale-Definitionen sind unter
‘/run/current-system/locale/X.Y’ verfügbar, wobei ‘X.Y’ die Version von
libc bezeichnet. Dies entspricht dem Pfad, an dem eine von Guix
ausgelieferte GNU libc standardmäßig nach Locale-Daten sucht. Er kann
überschrieben werden durch die Umgebungsvariable ‘LOCPATH’ (siehe *note
‘LOCPATH’ und Locale-Pakete: locales-and-locpath.).

   Die ‘locale-definition’-Form wird vom Modul ‘(gnu system locale)’ zur
Verfügung gestellt. Details folgen unten.

 -- Datentyp: locale-definition
     Dies ist der Datentyp einer Locale-Definition.

     ‘name’
          Der Name der Locale. Siehe *note (libc)Locale Names:: für mehr
          Informationen zu Locale-Namen.

     ‘source’
          Der Name der Quelle der Locale. Typischerweise ist das der
          Teil ‘SPRACHE_GEBIET’ des Locale-Namens.

     ‘charset’ (Vorgabe: ‘"UTF-8"’)
          Der „Zeichensatz“ oder das „Code set“, d.h. die Kodierung
          dieser Locale, wie die IANA sie definiert
          (https://www.iana.org/assignments/character-sets).

 -- Scheme-Variable: %default-locale-definitions
     Eine Liste häufig benutzter UTF-8-Locales, die als Vorgabewert des
     ‘locale-definitions’-Feldes in ‘operating-system’-Deklarationen
     benutzt wird.

     Diese Locale-Definitionen benutzen das “normalisierte Codeset” für
     den Teil des Namens, der nach dem Punkt steht (siehe *note
     normalized codeset: (libc)Using gettextized software.). Zum
     Beispiel ist ‘uk_UA.utf8’ enthalten, dagegen ist etwa ‘uk_UA.UTF-8’
     darin _nicht_ enthalten.

8.7.1 Kompatibilität der Locale-Daten
-------------------------------------

‘operating-system’-Deklarationen verfügen über ein ‘locale-libcs’-Feld,
um die GNU libc-Pakete anzugeben, die zum Kompilieren von
Locale-Deklarationen verwendet werden sollen (siehe *note
„operating-system“-Referenz::). „Was interessiert mich das?“, könnten
Sie fragen. Naja, leider ist das binäre Format der Locale-Daten von
einer libc-Version auf die nächste manchmal nicht miteinander
kompatibel.

   Zum Beispiel kann ein an die libc-Version 2.21 gebundenes Programm
keine mit libc 2.22 erzeugten Locale-Daten lesen; schlimmer noch, das
Programm _terminiert_ statt einfach die inkompatiblen Locale-Daten zu
ignorieren(1). Ähnlich kann ein an libc 2.22 gebundenes Programm die
meisten, aber nicht alle, Locale-Daten von libc 2.21 lesen (Daten zu
‘LC_COLLATE’ sind aber zum Beispiel inkompatibel); somit schlagen
Aufrufe von ‘setlocale’ vielleicht fehl, aber das Programm läuft weiter.

   Das „Problem“ mit Guix ist, dass Nutzer viel Freiheit genießen: Sie
können wählen, ob und wann sie die Software in ihren Profilen
aktualisieren und benutzen vielleicht eine andere libc-Version als sie
der Systemadministrator benutzt hat, um die systemweiten Locale-Daten zu
erstellen.

   Glücklicherweise können „unprivilegierte“ Nutzer ohne zusätzliche
Berechtigungen dann zumindest ihre eigenen Locale-Daten installieren und
GUIX_LOCPATH entsprechend definieren (siehe *note ‘GUIX_LOCPATH’ und
Locale-Pakete: locales-and-locpath.).

   Trotzdem ist es am besten, wenn die systemweiten Locale-Daten unter
‘/run/current-system/locale’ für alle libc-Versionen erstellt werden,
die auf dem System noch benutzt werden, damit alle Programme auf sie
zugreifen können — was auf einem Mehrbenutzersystem ganz besonders
wichtig ist. Dazu kann der Administrator des Systems mehrere libc-Pakete
im ‘locale-libcs’-Feld vom ‘operating-system’ angeben:

     (use-package-modules base)

     (operating-system
       ;; …
       (locale-libcs (list glibc-2.21 (canonical-package glibc))))

   Mit diesem Beispiel ergäbe sich ein System, was Locale-Definitionen
sowohl für libc 2.21 als auch die aktuelle Version von libc in
‘/run/current-system/locale’ hat.

   ---------- Footnotes ----------

   (1) Versionen 2.23 von GNU libc und neuere werden inkompatible
Locale-Daten nur mehr überspringen, was schon einmal eine Verbesserung
ist.


File: guix.de.info,  Node: Dienste,  Next: Setuid-Programme,  Prev: Locales,  Up: Systemkonfiguration

8.8 Dienste
===========

Ein wichtiger Bestandteil des Schreibens einer
‘operating-system’-Deklaration ist das Auflisten der “Systemdienste” und
ihrer Konfiguration (siehe *note Das Konfigurationssystem nutzen::).
Systemdienste sind typischerweise im Hintergrund laufende
Daemon-Programme, die beim Hochfahren des Systems gestartet werden, oder
andere Aktionen, die zu dieser Zeit durchgeführt werden müssen — wie das
Konfigurieren des Netzwerkzugangs.

   Guix hat eine weit gefasste Definition, was ein „Dienst“ ist (siehe
*note Dienstkompositionen::), aber viele Dienste sind solche, die von
GNU Shepherd verwaltet werden (siehe *note Shepherd-Dienste::). Auf
einem laufenden System kann der ‘herd’-Befehl benutzt werden, um
verfügbare Dienste aufzulisten, ihren Status anzuzeigen, sie zu starten
und zu stoppen oder andere angebotene Operationen durchzuführen (siehe
*note (shepherd)Jump Start::). Zum Beispiel:

     # herd status

   Dieser Befehl, durchgeführt als ‘root’, listet die momentan
definierten Dienste auf. Der Befehl ‘herd doc’ fasst kurz zusammen, was
ein gegebener Dienst ist und welche Aktionen mit ihm assoziiert sind:

     # herd doc nscd
     Run libc's name service cache daemon (nscd).

     # herd doc nscd action invalidate
     invalidate: Invalidate the given cache--e.g., 'hosts' for host name lookups.

   Die Unterbefehle ‘start’, ‘stop’ und ‘restart’ haben die Wirkung, die
man erwarten würde. Zum Beispiel kann mit folgenden Befehlen der
nscd-Dienst angehalten und der Xorg-Anzeigeserver neu gestartet werden:

     # herd stop nscd
     Service nscd has been stopped.
     # herd restart xorg-server
     Service xorg-server has been stopped.
     Service xorg-server has been started.

   Die folgenden Abschnitte dokumentieren die verfügbaren Dienste, die
in einer ‘operating-system’-Deklaration benutzt werden können,
angefangen mit den Diensten im Kern des Systems („core services“)

* Menu:

* Basisdienste::             Essenzielle Systemdienste.
* Geplante Auftragsausführung::  Der mcron-Dienst.
* Log-Rotation::             Der rottlog-Dienst.
* Netzwerkdienste::          Netzwerkeinrichtung, SSH-Daemon etc.
* X Window::                 Grafische Anzeige.
* Druckdienste::             Unterstützung für lokale und entfernte
                               Drucker.
* Desktop-Dienste::          D-Bus- und Desktop-Dienste.
* Tondienste::               Dienste für ALSA und Pulseaudio.
* Datenbankdienste::         SQL-Datenbanken, Schlüssel-Wert-Speicher etc.
* Mail-Dienste::             IMAP, POP3, SMTP und so weiter.
* Kurznachrichtendienste::   Dienste für Kurznachrichten.
* Telefondienste::           Telefoniedienste.
* Systemüberwachungsdienste::  Dienste zur Systemüberwachung.
* Kerberos-Dienste::         Kerberos-Dienste.
* LDAP-Dienste::             LDAP-Dienste.
* Web-Dienste::              Web-Server.
* Zertifikatsdienste::       TLS-Zertifikate via Let’s Encrypt.
* DNS-Dienste::              DNS-Daemons.
* VPN-Dienste::              VPN-Daemons.
* Network File System::      Dienste mit Bezug zum Netzwerkdateisystem.
* Kontinuierliche Integration::  Der Cuirass-Dienst.
* Dienste zur Stromverbrauchsverwaltung::  Den Akku schonen.
* Audio-Dienste::            Der MPD.
* Virtualisierungsdienste::  Dienste für virtuelle Maschinen.
* Versionskontrolldienste::  Entfernten Zugang zu Git-Repositorys bieten.
* Spieldienste::             Spielserver.
* PAM-Einbindedienst::       Dienst, um Datenträger beim Anmelden
                               einzubinden.
* Guix-Dienste::             Dienste, die speziell mit Guix zu tun haben.
* Linux-Dienste::            Dienste nur für Systeme mit Linux-Kernel.
* Verschiedene Dienste::     Andere Dienste.


File: guix.de.info,  Node: Basisdienste,  Next: Geplante Auftragsausführung,  Up: Dienste

8.8.1 Basisdienste
------------------

Das Modul ‘(gnu services base)’ stellt Definitionen für Basis-Dienste
zur Verfügung, von denen man erwartet, dass das System sie anbietet. Im
Folgenden sind die von diesem Modul exportierten Dienste aufgeführt.

 -- Scheme-Variable: %base-services
     Diese Variable enthält eine Liste von Basis-Diensten, die man auf
     einem System vorzufinden erwartet (siehe *note Diensttypen und
     Dienste:: für weitere Informationen zu Dienstobjekten): ein
     Anmeldungsdienst (mingetty) auf jeder Konsole (jedem „tty“),
     syslogd, den Name Service Cache Daemon (nscd) von libc, die
     udev-Geräteverwaltung und weitere.

     Dies ist der Vorgabewert für das ‘services’-Feld für die Dienste
     von ‘operating-system’-Deklarationen. Normalerweise werden Sie,
     wenn Sie ein Betriebssystem anpassen, Dienste an die
     ‘%base-services’-Liste anhängen, wie hier gezeigt:

          (append (list (service avahi-service-type)
                        (service openssh-service-type))
                  %base-services)

 -- Scheme-Variable: special-files-service-type
     Dieser Dienst richtet „besondere Dateien“ wie ‘/bin/sh’ ein; eine
     Instanz des Dienstes ist Teil der ‘%base-services’.

     Der mit ‘special-files-service-type’-Diensten assoziierte Wert muss
     eine Liste von Tupeln sein, deren erstes Element eine „besondere
     Datei“ und deren zweites Element deren Zielpfad ist. Der
     Vorgabewert ist:

          `(("/bin/sh" ,(file-append bash "/bin/sh")))

     Wenn Sie zum Beispiel auch ‘/usr/bin/env’ zu Ihrem System
     hinzufügen möchten, können Sie den Wert ändern auf:

          `(("/bin/sh" ,(file-append bash "/bin/sh"))
            ("/usr/bin/env" ,(file-append coreutils "/bin/env")))

     Da dieser Dienst Teil der ‘%base-services’ ist, können Sie
     ‘modify-services’ benutzen, um die Liste besonderer Dateien
     abzuändern (siehe *note ‘modify-services’: Service-Referenz.). Die
     leichte Alternative, um eine besondere Datei hinzuzufügen, ist über
     die Prozedur ‘extra-special-file’ (siehe unten).

 -- Scheme-Prozedur: extra-special-file DATEI ZIEL
     Das ZIEL als „besondere Datei“ DATEI verwenden.

     Beispielsweise können Sie die folgenden Zeilen in das
     ‘services’-Feld Ihrer Betriebssystemdeklaration einfügen für eine
     symbolische Verknüpfung ‘/usr/bin/env’:

          (extra-special-file "/usr/bin/env"
                              (file-append coreutils "/bin/env"))

 -- Scheme-Prozedur: host-name-service NAME
     Liefert einen Dienst, der den Rechnernamen (den „Host“-Namen des
     Rechners) als NAME festlegt.

 -- Scheme-Variable: console-font-service-type
     Installiert die angegebenen Schriftarten auf den festgelegten TTYs
     (auf dem Linux-Kernel werden Schriftarten für jede virtuelle
     Konsole einzeln festgelegt). Als Wert nimmt dieser Dienst eine
     Liste von Paaren aus TTY und Schriftart. Als Schriftart kann der
     Name einer vom ‘kbd’-Paket zur Verfügung gestellten Schriftart oder
     ein beliebiges gültiges Argument für ‘setfont’ dienen. Ein
     Beispiel:

          `(("tty1" . "LatGrkCyr-8x16")
            ("tty2" . ,(file-append
                          font-tamzen
                          "/share/kbd/consolefonts/TamzenForPowerline10x20.psf"))
            ("tty3" . ,(file-append
                          font-terminus
                          "/share/consolefonts/ter-132n"))) ; für HiDPI

 -- Scheme-Prozedur: login-service KONFIGURATION
     Liefert einen Dienst, der die Benutzeranmeldung möglich macht. Dazu
     verwendet er die angegebene KONFIGURATION, ein
     ‘<login-configuration>’-Objekt, das unter anderem die beim Anmelden
     angezeigte Mitteilung des Tages („Message of the Day“) festlegt.

 -- Datentyp: login-configuration
     Dies ist der Datentyp, der die Anmeldekonfiguration repräsentiert.

     ‘motd’
          Ein dateiartiges Objekt, das die „Message of the Day“ enthält.

     ‘allow-empty-passwords?’ (Vorgabe: ‘#t’)
          Leere Passwörter standardmäßig zulassen, damit sich neue
          Anwender anmelden können, direkt nachdem das Benutzerkonto
          „root“ für den Administrator angelegt wurde.

 -- Scheme-Prozedur: mingetty-service KONFIGURATION
     Liefert einen Dienst, der mingetty nach den Vorgaben der
     KONFIGURATION ausführt, einem ‘<mingetty-configuration>’-Objekt,
     das unter anderem die Konsole (das „tty“) festlegt, auf der
     mingetty laufen soll.

 -- Datentyp: mingetty-configuration
     Dieser Datentyp repräsentiert die Konfiguration von Mingetty, der
     vorgegebenen Implementierung zur Anmeldung auf einer virtuellen
     Konsole.

     ‘tty’
          Der Name der Konsole, auf der diese Mingetty-Instanz läuft —
          z.B. ‘"tty1"’.

     ‘auto-login’ (Vorgabe: ‘#f’)
          Steht dieses Feld auf wahr, muss es eine Zeichenkette sein,
          die den Benutzernamen angibt, als der man vom System
          automatisch angemeldet wird. Ist es ‘#f’, so muss zur
          Anmeldung ein Benutzername und ein Passwort eingegeben werden.

     ‘login-program’ (Vorgabe: ‘#f’)
          Dies muss entweder ‘#f’ sein, dann wird das voreingestellte
          Anmeldeprogramm benutzt (‘login’ aus dem Shadow-Werkzeugsatz)
          oder der Name des Anmeldeprogramms als G-Ausdruck.

     ‘login-pause?’ (Vorgabe: ‘#f’)
          Ist es auf ‘#t’ gesetzt, sorgt es in Verbindung mit AUTO-LOGIN
          dafür, dass der Benutzer eine Taste drücken muss, ehe eine
          Anmelde-Shell gestartet wird.

     ‘mingetty’ (Vorgabe: MINGETTY)
          Welches Mingetty-Paket benutzt werden soll.

 -- Scheme-Prozedur: agetty-service KONFIGURATION
     Liefert einen Dienst, um agetty entsprechend der KONFIGURATION
     auszuführen, welche ein ‘<agetty-configuration>’-Objekt sein muss,
     das unter anderem festlegt, auf welchem tty es laufen soll.

 -- Datentyp: agetty-configuration
     Dies ist der Datentyp, der die Konfiguration von agetty
     repräsentiert, was Anmeldungen auf einer virtuellen oder seriellen
     Konsole implementiert. Siehe die Handbuchseite ‘agetty(8)’ für mehr
     Informationen.

     ‘tty’
          Der Name der Konsole, auf der diese Instanz von agetty läuft,
          als Zeichenkette — z.B. ‘"ttyS0"’. Dieses Argument ist
          optional, sein Vorgabewert ist eine vernünftige Wahl unter den
          seriellen Schnittstellen, auf deren Benutzung der Linux-Kernel
          eingestellt ist.

          Hierzu wird, wenn in der Kernel-Befehlszeile ein Wert für eine
          Option namens ‘agetty.tty’ festgelegt wurde, der Gerätename
          daraus für agetty extrahiert und benutzt.

          Andernfalls wird agetty, falls auf der Kernel-Befehlszeile
          eine Option ‘console’ mit einem tty vorkommt, den daraus
          extrahierten Gerätenamen der seriellen Schnittstelle benutzen.

          In beiden Fällen wird agetty nichts an den anderen
          Einstellungen für serielle Geräte verändern (Baud-Rate etc.),
          in der Hoffnung, dass Linux sie auf die korrekten Werte
          festgelegt hat.

     ‘baud-rate’ (Vorgabe: ‘#f’)
          Eine Zeichenkette, die aus einer kommagetrennten Liste von
          einer oder mehreren Baud-Raten besteht, absteigend sortiert.

     ‘term’ (Vorgabe: ‘#f’)
          Eine Zeichenkette, die den Wert enthält, der für die
          Umgebungsvariable ‘TERM’ benutzt werden soll.

     ‘eight-bits?’ (Vorgabe: ‘#f’)
          Steht dies auf ‘#t’, wird angenommen, dass das tty
          8-Bit-korrekt ist, so dass die Paritätserkennung abgeschaltet
          wird.

     ‘auto-login’ (Vorgabe: ‘#f’)
          Wird hier ein Anmeldename als eine Zeichenkette übergeben,
          wird der angegebene Nutzer automatisch angemeldet, ohne nach
          einem Anmeldenamen oder Passwort zu fragen.

     ‘no-reset?’ (Vorgabe: ‘#f’)
          Steht dies auf ‘#t’, werden die Cflags des Terminals (d.h.
          dessen Steuermodi) nicht zurückgesetzt.

     ‘host’ (Vorgabe: ‘#f’)
          Dies akzeptiert eine Zeichenkette mit dem einzutragenden
          Anmeldungs-Rechnernamen "login_host", der in die Datei
          ‘/var/run/utmpx’ geschrieben wird.

     ‘remote?’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, wird in Verbindung mit HOST eine
          Befehlszeilenoption ‘-r’ für einen falschen Rechnernamen
          („Fakehost“) in der Befehlszeile des mit LOGIN-PROGRAM
          angegebenen Anmeldeprogramms übergeben.

     ‘flow-control?’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, wird Hardware-Flusssteuerung
          (RTS/CTS) aktiviert.

     ‘no-issue?’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, wird der Inhalt der Datei
          ‘/etc/issue’ _nicht_ angezeigt, bevor die Anmeldeaufforderung
          zu sehen ist.

     ‘init-string’ (Vorgabe: ‘#f’)
          Dies akzeptiert eine Zeichenkette, die zum tty oder zum Modem
          zuerst vor allem anderen gesendet wird. Es kann benutzt
          werden, um ein Modem zu initialisieren.

     ‘no-clear?’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, wird agetty den Bildschirm _nicht_
          löschen, bevor es die Anmeldeaufforderung anzeigt.

     ‘login-program’ (Vorgabe: (file-append shadow "/bin/login"))
          Hier muss entweder ein G-Ausdruck mit dem Namen eines
          Anmeldeprogramms übergeben werden, oder dieses Feld wird nicht
          gesetzt, so dass als Vorgabewert das Programm ‘login’ aus dem
          Shadow-Werkzeugsatz verwendet wird.

     ‘local-line’ (Vorgabe: ‘#f’)
          Steuert den Leitungsschalter CLOCAL. Hierfür wird eines von
          drei Symbolen als Argument akzeptiert, ‘'auto’, ‘'always’ oder
          ‘'never’. Für ‘#f’ wählt agetty als Vorgabewert ‘'auto’.

     ‘extract-baud?’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, so wird agetty angewiesen, die
          Baud-Rate aus den Statusmeldungen mancher Arten von Modem
          abzulesen.

     ‘skip-login?’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, wird der Benutzer nicht
          aufgefordert, einen Anmeldenamen einzugeben. Dies kann
          zusammen mit dem LOGIN-PROGRAM-Feld benutzt werden, um nicht
          standardkonforme Anmeldesysteme zu benutzen.

     ‘no-newline?’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, wird _kein_ Zeilenumbruch
          ausgegeben, bevor die Datei ‘/etc/issue’ ausgegeben wird.

     ‘login-options’ (Vorgabe: ‘#f’)
          Dieses Feld akzeptiert eine Zeichenkette mit den
          Befehlszeilenoptionen für das Anmeldeprogramm. Beachten Sie,
          dass bei einem selbst gewählten LOGIN-PROGRAM ein böswilliger
          Nutzer versuchen könnte, als Anmeldenamen etwas mit
          eingebetteten Befehlszeilenoptionen anzugeben, die vom
          Anmeldeprogramm interpretiert werden könnten.

     ‘login-pause’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, wird auf das Drücken einer
          beliebigen Taste gewartet, bevor die Anmeldeaufforderung
          angezeigt wird. Hiermit kann in Verbindung mit AUTO-LOGIN
          weniger Speicher verbraucht werden, indem man Shells erst
          erzeugt, wenn sie benötigt werden.

     ‘chroot’ (Vorgabe: ‘#f’)
          Wechselt die Wurzel des Dateisystems auf das angegebene
          Verzeichnis. Dieses Feld akzeptiert einen Verzeichnispfad als
          Zeichenkette.

     ‘hangup?’ (Vorgabe: ‘#f’)
          Mit dem Linux-Systemaufruf ‘vhangup’ auf dem angegebenen
          Terminal virtuell auflegen.

     ‘keep-baud?’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, wird versucht, die bestehende
          Baud-Rate beizubehalten. Die Baud-Raten aus dem Feld BAUD-RATE
          werden benutzt, wenn agetty ein <BREAK>-Zeichen empfängt.

     ‘timeout’ (Vorgabe: ‘#f’)
          Ist dies auf einen ganzzahligen Wert gesetzt, wird terminiert,
          falls kein Benutzername innerhalb von TIMEOUT Sekunden
          eingelesen werden konnte.

     ‘detect-case?’ (Vorgabe: ‘#f’)
          Ist dies auf ‘#t’ gesetzt, wird Unterstützung für die
          Erkennung von Terminals aktiviert, die nur Großschreibung
          beherrschen. Mit dieser Einstellung wird, wenn ein Anmeldename
          nur aus Großbuchstaben besteht, dieser als Anzeichen dafür
          aufgefasst, dass das Terminal nur Großbuchstaben beherrscht,
          und einige Umwandlungen von Groß- in Kleinbuchstaben
          aktiviert. Beachten Sie, dass dabei _keine_ Unicode-Zeichen
          unterstützt werden.

     ‘wait-cr?’ (Vorgabe: ‘#f’)
          Wenn dies auf ‘#t’ gesetzt ist, wird gewartet, bis der
          Benutzer oder das Modem einen Wagenrücklauf („Carriage
          Return“) oder einen Zeilenvorschub („Linefeed“) absendet, ehe
          ‘/etc/issue’ oder eine Anmeldeaufforderung angezeigt wird.
          Dies wird typischerweise zusammen mit dem Feld INIT-STRING
          benutzt.

     ‘no-hints?’ (Vorgabe: ‘#f’)
          Ist es auf ‘#t’ gesetzt, werden _keine_ Hinweise zu den
          Feststelltasten Num-Taste, Umschaltsperre („Caps Lock“) und
          Rollen-Taste („Scroll Lock“) angezeigt.

     ‘no-hostname?’ (Vorgabe: ‘#f’)
          Das vorgegebene Verhalten ist, den Rechnernamen auszugeben.
          Ist dieses Feld auf ‘#t’ gesetzt, wird überhaupt kein
          Rechnername angezeigt.

     ‘long-hostname?’ (Vorgabe: ‘#f’)
          Das vorgegebene Verhalten ist, den Rechnernamen nur bis zu
          seinem ersten Punkt anzuzeigen. Ist dieses Feld auf ‘#t’
          gesetzt, wird der vollständige Rechnername (der „Fully
          Qualified Hostname“), wie ihn ‘gethostname’ oder ‘getaddrinfo’
          liefern, angezeigt.

     ‘erase-characters’ (Vorgabe: ‘#f’)
          Dieses Feld akzeptiert eine Zeichenkette aus Zeichen, die auch
          als Rücktaste (zum Löschen) interpretiert werden sollen, wenn
          der Benutzer seinen Anmeldenamen eintippt.

     ‘kill-characters’ (Vorgabe: ‘#f’)
          Dieses Feld akzeptiert eine Zeichenkette aus Zeichen, deren
          Eingabe als „ignoriere alle vorherigen Zeichen“ interpretiert
          werden soll (auch „Kill“-Zeichen genannt), wenn der Benutzer
          seinen Anmeldenamen eintippt.

     ‘chdir’ (Vorgabe: ‘#f’)
          Dieses Feld akzeptiert eine Zeichenkette, die einen
          Verzeichnispfad angibt, zu dem vor der Anmeldung gewechselt
          wird.

     ‘delay’ (Vorgabe: ‘#f’)
          Dieses Feld akzeptiert eine ganze Zahl mit der Anzahl
          Sekunden, die gewartet werden soll, bis ein tty geöffnet und
          die Anmeldeaufforderung angezeigt wird.

     ‘nice’ (Vorgabe: ‘#f’)
          Dieses Feld akzeptiert eine ganze Zahl mit dem „nice“-Wert,
          mit dem das Anmeldeprogramm ausgeführt werden soll.

     ‘extra-options’ (Vorgabe: ‘'()’)
          Dieses Feld ist ein „Notausstieg“, mit dem Nutzer beliebige
          Befehlszeilenoptionen direkt an ‘agetty’ übergeben können.
          Diese müssen hier als eine Liste von Zeichenketten angegeben
          werden.

 -- Scheme-Prozedur: kmscon-service-type KONFIGURATION
     Liefert einen Dienst, um kmscon
     (https://www.freedesktop.org/wiki/Software/kmscon) entsprechend der
     KONFIGURATION auszuführen. Diese ist ein
     ‘<kmscon-configuration>’-Objekt, das unter anderem angibt, auf
     welchem tty es ausgeführt werden soll.

 -- Datentyp: kmscon-configuration
     Dieser Datentyp repräsentiert die Konfiguration von Kmscon, die das
     Anmelden auf virtuellen Konsolen ermöglicht.

     ‘virtual-terminal’
          Der Name der Konsole, auf der diese Kmscon läuft — z.B.
          ‘"tty1"’.

     ‘login-program’ (Vorgabe: ‘#~(string-append #$shadow "/bin/login")’)
          Ein G-Ausdruck, der den Namen des Anmeldeprogramms angibt. Als
          Vorgabe wird das Anmeldeprogramm ‘login’ aus dem
          Shadow-Werkzeugsatz verwendet.

     ‘login-arguments’ (Vorgabe: ‘'("-p")’)
          Eine Liste der Argumente, die an ‘login’ übergeben werden
          sollen.

     ‘auto-login’ (Vorgabe: ‘#f’)
          Wird hier ein Anmeldename als eine Zeichenkette übergeben,
          wird der angegebene Nutzer automatisch angemeldet, ohne nach
          einem Anmeldenamen oder Passwort zu fragen.

     ‘hardware-acceleration?’ (Vorgabe: #f)
          Ob Hardware-Beschleunigung verwendet werden soll.

     ‘kmscon’ (Vorgabe: KMSCON)
          Das Kmscon-Paket, das benutzt werden soll.

 -- Scheme-Prozedur: nscd-service [KONFIGURATION] [#:glibc glibc]
          [#:name-services '()] Liefert einen Dienst, der den Name
          Service Cache
     Daemon (nscd) von libc mit der angegebenen KONFIGURATION ausführt —
     diese muss ein ‘<nscd-configuration>’-Objekt sein. Siehe *note Name
     Service Switch:: für ein Beispiel.

     Der Einfachheit halber bietet der Shepherd-Dienst für nscd die
     folgenden Aktionen an:

     ‘invalidate’
          Dies macht den angegebenen Zwischenspeicher ungültig. Wenn Sie
          zum Beispiel:

               herd invalidate nscd hosts

          ausführen, wird der Zwischenspeicher für die Auflösung von
          Rechnernamen (von „Host“-Namen) des nscd ungültig.

     ‘statistics’
          Wenn Sie ‘herd statistics nscd’ ausführen, werden Ihnen
          Informationen angezeigt, welche Ihnen Informationen über den
          nscd-Zustand und die Zwischenspeicher angezeigt.

 -- Scheme-Variable: %nscd-default-configuration
     This is the default ‘<nscd-configuration>’ value (see below) used
     by ‘nscd-service’. It uses the caches defined by
     ‘%nscd-default-caches’; see below.

 -- Datentyp: nscd-configuration
     Dieser Datentyp repräsentiert die Konfiguration des Name Service
     Caching Daemon (kurz „nscd“).

     ‘name-services’ (Vorgabe: ‘'()’)
          Liste von Paketen, die “Namensdienste” bezeichnen, die für den
          nscd sichtbar sein müssen, z.B. ‘(list NSS-MDNS)’.

     ‘glibc’ (Vorgabe: GLIBC)
          Ein Paket-Objekt, das die GNU-C-Bibliothek angibt, woraus der
          ‘nscd’-Befehl genommen werden soll.

     ‘log-file’ (Vorgabe: ‘"/var/log/nscd.log"’)
          Name der nscd-Protokolldatei. Hierhin werden Ausgaben zur
          Fehlersuche geschrieben, falls ‘debug-level’ echt positiv ist.

     ‘debug-level’ (Vorgabe: ‘0’)
          Eine ganze Zahl, die den Detailgrad der Ausgabe zur
          Fehlersuche angibt. Größere Zahlen bewirken eine
          ausführlichere Ausgabe.

     ‘caches’ (default: ‘%nscd-default-caches’)
          Liste der ‘<nscd-cache>’-Objekte, die repräsentieren, was
          alles zwischengespeichert werden soll; siehe unten.

 -- Datentyp: nscd-cache
     Ein Datentyp, der eine Zwischenspeicher-Datenbank von nscd mitsamt
     ihren Parametern definiert.

     ‘Datenbank’
          Dies ist ein Symbol, was den Namen der Datenbank
          repräsentiert, die zwischengespeichert werden soll. Gültige
          Werte sind ‘passwd’, ‘group’, ‘hosts’ und ‘services’, womit
          jeweils die entsprechende NSS-Datenbank bezeichnet wird (siehe
          *note (libc)NSS Basics::).

     ‘positive-time-to-live’
     ‘negative-time-to-live’ (Vorgabe: ‘20’)
          Eine Zahl, die für die Anzahl an Sekunden steht, die ein
          erfolgreiches (positives) oder erfolgloses (negatives)
          Nachschlageresultat im Zwischenspeicher verbleibt.

     ‘check-files?’ (Vorgabe: ‘#t’)
          Ob auf Änderungen an den der DATABASE entsprechenden Dateien
          reagiert werden soll.

          Wenn DATABASE zum Beispiel ‘hosts’ ist, wird, wenn dieses Feld
          gesetzt ist, nscd Änderungen an ‘/etc/hosts’ beobachten und
          berücksichtigen.

     ‘persistent?’ (Vorgabe: ‘#t’)
          Ob der Zwischenspeicher dauerhaft auf der Platte gespeichert
          werden soll.

     ‘shared?’ (Vorgabe: ‘#t’)
          Ob der Zwischenspeicher zwischen den Nutzern geteilt werden
          soll.

     ‘max-database-size’ (Vorgabe: 32 MiB)
          Die Maximalgröße des Datenbank-Zwischenspeichers in Bytes.

 -- Scheme-Variable: %nscd-default-caches
     Liste von ‘<nscd-cache>’-Objekten, die von der vorgegebenen
     ‘nscd-configuration’ benutzt werden (siehe oben).

     Damit wird dauerhaftes und aggressives Zwischenspeichern beim
     Nachschlagen von Dienst- und Rechnernamen („Host“-Namen) aktiviert.
     Letzteres verbessert die Leistungsfähigkeit beim Nachschlagen von
     Rechnernamen, sorgt für mehr Widerstandsfähigkeit gegenüber
     unverlässlichen Namens-Servern und bietet außerdem einen besseren
     Datenschutz — oftmals befindet sich das Ergebnis einer Anfrage nach
     einem Rechnernamen bereits im lokalen Zwischenspeicher und externe
     Namens-Server müssen nicht miteinbezogen werden.

 -- Datentyp: syslog-configuration
     Dieser Datentyp repräsentiert die Konfiguration des syslog-Daemons.

     ‘syslogd’ (Vorgabe: ‘#~(string-append #$inetutils "/libexec/syslogd")’)
          Welcher Syslog-Daemon benutzt werden soll.

     ‘config-file’ (Vorgabe: ‘%default-syslog.conf’)
          Die zu benutzende syslog-Konfigurationsdatei.

 -- Scheme-Prozedur: syslog-service KONFIGURATION
     Liefert einen Dienst, der einen syslog-Daemon entsprechend der
     KONFIGURATION ausführt.

     Siehe *note (inetutils)syslogd invocation:: für weitere
     Informationen über die Syntax der Konfiguration.

 -- Scheme-Variable: guix-service-type
     Dies ist der Typ für den Dienst, der den Erstellungs-Daemon
     ‘guix-daemon’ ausführt (siehe *note Aufruf des guix-daemon::). Als
     Wert muss ein ‘guix-configuration’-Verbundsobjekt verwendet werden,
     wie unten beschrieben.

 -- Datentyp: guix-configuration
     Dieser Datentyp repräsentiert die Konfiguration des
     Erstellungs-Daemons von Guix. Siehe *note Aufruf des guix-daemon::
     für weitere Informationen.

     ‘guix’ (Vorgabe: GUIX)
          Das zu verwendende Guix-Paket.

     ‘build-group’ (Vorgabe: ‘"guixbuild"’)
          Der Name der Gruppe, zu der die Erstellungs-Benutzerkonten
          gehören.

     ‘build-accounts’ (Vorgabe: ‘10’)
          Die Anzahl zu erzeugender Erstellungs-Benutzerkonten.

     ‘authorize-key?’ (Vorgabe: ‘#t’)
          Ob die unter ‘authorized-keys’ aufgelisteten
          Substitutschlüssel autorisiert werden sollen — vorgegeben ist,
          den von ‘ci.guix.gnu.org’ zu autorisieren (siehe *note
          Substitute::).

     ‘authorized-keys’ (Vorgabe: ‘%default-authorized-guix-keys’)
          Die Liste der Dateien mit autorisierten Schlüsseln, d.h. eine
          Liste von Zeichenketten als G-Ausdrücke (siehe *note Aufruf
          von guix archive::). Der vorgegebene Inhalt ist der Schlüssel
          von ‘ci.guix.gnu.org’ (siehe *note Substitute::).

     ‘use-substitutes?’ (Vorgabe: ‘#t’)
          Ob Substitute benutzt werden sollen.

     ‘substitute-urls’ (Vorgabe: ‘%default-substitute-urls’)
          Die Liste der URLs, auf denen nach Substituten gesucht wird,
          wenn nicht anders angegeben.

     ‘max-silent-time’ (Vorgabe: ‘0’)
     ‘timeout’ (Vorgabe: ‘0’)
          Die Anzahl an Sekunden, die jeweils nichts in die Ausgabe
          geschrieben werden darf bzw. die es insgesamt dauern darf, bis
          ein Erstellungsprozess abgebrochen wird. Beim Wert null wird
          nie abgebrochen.

     ‘log-compression’ (Vorgabe: ‘'bzip2’)
          Die für Erstellungsprotokolle zu benutzende
          Kompressionsmethode — entweder ‘gzip’, ‘bzip2’ oder ‘none’.

     ‘extra-options’ (Vorgabe: ‘'()’)
          Eine Liste zusätzlicher Befehlszeilenoptionen zu
          ‘guix-daemon’.

     ‘log-file’ (Vorgabe: ‘"/var/log/guix-daemon.log"’)
          Die Datei, in die die Standardausgabe und die
          Standardfehlerausgabe von ‘guix-daemon’ geschrieben werden.

     ‘http-proxy’ (Vorgabe: ‘#f’)
          Die URL des für das Herunterladen von Ableitungen mit fester
          Ausgabe und von Substituten zu verwendenden HTTP- und
          HTTPS-Proxys.

          Sie können den für den Daemon benutzten Proxy auch zur
          Laufzeit ändern, indem Sie die ‘set-http-proxy’-Aktion
          aufrufen, wodurch er neu gestartet wird.

               herd set-http-proxy guix-daemon http://localhost:8118

          Um die Proxy-Einstellungen zu löschen, führen Sie dies aus:

               herd set-http-proxy guix-daemon

     ‘tmpdir’ (Vorgabe: ‘#f’)
          Ein Verzeichnispfad, der angibt, wo ‘guix-daemon’ seine
          Erstellungen durchführt.

 -- Scheme-Prozedur: udev-service [#:udev EUDEV #:rules ‘'()’]
     Führt UDEV aus, was zur Laufzeit Gerätedateien ins Verzeichnis
     ‘/dev’ einfügt. udev-Regeln können über die RULES-Variable als eine
     Liste von Dateien übergeben werden. Die Prozeduren ‘udev-rule’ und
     ‘file->udev-rule’ aus ‘(gnu services base)’ vereinfachen die
     Erstellung einer solchen Regeldatei.

 -- Scheme-Prozedur: udev-rule [DATEINAME INHALT]
     Liefert eine udev-Regeldatei mit dem angegebenen DATEINAMEn, in der
     die vom Literal INHALT definierten Regeln stehen.

     Im folgenden Beispiel wird eine Regel für ein USB-Gerät definiert
     und in der Datei ‘90-usb-ding.rules’ gespeichert. Mit der Regel
     wird ein Skript ausgeführt, sobald ein USB-Gerät mit der
     angegebenen Produktkennung erkannt wird.

          (define %beispiel-udev-rule
            (udev-rule
              "90-usb-ding.rules"
              (string-append "ACTION==\"add\", SUBSYSTEM==\"usb\", "
                             "ATTR{product}==\"Beispiel\", "
                             "RUN+=\"/pfad/zum/skript\"")))

     Der Befehl ‘herd rules udev’ liefert, wenn er als
     Administratornutzer „root“ ausgeführt wird, Namen und Verzeichnis
     von allen aktiven udev-Regeln.

   Hier zeigen wir, wie man den vorgegebenen UDEV-SERVICE um sie
erweitern kann.

     (operating-system
      ;; …
      (services
      (modify-services %desktop-services
        (udev-service-type config =>
          (udev-configuration (inherit config)
           (rules (append (udev-configuration-rules config)
                          (list %beispiel-udev-rule))))))))

 -- Scheme-Prozedur: file->udev-rule [DATEINAME DATEI]
     Liefert eine udev-Datei mit dem angegebenen DATEINAMEn, in der alle
     in der DATEI, einem dateiartigen Objekt, definierten Regeln stehen.

     Folgendes Beispiel stellt dar, wie wir eine bestehende Regeldatei
     verwenden können.

          (use-modules (guix download)     ;für url-fetch
                       (guix packages)     ;für origin
                       …)

          (define %android-udev-rules
            (file->udev-rule
              "51-android-udev.rules"
              (let ((version "20170910"))
                (origin
                 (method url-fetch)
                 (uri (string-append "https://raw.githubusercontent.com/M0Rf30/"
                                     "android-udev-rules/" version "/51-android.rules"))
                 (sha256
                  (base32 "0lmmagpyb6xsq6zcr2w1cyx9qmjqmajkvrdbhjx32gqf1d9is003"))))))

   Zusätzlich können Guix-Paketdefinitionen unter den RULES aufgeführt
werden, um die udev-Regeln um diejenigen Definitionen zu ergänzen, die
im Unterverzeichnis ‘lib/udev/rules.d’ des jeweiligen Pakets aufgeführt
sind. Statt des bisherigen Beispiels zu FILE->UDEV-RULE hätten wir also
auch das Paket ANDROID-UDEV-RULES benutzen können, das in Guix im Modul
‘(gnu packages android)’ vorhanden ist.

   Das folgende Beispiel zeit, wie dieses Paket ANDROID-UDEV-RULES
benutzt werden kann, damit das „Android-Tool“ ‘adb’ Geräte erkennen
kann, ohne dafür Administratorrechte vorauszusetzen. Man sieht hier
auch, wie die Benutzergruppe ‘adbusers’ erstellt werden kann, die
existieren muss, damit die im Paket ANDROID-UDEV-RULES definierten
Regeln richtig funktionieren. Um so eine Benutzergruppe zu erzeugen,
müssen wir sie sowohl unter den SUPPLEMENTARY-GROUPS unserer
USER-ACCOUNT-Deklaration aufführen, als auch sie im GROUPS-Feld des
OPERATING-SYSTEM-Verbundsobjekts aufführen.

     (use-modules (gnu packages android)  ;für android-udev-rules
                  (gnu system shadow)     ;für user-group
                  …)

     (operating-system
       ;; …
       (users (cons (user-account
                     ;; …
                     (supplementary-groups
                      '("adbusers"   ;für adb
                        "wheel" "netdev" "audio" "video")))))

       (groups (cons (user-group (system? #t) (name "adbusers"))
                     %base-groups))

       ;; …

       (services
        (modify-services %desktop-services
          (udev-service-type
           config =>
           (udev-configuration (inherit config)
                               (rules (cons android-udev-rules
                                            (udev-configuration-rules config))))))))

 -- Scheme-Variable: urandom-seed-service-type
     Save some entropy in ‘%random-seed-file’ to seed ‘/dev/urandom’
     when rebooting. It also tries to seed ‘/dev/urandom’ from
     ‘/dev/hwrng’ while booting, if ‘/dev/hwrng’ exists and is readable.

 -- Scheme-Variable: %random-seed-file
     Der Name der Datei, in der einige zufällige Bytes vom
     URANDOM-SEED-SERVICE abgespeichert werden, um sie nach einem
     Neustart von dort als Startwert für ‘/dev/urandom’ auslesen zu
     können. Als Vorgabe wird ‘/var/lib/random-seed’ verwendet.

 -- Scheme-Variable: gpm-service-type
     Dieser Typ wird für den Dienst verwendet, der GPM ausführt, den
     “General-Purpose Mouse Daemon”, welcher zur Linux-Konsole
     Mausunterstützung hinzufügt. GPM ermöglicht es seinen Benutzern,
     auch in der Konsole die Maus zu benutzen und damit etwa Text
     auszuwählen, zu kopieren und einzufügen.

     Der Wert für Dienste dieses Typs muss eine ‘gpm-configuration’ sein
     (siehe unten). Dieser Dienst gehört _nicht_ zu den
     ‘%base-services’.

 -- Datentyp: gpm-configuration
     Repräsentiert die Konfiguration von GPM.

     ‘options’ (Vorgabe: ‘%default-gpm-options’)
          Befehlszeilenoptionen, die an ‘gpm’ übergeben werden. Die
          vorgegebenen Optionen weisen ‘gpm’ an, auf Maus-Ereignisse auf
          der Datei ‘/dev/input/mice’ zu lauschen. Siehe *note
          (gpm)Command Line:: für weitere Informationen.

     ‘gpm’ (Vorgabe: ‘gpm’)
          Das GPM-Paket, was benutzt werden soll.

 -- Scheme-Variable: guix-publish-service-type
     Dies ist der Diensttyp für ‘guix publish’ (siehe *note Aufruf von
     guix publish::). Sein Wert muss ein
     ‘guix-publish-configuration’-Objekt sein, wie im Folgenden
     beschrieben.

     Hierbei wird angenommen, dass ‘/etc/guix’ bereits ein mit ‘guix
     archive --generate-key’ erzeugtes Schlüsselpaar zum Signieren
     enthält (siehe *note Aufruf von guix archive::). Falls nicht, wird
     der Dienst beim Starten fehlschlagen.

 -- Datentyp: guix-publish-configuration
     Der Datentyp, der die Konfiguration des „‘guix publish’“-Dienstes
     repräsentiert.

     ‘guix’ (Vorgabe: ‘guix’)
          Das zu verwendende Guix-Paket.

     ‘port’ (Vorgabe: ‘80’)
          Der TCP-Port, auf dem auf Verbindungen gelauscht werden soll.

     ‘host’ (Vorgabe: ‘"localhost"’)
          Unter welcher Rechneradresse (welchem „Host“, also welcher
          Netzwerkschnittstelle) auf Verbindungen gelauscht wird.
          Benutzen Sie ‘"0.0.0.0"’, wenn auf allen verfügbaren
          Netzwerkschnittstellen gelauscht werden soll.

     ‘compression’ (Vorgabe: ‘'(("gzip" 3))’)
          Dies ist eine Liste von Tupeln aus Kompressionsmethode und
          -stufe, die zur Kompression von Substituten benutzt werden. Um
          zum Beispiel alle Substitute mit _beiden_, sowohl lzip auf
          Stufe 7 und gzip auf Stufe 9, zu komprimieren, schreiben Sie:

               '(("lzip" 7) ("gzip" 9))

          Auf Stufe 9 ist das Kompressionsverhältnis am besten, auf
          Kosten von hoher Prozessorauslastung, während auf Stufe 1 eine
          schnelle Kompression erreicht wird.

          Wird eine leere Liste angegeben, wird Kompression
          abgeschaltet.

     ‘nar-path’ (Vorgabe: ‘"nar"’)
          Der URL-Pfad, unter dem „Nars“ zum Herunterladen angeboten
          werden. Siehe *note ‘--nar-path’: Aufruf von guix publish. für
          Details.

     ‘cache’ (Vorgabe: ‘#f’)
          Wenn dies ‘#f’ ist, werden Archive nicht zwischengespeichert,
          sondern erst bei einer Anfrage erzeugt. Andernfalls sollte
          dies der Name eines Verzeichnisses sein — z.B.
          ‘"/var/cache/guix/publish"’ —, in das ‘guix publish’ fertige
          Archive und Metadaten zwischenspeichern soll. Siehe *note
          ‘--cache’: Aufruf von guix publish. für weitere Informationen
          über die jeweiligen Vor- und Nachteile.

     ‘workers’ (Vorgabe: ‘#f’)
          Ist dies eine ganze Zahl, gibt es die Anzahl der
          Worker-Threads an, die zum Zwischenspeichern benutzt werden;
          ist es ‘#f’, werden so viele benutzt, wie es Prozessoren gibt.
          Siehe *note ‘--workers’: Aufruf von guix publish. für mehr
          Informationen.

     ‘ttl’ (Vorgabe: ‘#f’)
          Wenn dies eine ganze Zahl ist, bezeichnet sie die
          “Time-to-live” als die Anzahl der Sekunden, die
          heruntergeladene veröffentlichte Archive zwischengespeichert
          werden dürfen. Siehe *note ‘--ttl’: Aufruf von guix publish.
          für mehr Informationen.

 -- Scheme-Prozedur: rngd-service [#:rng-tools RNG-TOOLS] [#:device
          "/dev/hwrng"] Liefert einen Dienst, der das
     ‘rngd’-Programm aus den RNG-TOOLS benutzt, um das mit DEVICE
     bezeichnete Gerät zum Entropie-Pool des Kernels hinzuzufügen.
     Dieser Dienst wird fehlschlagen, falls das mit DEVICE bezeichnete
     Gerät nicht existiert.

 -- Scheme-Prozedur: pam-limits-service [#:limits ‘'()’]

     Liefert einen Dienst, der eine Konfigurationsdatei für das
     ‘pam_limits’-Modul
     (http://linux-pam.org/Linux-PAM-html/sag-pam_limits.html)
     installiert. Diese Prozedur nimmt optional eine Liste von
     ‘pam-limits-entry’-Werten entgegen, die benutzt werden können, um
     ‘ulimit’-Limits und nice-Prioritäten für Benutzersitzungen
     festzulegen.

     Die folgenden Limit-Definitionen setzen zwei harte und weiche
     Limits für alle Anmeldesitzungen für Benutzer in der
     ‘realtime’-Gruppe.

          (pam-limits-service
           (list
            (pam-limits-entry "@realtime" 'both 'rtprio 99)
            (pam-limits-entry "@realtime" 'both 'memlock 'unlimited)))

     Der erste Eintrag erhöht die maximale Echtzeit-Priorität für
     unprivilegierte Prozesse ohne zusätzliche Berechtigungen; der
     zweite Eintrag hebt jegliche Einschränkungen des maximalen
     Adressbereichs auf, der im Speicher reserviert werden darf. Diese
     Einstellungen werden in dieser Form oft für Echtzeit-Audio-Systeme
     verwendet.


This is guix.de.info, produced by makeinfo version 6.7 from
guix.de.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 ng0
Copyright © 2016, 2017, 2018, 2019 Jan Nieuwenhuizen
Copyright © 2016 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar

   Es ist Ihnen gestattet, dieses Dokument zu vervielfältigen,
weiterzugeben und/oder zu verändern, unter den Bedingungen der GNU Free
Documentation License, entweder gemäß Version 1.3 der Lizenz oder (nach
Ihrer Option) einer späteren Version, die von der Free Software
Foundation veröffentlicht wurde, ohne unveränderliche Abschnitte, ohne
vorderen Umschlagtext und ohne hinteren Umschlagtext. Eine Kopie der
Lizenz finden Sie im Abschnitt mit dem Titel „GNU Free Documentation
License“.
INFO-DIR-SECTION Systemadministration
START-INFO-DIR-ENTRY
* Guix: (guix.de).           Installierte Software und Systemkonfigurationen
                               verwalten.
* guix package: (guix.de)guix package aufrufen.  Pakete installieren,
                                                   entfernen und
                                                   aktualisieren.
* guix gc: (guix.de)guix gc aufrufen.  Unbenutzten Plattenspeicher wieder
                                         freigeben.
* guix pull: (guix.de)guix pull aufrufen.  Die Liste verfügbarer Pakete
                                             aktualisieren.
* guix system: (guix.de)guix system aufrufen.  Die
                                                 Betriebssystemkonfiguration
                                                 verwalten.
* guix deploy: (guix.de)guix deploy aufrufen.  Betriebssystemkonfigurationen
                                                 entfernter Rechner verwalten.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Softwareentwicklung
START-INFO-DIR-ENTRY
* guix environment: (guix.de)guix environment aufrufen.  Umgebungen für
                                                           Entwickler
                                                           erstellen
* guix build: (guix.de)guix build aufrufen.  Erstellen von Paketen.
* guix pack: (guix.de)guix pack aufrufen.  Bündel aus Binärdateien
                                             erstellen.
END-INFO-DIR-ENTRY


File: guix.de.info,  Node: Top,  Next: Einführung,  Up: (dir)

GNU Guix
********

Dieses Dokument beschreibt GNU Guix, Version 1.1.0.411-5c10d, ein
Werkzeug zur funktionalen Verwaltung von Softwarepaketen, das für das
GNU-System geschrieben wurde.

   Dieses Handbuch ist auch auf Englisch (siehe *note (guix)Top::), in
Vereinfachtem Chinesisch (siehe *note (guix.zh_CN)Top::), auf
Französisch (siehe *note (guix.fr)Top::), auf Spanisch (siehe *note
(guix.es)Top::) und auf Russisch verfügbar (siehe *note (guix.ru)Top::).
Wenn Sie es in Ihre eigene Sprache übersetzen möchten, dann sind Sie
beim Translation Project
(https://translationproject.org/domain/guix-manual.html) herzlich
willkommen.

* Menu:

* Einführung::              Was ist Guix überhaupt?
* Installation::             Guix installieren.
* Systeminstallation::       Das ganze Betriebssystem installieren.
* Paketverwaltung::          Pakete installieren, aktualisieren usw.
* Entwicklung::              Von Guix unterstützte Softwareentwicklung.
* Programmierschnittstelle::  Guix in Scheme verwenden.
* Zubehör::                 Befehle zur Paketverwaltung.
* Systemkonfiguration::      Das Betriebssystem konfigurieren.
* Dokumentation::            Wie man Nutzerhandbücher von Software liest.
* Dateien zur Fehlersuche installieren::  Womit man seinen Debugger
                                            füttert.
* Sicherheitsaktualisierungen::  Sicherheits-Patches schnell einspielen.
* Bootstrapping::            GNU/Linux von Grund auf selbst erstellen.
* Portierung::               Guix auf andere Plattformen und Kernels
                               bringen.
* Mitwirken::                Ihre Hilfe ist nötig!

* Danksagungen::             Danke!
* GNU-Lizenz für freie Dokumentation::  Die Lizenz dieses Handbuchs.
* Konzeptverzeichnis::       Konzepte.
* Programmierverzeichnis::   Datentypen, Funktionen und Variable.

 — Detaillierte Liste der Knoten —



Einführung



* Auf Guix-Art Software verwalten::  Was Guix besonders macht.
* GNU-Distribution::         Die Pakete und Werkzeuge.

Installation



* Aus Binärdatei installieren::  Guix installieren, ohne Zeit zu verlieren!
* Voraussetzungen::          Zum Erstellen und Benutzen von Guix nötige
                               Software.
* Den Testkatalog laufen lassen::  Guix testen.
* Den Daemon einrichten::    Wie man die Umgebung des Erstellungs-Daemons
                               einrichtet.
* Aufruf des guix-daemon::   Den Erstellungs-Daemon laufen lassen.
* Anwendungen einrichten::   Anwendungsspezifische Einstellungen.

Den Daemon einrichten



* Einrichten der Erstellungsumgebung::  Die isolierte Umgebung zum Erstellen
                                          vorbereiten.
* Auslagern des Daemons einrichten::  Erstellungen auf entfernte Maschinen
                                        auslagern.
* SELinux-Unterstützung::   Wie man eine SELinux-Richtlinie für den Daemon
                               einrichtet.

Systeminstallation



* Einschränkungen::         Was Sie erwarten dürfen.
* Hardware-Überlegungen::   Unterstützte Hardware.
* Installation von USB-Stick oder DVD::  Das Installationsmedium
                                           vorbereiten.
* Vor der Installation::     Netzwerkanbindung, Partitionierung etc.
* Geführte grafische Installation::  Leichte grafische Installation.
* Manuelle Installation::    Manuelle Installation für Zauberer.
* Nach der Systeminstallation::  Wenn die Installation erfolgreich war.
* Guix in einer VM installieren::  Ein „Guix System“-Spielplatz.
* Ein Abbild zur Installation erstellen::  Wie ein solches entsteht.

Manuelle Installation



* Tastaturbelegung und Netzwerkanbindung und Partitionierung::  Erstes
                                                                  Einrichten.
* Fortfahren mit der Installation::  Installieren.

Paketverwaltung



* Funktionalitäten::        Wie Guix Ihr Leben schöner machen wird.
* Aufruf von guix package::  Pakete installieren, entfernen usw.
* Substitute::               Vorerstelle Binärdateien herunterladen.
* Pakete mit mehreren Ausgaben.::  Ein Quellpaket, mehrere Ausgaben.
* Aufruf von guix gc::       Den Müllsammler laufen lassen.
* Aufruf von guix pull::     Das neueste Guix samt Distribution laden.
* Kanäle::                  Die Paketsammlung anpassen.
* Aufruf von time-machine::  Alte Guix-Versionen verwenden.
* Untergeordnete::           Mit einer anderen Version von Guix
                               interagieren.
* Aufruf von guix describe::  Informationen über Ihre Guix-Version
                                anzeigen.
* Aufruf von guix archive::  Import und Export von Store-Dateien.

Substitute



* Offizieller Substitut-Server::  Eine besondere Quelle von Substituten.
* Substitut-Server autorisieren::  Wie man Substitute an- und abschaltet.
* Substitutauthentifizierung::  Wie Guix Substitute verifiziert.
* Proxy-Einstellungen::      Wie Sie Substitute über einen Proxy beziehen.
* Fehler bei der Substitution::  Was passiert, wenn die Substitution
                                   fehlschlägt.
* Vom Vertrauen gegenüber Binärdateien::  Wie können Sie diesem binären
                                              Blob trauen?

Entwicklung



* Aufruf von guix environment::  Entwicklungsumgebungen einrichten.
* Aufruf von guix pack::     Software-Bündel erstellen.

Programmierschnittstelle



* Paketmodule::              Pakete aus Sicht des Programmierers.
* Pakete definieren::        Wie Sie neue Pakete definieren.
* Erstellungssysteme::       Angeben, wie Pakete erstellt werden.
* Der Store::                Den Paket-Store verändern.
* Ableitungen::              Systemnahe Schnittstelle für Paketableitungen.
* Die Store-Monade::         Rein funktionale Schnittstelle zum Store.
* G-Ausdrücke::             Erstellungsausdrücke verarbeiten.
* Aufruf von guix repl::     Interaktiv an Guix herumbasteln.

Pakete definieren



* „package“-Referenz::   Der Datentyp für Pakete.
* „origin“-Referenz::    Datentyp für Paketursprünge.

Zubehör



* Aufruf von guix build::    Pakete aus der Befehlszeile heraus erstellen.
* Aufruf von guix edit::     Paketdefinitionen bearbeiten.
* Aufruf von guix download::  Herunterladen einer Datei und Ausgabe ihres
                                Hashes.
* Aufruf von guix hash::     Den kryptografischen Hash einer Datei
                               berechnen.
* Aufruf von guix import::   Paketdefinitionen importieren.
* Aufruf von guix refresh::  Paketdefinitionen aktualisieren.
* Aufruf von guix lint::     Fehler in Paketdefinitionen finden.
* Aufruf von guix size::     Plattenplatzverbrauch profilieren.
* Aufruf von guix graph::    Den Paketgraphen visualisieren.
* Aufruf von guix publish::  Substitute teilen.
* Aufruf von guix challenge::  Die Substitut-Server anfechten.
* Aufruf von guix copy::     Mit einem entfernten Store Dateien austauschen.
* Aufruf von guix container::  Prozesse isolieren.
* Aufruf von guix weather::  Die Verfügbarkeit von Substituten
                               einschätzen.
* Aufruf von guix processes::  Auflisten der Client-Prozesse

Aufruf von ‘guix build’



* Gemeinsame Erstellungsoptionen::  Erstellungsoptionen für die meisten
                                      Befehle.
* Paketumwandlungsoptionen::  Varianten von Paketen erzeugen.
* Zusätzliche Erstellungsoptionen::  Optionen spezifisch für „guix
                                        build“.
* Fehlschläge beim Erstellen untersuchen::  Praxiserfahrung bei der
                                               Paketerstellung.

Systemkonfiguration



* Das Konfigurationssystem nutzen::  Ihr GNU-System anpassen.
* „operating-system“-Referenz::  Details der
                                       Betriebssystem-Deklarationen.
* Dateisysteme::             Die Dateisystemeinbindungen konfigurieren.
* Zugeordnete Geräte::      Näheres zu blockorientierten Speichermedien.
* Benutzerkonten::           Benutzerkonten festlegen.
* Tastaturbelegung::         Wie das System Tastendrücke interpretiert.
* Locales::                  Sprache und kulturelle Konventionen.
* Dienste::                  Systemdienste festlegen.
* Setuid-Programme::         Mit Administratorrechten startende Programme.
* X.509-Zertifikate::        HTTPS-Server authentifizieren.
* Name Service Switch::      Den Name Service Switch von libc konfigurieren.
* Initiale RAM-Disk::        Linux-libre hochfahren.
* Bootloader-Konfiguration::  Den Bootloader konfigurieren.
* Aufruf von guix system::   Instanziierung einer Systemkonfiguration.
* Aufruf von guix deploy::   Eine Systemkonfiguration auf einen entfernten
                               Rechner aufspielen.
* Guix in einer VM starten::  Wie man „Guix System“ in einer virtuellen
                                Maschine startet.
* Dienste definieren::       Neue Dienstdefinitionen hinzufügen.

Dienste



* Basisdienste::             Essenzielle Systemdienste.
* Geplante Auftragsausführung::  Der mcron-Dienst.
* Log-Rotation::             Der rottlog-Dienst.
* Netzwerkdienste::          Netzwerkeinrichtung, SSH-Daemon etc.
* X Window::                 Grafische Anzeige.
* Druckdienste::             Unterstützung für lokale und entfernte
                               Drucker.
* Desktop-Dienste::          D-Bus- und Desktop-Dienste.
* Tondienste::               Dienste für ALSA und Pulseaudio.
* Datenbankdienste::         SQL-Datenbanken, Schlüssel-Wert-Speicher etc.
* Mail-Dienste::             IMAP, POP3, SMTP und so weiter.
* Kurznachrichtendienste::   Dienste für Kurznachrichten.
* Telefondienste::           Telefoniedienste.
* Systemüberwachungsdienste::  Dienste zur Systemüberwachung.
* Kerberos-Dienste::         Kerberos-Dienste.
* Web-Dienste::              Web-Server.
* Zertifikatsdienste::       TLS-Zertifikate via Let’s Encrypt.
* DNS-Dienste::              DNS-Daemons.
* VPN-Dienste::              VPN-Daemons.
* Network File System::      Dienste mit Bezug zum Netzwerkdateisystem.
* Kontinuierliche Integration::  Der Cuirass-Dienst.
* Dienste zur Stromverbrauchsverwaltung::  Den Akku schonen.
* Audio-Dienste::            Der MPD.
* Virtualisierungsdienste::  Dienste für virtuelle Maschinen.
* Versionskontrolldienste::  Entfernten Zugang zu Git-Repositorys bieten.
* Spieldienste::             Spielserver.
* PAM-Einbindedienst::       Dienst, um Datenträger beim Anmelden
                               einzubinden.
* Linux-Dienste::            Dienste nur für Systeme mit Linux-Kernel.
* Verschiedene Dienste::     Andere Dienste.

Dienste definieren



* Dienstkompositionen::      Wie Dienste zusammengestellt werden.
* Diensttypen und Dienste::  Typen und Dienste.
* Service-Referenz::         Referenz zur Programmierschnittstelle.
* Shepherd-Dienste::         Eine spezielle Art von Dienst.



File: guix.de.info,  Node: Einführung,  Next: Installation,  Prev: Top,  Up: Top

1 Einführung
************

GNU Guix(1) ist ein Werkzeug zur Verwaltung von Softwarepaketen für das
GNU-System und eine Distribution (eine „Verteilung“) desselbigen
GNU-Systems. Guix macht es _nicht_ mit besonderen Berechtigungen
ausgestatteten, „unprivilegierten“ Nutzern leicht, Softwarepakete zu
installieren, zu aktualisieren oder zu entfernen, zu einem vorherigen
Satz von Paketen zurückzuwechseln, Pakete aus ihrem Quellcode heraus zu
erstellen und hilft allgemein bei der Erzeugung und Wartung von
Software-Umgebungen.

   Sie können GNU Guix auf ein bestehendes GNU/Linux-System aufsetzen,
wo es die bereits verfügbaren Werkzeuge ergänzt, ohne zu stören (siehe
*note Installation::), oder Sie können es als eine eigenständige
Betriebssystem-Distribution namens “Guix System” verwenden(2). Siehe
*note GNU-Distribution::.

* Menu:

* Auf Guix-Art Software verwalten::  Was Guix besonders macht.
* GNU-Distribution::         Die Pakete und Werkzeuge.

   ---------- Footnotes ----------

   (1) „Guix“ wird wie „geeks“ ausgesprochen, also als „ɡiːks“ in der
Notation des Internationalen Phonetischen Alphabets (IPA).

   (2) Der Name “Guix System” wird auf englische Weise ausgesprochen.
Früher hatten wir „Guix System“ als „Guix System Distribution“
bezeichnet und mit „GuixSD“ abgekürzt. Wir denken mittlerweile aber,
dass es sinnvoller ist, alles unter der Fahne von Guix zu gruppieren,
weil schließlich „Guix System“ auch über den Befehl ‘guix system’
verfügbar ist, selbst wenn Sie Guix auf einer fremden Distribution
benutzen!


File: guix.de.info,  Node: Auf Guix-Art Software verwalten,  Next: GNU-Distribution,  Up: Einführung

1.1 Auf Guix-Art Software verwalten
===================================

Guix bietet eine befehlszeilenbasierte Paketverwaltungsschnittstelle
(siehe *note Aufruf von guix package::), Werkzeuge als Hilfestellung bei
der Software-Entwicklung (siehe *note Entwicklung::),
Befehlszeilenwerkzeuge für fortgeschrittenere Nutzung (siehe *note
Zubehör::) sowie Schnittstellen zur Programmierung in Scheme (siehe
*note Programmierschnittstelle::). Der “Erstellungs-Daemon” ist für das
Erstellen von Paketen im Auftrag von Nutzern verantwortlich (siehe *note
Den Daemon einrichten::) und für das Herunterladen vorerstellter
Binärdateien aus autorisierten Quellen (siehe *note Substitute::).

   Guix enthält Paketdefinitionen für viele Pakete, manche aus GNU und
andere nicht aus GNU, die alle die Freiheit des Computernutzers
respektieren (https://www.gnu.org/philosophy/free-sw.html). Es ist
_erweiterbar_: Nutzer können ihre eigenen Paketdefinitionen schreiben
(siehe *note Pakete definieren::) und sie als unabhängige Paketmodule
verfügbar machen (siehe *note Paketmodule::). Es ist auch _anpassbar_:
Nutzer können spezialisierte Paketdefinitionen aus bestehenden
_ableiten_, auch von der Befehlszeile (siehe *note
Paketumwandlungsoptionen::).

   Intern implementiert Guix die Disziplin der “funktionalen
Paketverwaltung”, zu der Nix schon die Pionierarbeit geleistet hat
(siehe *note Danksagungen::). In Guix wird der Prozess, ein Paket zu
erstellen und zu installieren, als eine _Funktion_ im mathematischen
Sinn aufgefasst. Diese Funktion hat Eingaben, wie zum Beispiel
Erstellungs-Skripts, einen Compiler und Bibliotheken, und liefert ein
installiertes Paket. Als eine reine Funktion hängt sein Ergebnis allein
von seinen Eingaben ab — zum Beispiel kann er nicht auf Software oder
Skripts Bezug nehmen, die nicht ausdrücklich als Eingaben übergeben
wurden. Eine Erstellungsfunktion führt immer zum selben Ergebnis, wenn
ihr die gleiche Menge an Eingaben übergeben wurde. Sie kann die Umgebung
des laufenden Systems auf keine Weise beeinflussen, zum Beispiel kann
sie keine Dateien außerhalb ihrer Erstellungs- und
Installationsverzeichnisse verändern. Um dies zu erreichen, laufen
Erstellungsprozesse in isolieren Umgebungen (sogenannte “Container”), wo
nur ausdrückliche Eingaben sichtbar sind.

   Das Ergebnis von Paketerstellungsfunktionen wird im Dateisystem
“zwischengespeichert” in einem besonderen Verzeichnis, was als “der
Store” bezeichnet wird (siehe *note Der Store::). Jedes Paket wird in
sein eigenes Verzeichnis im Store installiert — standardmäßig ist er
unter ‘/gnu/store’ zu finden. Der Verzeichnisname enthält einen Hash
aller Eingaben, anhand derer das Paket erzeugt wurde, somit hat das
Ändern einer Eingabe einen völlig anderen Verzeichnisnamen zur Folge.

   Dieses Vorgehen ist die Grundlage für die Guix auszeichnenden
Funktionalitäten: Unterstützung transaktionsbasierter
Paketaktualisierungen und -rücksetzungen, Installation von Paketen für
jeden Nutzer sowie Garbage Collection für Pakete (siehe *note
Funktionalitäten::).


File: guix.de.info,  Node: GNU-Distribution,  Prev: Auf Guix-Art Software verwalten,  Up: Einführung

1.2 GNU-Distribution
====================

Mit Guix kommt eine Distribution des GNU-Systems, die nur aus freier
Software(1) besteht. Die Distribution kann für sich allein installiert
werden (siehe *note Systeminstallation::), aber Guix kann auch auf einem
bestehenden GNU/Linux-System installiert werden. Wenn wir die
Anwendungsfälle unterscheiden möchten, bezeichnen wir die alleinstehende
Distribution als „Guix System“ (mit englischer Aussprache).

   Die Distribution stellt den Kern der GNU-Pakete, also insbesondere
GNU libc, GCC und Binutils, sowie zahlreiche zum GNU-Projekt gehörende
und nicht dazu gehörende Anwendungen zur Verfügung. Die vollständige
Liste verfügbarer Pakete können Sie online
(https://www.gnu.org/software/guix/packages) einsehen, oder indem Sie
‘guix package’ ausführen (siehe *note Aufruf von guix package::):

     guix package --list-available

   Unser Ziel ist, eine zu 100% freie Software-Distribution von
Linux-basierten und von anderen GNU-Varianten anzubieten, mit dem Fokus
darauf, das GNU-Projekt und die enge Zusammenarbeit seiner Bestandteile
zu befördern, sowie die Programme und Werkzeuge hervorzuheben, die die
Nutzer dabei unterstützen, von dieser Freiheit Gebrauch zu machen.

   Pakete sind zur Zeit auf folgenden Plattformen verfügbar:

‘x86_64-linux’
     Intel/AMD-‘x86_64’-Architektur, Linux-Libre als Kernel,

‘i686-linux’
     Intel-32-Bit-Architektur (IA-32), Linux-Libre als Kernel,

‘armhf-linux’
     ARMv7-A-Architektur mit „hard float“, Thumb-2 und NEON, für die
     EABI „hard-float application binary interface“, mit Linux-Libre als
     Kernel,

‘aarch64-linux’
     64-Bit-ARMv8-A-Prozessoren, little-endian, mit Linux-Libre als
     Kernel,

‘mips64el-linux’
     64-Bit-MIPS-Prozessoren, little-endian, speziell die
     Loongson-Reihe, n32-ABI, mit Linux-Libre als Kernel. Diese
     Konfiguration wird nicht länger in vollem Umfang unterstützt;
     insbesondere werden von der Erstellungsfarm des Guix-Projekts keine
     Substitute mehr für diese Architektur angeboten.

   Mit Guix System _deklarieren_ Sie alle Aspekte der
Betriebssystemkonfiguration und Guix kümmert sich darum, die
Konfiguration auf transaktionsbasierte, reproduzierbare und zustandslose
Weise zu instanziieren (siehe *note Systemkonfiguration::). Guix System
benutzt den Kernel Linux-libre, das Shepherd-Initialisierungssystem
(siehe *note (shepherd)Einführung::), die wohlbekannten GNU-Werkzeuge
mit der zugehörigen Werkzeugkette sowie die grafische Umgebung und
Systemdienste Ihrer Wahl.

   Guix System ist auf allen oben genannten Plattformen außer
‘mips64el-linux’ verfügbar.

Informationen, wie auf andere Architekturen oder Kernels portiert werden
kann, finden Sie im Abschnitt *note Portierung::.

   Diese Distribution aufzubauen basiert auf Kooperation, und Sie sind
herzlich eingeladen, dabei mitzumachen! Im Abschnitt *note Mitwirken::
stehen weitere Informationen, wie Sie uns helfen können.

   ---------- Footnotes ----------

   (1) Die Bezeichnung „frei“ steht hier für die Freiheiten, die Nutzern
der Software geboten werden
(https://www.gnu.org/philosophy/free-sw.html).


File: guix.de.info,  Node: Installation,  Next: Systeminstallation,  Prev: Einführung,  Up: Top

2 Installation
**************

     Anmerkung: Wir empfehlen, dieses Shell-basierte Installationsskript
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh)
     zu benutzen, um Guix auf ein bestehendes GNU/Linux-System zu
     installieren — im Folgenden als “Fremddistribution” bezeichnet.(1)
     Das Skript automatisiert das Herunterladen, das Installieren und
     die anfängliche Konfiguration von Guix. Es sollte als der
     Administratornutzer „root“ ausgeführt werden.

   Wenn es auf einer Fremddistribution installiert wird, ergänzt
GNU Guix die verfügbaren Werkzeuge, ohne dass sie sich gegenseitig
stören. Guix’ Daten befinden sich ausschließlich in zwei Verzeichnissen,
üblicherweise ‘/gnu/store’ und ‘/var/guix’; andere Dateien auf Ihrem
System wie ‘/etc’ bleiben unberührt.

   Sobald es installiert ist, kann Guix durch Ausführen von ‘guix pull’
aktualisiert werden (siehe *note Aufruf von guix pull::).

   Sollten Sie es vorziehen, die Installationsschritte manuell
durchzuführen, oder falls Sie Anpassungen daran vornehmen möchten,
könnten sich die folgenden Unterabschnitte als nützlich erweisen. Diese
beschreiben die Software-Voraussetzungen von Guix und wie man es manuell
installiert, so dass man es benutzen kann.

* Menu:

* Aus Binärdatei installieren::  Guix installieren, ohne Zeit zu verlieren!
* Voraussetzungen::          Zum Erstellen und Benutzen von Guix nötige
                               Software.
* Den Testkatalog laufen lassen::  Guix testen.
* Den Daemon einrichten::    Wie man die Umgebung des Erstellungs-Daemons
                               einrichtet.
* Aufruf des guix-daemon::   Den Erstellungs-Daemon laufen lassen.
* Anwendungen einrichten::   Anwendungsspezifische Einstellungen.
* Aktualisieren von Guix::   Guix und seinen Erstellungs-Daemon
                               aktualisieren.

   ---------- Footnotes ----------

   (1) Dieser Abschnitt bezieht sich auf die Installation des
Paketverwaltungswerkzeugs, das auf ein bestehendes GNU/Linux-System
aufsetzend installiert werden kann. Wenn Sie stattdessen das
vollständige GNU-Betriebssystem installieren möchten, lesen Sie *note
Systeminstallation::.


File: guix.de.info,  Node: Aus Binärdatei installieren,  Next: Voraussetzungen,  Up: Installation

2.1 Aus Binärdatei installieren
===============================

Dieser Abschnitt beschreibt, wie sich Guix auf einem beliebigen System
aus einem alle Komponenten umfassenden Tarball installieren lässt, der
Binärdateien für Guix und all seine Abhängigkeiten liefert. Dies geht in
der Regel schneller, als Guix aus seinen Quelldateien zu installieren,
was in den nächsten Abschnitten beschrieben wird. Vorausgesetzt wird
hier lediglich, dass GNU tar und Xz verfügbar sind.

     Anmerkung: We recommend the use of this shell installer script
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh).
     The script automates the download, installation, and initial
     configuration steps described below. It should be run as the root
     user. As root, you can thus run this:

          cd /tmp
          wget https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh
          chmod +x guix-install.sh
          ./guix-install.sh

   Die Installation läuft so ab:

  1. Laden Sie den binären Tarball von
     ‘https://ftp.gnu.org/gnu/guix/guix-binary-1.1.0.411-5c10d.SYSTEM.tar.xz’
     herunter, wobei SYSTEM für ‘x86_64-linux’ steht, falls Sie es auf
     einer Maschine mit ‘x86_64’-Architektur einrichten, auf der bereits
     der Linux-Kernel läuft, oder entsprechend für andere Maschinen.

     Achten Sie darauf, auch die zugehörige ‘.sig’-Datei herunterzuladen
     und verifizieren Sie damit die Authentizität des Tarballs, ungefähr
     so:

          $ wget https://ftp.gnu.org/gnu/guix/guix-binary-1.1.0.411-5c10d.SYSTEM.tar.xz.sig
          $ gpg --verify guix-binary-1.1.0.411-5c10d.SYSTEM.tar.xz.sig

     Falls dieser Befehl fehlschlägt, weil Sie nicht über den nötigen
     öffentlichen Schlüssel verfügen, können Sie ihn mit diesem Befehl
     importieren:

          $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
                -qO - | gpg --import -

     und den Befehl ‘gpg --verify’ erneut ausführen.

     Beachten Sie, dass eine Warnung wie „Dieser Schlüssel trägt keine
     vertrauenswürdige Signatur!“ normal ist.

  2. Nun müssen Sie zum Administratornutzer ‘root’ wechseln. Abhängig
     von Ihrer Distribution müssen Sie dazu etwa ‘su -’ oder ‘sudo -i’
     ausführen. Danach führen Sie als ‘root’-Nutzer aus:

          # cd /tmp
          # tar --warning=no-timestamp -xf \
               /pfad/zur/guix-binary-1.1.0.411-5c10d.SYSTEM.tar.xz
          # mv var/guix /var/ && mv gnu /

     Dadurch wird ‘/gnu/store’ (siehe *note Der Store::) und ‘/var/guix’
     erzeugt. Letzteres enthält ein fertiges Guix-Profil für den
     Administratornutzer ‘root’ (wie im nächsten Schritt beschrieben).

     Entpacken Sie den Tarball _nicht_ auf einem schon funktionierenden
     Guix-System, denn es würde seine eigenen essenziellen Dateien
     überschreiben.

     Die Befehlszeilenoption ‘--warning=no-timestamp’ stellt sicher,
     dass GNU tar nicht vor „unplausibel alten Zeitstempeln“ warnt
     (solche Warnungen traten bei GNU tar 1.26 und älter auf, neue
     Versionen machen keine Probleme). Sie treten auf, weil alle Dateien
     im Archiv als Änderungszeitpunkt null eingetragen bekommen haben
     (das bezeichnet den 1. Januar 1970). Das ist Absicht, damit der
     Inhalt des Archivs nicht davon abhängt, wann es erstellt wurde, und
     es somit reproduzierbar wird.

  3. Machen Sie das Profil als ‘~root/.config/guix/current’ verfügbar,
     wo ‘guix pull’ es aktualisieren kann (siehe *note Aufruf von guix
     pull::):

          # mkdir -p ~root/.config/guix
          # ln -sf /var/guix/profiles/per-user/root/current-guix \
                   ~root/.config/guix/current

     „Sourcen“ Sie ‘etc/profile’, um ‘PATH’ und andere relevante
     Umgebungsvariable zu ergänzen:

          # GUIX_PROFILE="`echo ~root`/.config/guix/current" ; \
            source $GUIX_PROFILE/etc/profile

  4. Erzeugen Sie Nutzergruppe und Nutzerkonten für die
     Erstellungs-Benutzer wie folgt (siehe *note Einrichten der
     Erstellungsumgebung::).

  5. Führen Sie den Daemon aus, und lassen Sie ihn automatisch bei jedem
     Hochfahren starten.

     Wenn Ihre Wirts-Distribution systemd als „init“-System verwendet,
     können Sie das mit folgenden Befehlen veranlassen:

          # cp ~root/.config/guix/current/lib/systemd/system/guix-daemon.service \
               /etc/systemd/system/
          # systemctl enable --now guix-daemon

     Wenn Ihre Wirts-Distribution als „init“-System Upstart verwendet:

          # initctl reload-configuration
          # cp ~root/.config/guix/current/lib/upstart/system/guix-daemon.conf \
               /etc/init/
          # start guix-daemon

     Andernfalls können Sie den Daemon immer noch manuell starten, mit:

          # ~root/.config/guix/current/bin/guix-daemon \
                 --build-users-group=guixbuild

  6. Stellen Sie den ‘guix’-Befehl auch anderen Nutzern Ihrer Maschine
     zur Verfügung, zum Beispiel so:

          # mkdir -p /usr/local/bin
          # cd /usr/local/bin
          # ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix

     Es ist auch eine gute Idee, die Info-Version dieses Handbuchs
     ebenso verfügbar zu machen:

          # mkdir -p /usr/local/share/info
          # cd /usr/local/share/info
          # for i in /var/guix/profiles/per-user/root/current-guix/share/info/* ;
            do ln -s $i ; done

     Auf diese Art wird, unter der Annahme, dass bei Ihnen
     ‘/usr/local/share/info’ im Suchpfad eingetragen ist, das Ausführen
     von ‘info guix.de’ dieses Handbuch öffnen (siehe *note
     (texinfo)Other Info Directories:: hat weitere Details, wie Sie den
     Info-Suchpfad ändern können).

  7. Um Substitute von ‘ci.guix.gnu.org’ oder einem Spiegelserver davon
     zu benutzen (siehe *note Substitute::), müssen sie erst autorisiert
     werden:

          # guix archive --authorize < \
               ~root/.config/guix/current/share/guix/ci.guix.gnu.org.pub

  8. Alle Nutzer müssen womöglich ein paar zusätzliche Schritte
     ausführen, damit ihre Guix-Umgebung genutzt werden kann, siehe
     *note Anwendungen einrichten::.

   Voilà, die Installation ist fertig!

   Sie können nachprüfen, dass Guix funktioniert, indem Sie ein
Beispielpaket in das root-Profil installieren:

     # guix install hello

   Der Tarball zur Installation aus einer Binärdatei kann einfach durch
Ausführung des folgenden Befehls im Guix-Quellbaum (re-)produziert und
verifiziert werden:

     make guix-binary.SYSTEM.tar.xz

… was wiederum dies ausführt:

     guix pack -s SYSTEM --localstatedir \
       --profile-name=current-guix guix

   Siehe *note Aufruf von guix pack:: für weitere Informationen zu
diesem praktischen Werkzeug.


File: guix.de.info,  Node: Voraussetzungen,  Next: Den Testkatalog laufen lassen,  Prev: Aus Binärdatei installieren,  Up: Installation

2.2 Voraussetzungen
===================

Dieser Abschnitt listet Voraussetzungen auf, um Guix aus seinem
Quellcode zu erstellen. Der Erstellungsprozess für Guix ist derselbe wie
für andere GNU-Software und wird hier nicht beschrieben. Bitte lesen Sie
die Dateien ‘README’ und ‘INSTALL’ im Guix-Quellbaum, um weitere Details
zu erfahren.

   GNU Guix kann von seinem Webauftritt unter
<http://www.gnu.org/software/guix/> heruntergeladen werden.

   GNU Guix hat folgende Pakete als Abhängigkeiten:

   • GNU Guile (https://gnu.org/software/guile/), Version 3.0.x oder
     2.2.x,
   • Guile-Gcrypt (https://notabug.org/cwebber/guile-gcrypt), Version
     0.1.0 oder neuer,
   • GnuTLS (https://gnutls.org/), im Speziellen dessen Anbindungen für
     Guile (siehe *note how to install the GnuTLS bindings for Guile:
     (gnutls-guile)Guile Preparations.),
   • Guile-SQLite3 (https://notabug.org/guile-sqlite3/guile-sqlite3),
     Version 0.1.0 oder neuer,
   • Guile-Git (https://gitlab.com/guile-git/guile-git), vom August 2017
     oder neuer,
   • Guile-JSON (https://savannah.nongnu.org/projects/guile-json/) 3.x,
   • zlib (https://zlib.net),
   • GNU Make (https://www.gnu.org/software/make/).

   Folgende Abhängigkeiten sind optional:

   • Unterstützung für das Auslagern von Erstellungen (siehe *note
     Auslagern des Daemons einrichten::) und ‘guix copy’ (siehe *note
     Aufruf von guix copy::) hängt von Guile-SSH
     (https://github.com/artyom-poptsov/guile-ssh), Version 0.12.0 oder
     neuer, ab.

   • Wenn lzlib (https://www.nongnu.org/lzip/lzlib.html) verfügbar ist,
     können lzlib-Substitute benutzt werden und ‘guix publish’ kann
     Substitute mit lzlib komprimieren.

   • Wenn libbz2 (http://www.bzip.org) verfügbar ist, kann ‘guix-daemon’
     damit Erstellungsprotokolle komprimieren.

   Sofern nicht ‘--disable-daemon’ beim Aufruf von ‘configure’ übergeben
wurde, benötigen Sie auch folgende Pakete:

   • GNU libgcrypt (https://gnupg.org/),
   • SQLite 3 (https://sqlite.org),
   • GCC’s g++ (https://gcc.gnu.org) mit Unterstützung für den
     C++11-Standard.

   Sollten Sie Guix auf einem System konfigurieren, auf dem Guix bereits
installiert ist, dann stellen Sie sicher, dasselbe Zustandsverzeichnis
wie für die bestehende Installation zu verwenden. Benutzen Sie dazu die
Befehlszeilenoption ‘--localstatedir’ des ‘configure’-Skripts (siehe
*note ‘localstatedir’: (standards)Directory Variables.). Die
LOCALSTATEDIR-Option wird normalerweise auf den Wert ‘/var’ festgelegt.
Das ‘configure’-Skript schützt vor ungewollter Fehlkonfiguration der
LOCALSTATEDIR, damit Sie nicht versehentlich Ihren Store verfälschen
(siehe *note Der Store::).


File: guix.de.info,  Node: Den Testkatalog laufen lassen,  Next: Den Daemon einrichten,  Prev: Voraussetzungen,  Up: Installation

2.3 Den Testkatalog laufen lassen
=================================

Nachdem ‘configure’ und ‘make’ erfolgreich durchgelaufen sind, ist es
ratsam, den Testkatalog auszuführen. Er kann dabei helfen, Probleme mit
der Einrichtung oder Systemumgebung zu finden, oder auch Probleme in
Guix selbst — und Testfehler zu melden ist eine wirklich gute Art und
Weise, bei der Verbesserung von Guix mitzuhelfen. Um den Testkatalog
auszuführen, geben Sie Folgendes ein:

     make check

   Testfälle können parallel ausgeführt werden. Sie können die
Befehlszeiltenoption ‘-j’ von GNU make benutzen, damit es schneller
geht. Der erste Durchlauf kann auf neuen Maschinen ein paar Minuten
dauern, nachfolgende Ausführungen werden schneller sein, weil der für
die Tests erstellte Store schon einige Dinge zwischengespeichert haben
wird.

   Es ist auch möglich, eine Teilmenge der Tests laufen zu lassen, indem
Sie die ‘TESTS’-Variable des Makefiles ähnlich wie in diesem Beispiel
definieren:

     make check TESTS="tests/store.scm tests/cpio.scm"

   Standardmäßig werden Testergebnisse pro Datei angezeigt. Um die
Details jedes einzelnen Testfalls zu sehen, können Sie wie in diesem
Beispiel die ‘SCM_LOG_DRIVER_FLAGS’-Variable des Makefiles definieren:

     make check TESTS="tests/base64.scm" SCM_LOG_DRIVER_FLAGS="--brief=no"

   Kommt es zum Fehlschlag, senden Sie bitte eine E-Mail an
<bug-guix@gnu.org> und fügen Sie die Datei ‘test-suite.log’ als Anhang
bei. Bitte geben Sie dabei in Ihrer Nachricht die benutzte Version von
Guix an sowie die Versionsnummern der Abhängigkeiten (siehe *note
Voraussetzungen::).

   Guix wird auch mit einem Testkatalog für das ganze System
ausgeliefert, der vollständige Instanzen des „Guix
System“-Betriebssystems testet. Er kann nur auf Systemen benutzt werden,
auf denen Guix bereits installiert ist, mit folgendem Befehl:

     make check-system

Oder, auch hier, indem Sie ‘TESTS’ definieren, um eine Teilmenge der
auszuführenden Tests anzugeben:

     make check-system TESTS="basic mcron"

   Diese Systemtests sind in den ‘(gnu tests …)’-Modulen definiert. Sie
funktionieren, indem Sie das getestete Betriebssystem mitsamt schlichter
Instrumentierung in einer virtuellen Maschine (VM) ausführen. Die Tests
können aufwendige Berechnungen durchführen oder sie günstig umgehen, je
nachdem, ob für ihre Abhängigkeiten Substitute zur Verfügung stehen
(siehe *note Substitute::). Manche von ihnen nehmen viel Speicherplatz
in Anspruch, um die VM-Abbilder zu speichern.

   Auch hier gilt: Falls Testfehler auftreten, senden Sie bitte alle
Details an <bug-guix@gnu.org>.


File: guix.de.info,  Node: Den Daemon einrichten,  Next: Aufruf des guix-daemon,  Prev: Den Testkatalog laufen lassen,  Up: Installation

2.4 Den Daemon einrichten
=========================

Operationen wie das Erstellen eines Pakets oder Laufenlassen des
Müllsammlers werden alle durch einen spezialisierten Prozess
durchgeführt, den “Erstellungs-Daemon”, im Auftrag seiner Kunden (den
Clients). Nur der Daemon darf auf den Store und seine zugehörige
Datenbank zugreifen. Daher wird jede den Store verändernde Operation
durch den Daemon durchgeführt. Zum Beispiel kommunizieren
Befehlszeilenwerkzeuge wie ‘guix package’ und ‘guix build’ mit dem
Daemon (mittels entfernter Prozeduraufrufe), um ihm Anweisungen zu
geben, was er tun soll.

   Folgende Abschnitte beschreiben, wie Sie die Umgebung des
Erstellungs-Daemons ausstatten sollten. Siehe auch *note Substitute::
für Informationen darüber, wie Sie es dem Daemon ermöglichen,
vorerstellte Binärdateien herunterzuladen.

* Menu:

* Einrichten der Erstellungsumgebung::  Die isolierte Umgebung zum Erstellen
                                          vorbereiten.
* Auslagern des Daemons einrichten::  Erstellungen auf entfernte Maschinen
                                        auslagern.
* SELinux-Unterstützung::   Wie man eine SELinux-Richtlinie für den Daemon
                               einrichtet.


File: guix.de.info,  Node: Einrichten der Erstellungsumgebung,  Next: Auslagern des Daemons einrichten,  Up: Den Daemon einrichten

2.4.1 Einrichten der Erstellungsumgebung
----------------------------------------

In einem normalen Mehrbenutzersystem werden Guix und sein Daemon — das
Programm ‘guix-daemon’ — vom Systemadministrator installiert;
‘/gnu/store’ gehört ‘root’ und ‘guix-daemon’ läuft als ‘root’. Nicht mit
erweiterten Rechten ausgestattete Nutzer können Guix-Werkzeuge benutzen,
um Pakete zu erstellen oder anderweitig auf den Store zuzugreifen, und
der Daemon wird dies für sie erledigen und dabei sicherstellen, dass der
Store in einem konsistenten Zustand verbleibt und sich die Nutzer
erstellte Pakete teilen.

   Wenn ‘guix-daemon’ als Administratornutzer ‘root’ läuft, wollen Sie
aber vielleicht dennoch nicht, dass Paketerstellungsprozesse auch als
‘root’ ablaufen, aus offensichtlichen Sicherheitsgründen. Um dies zu
vermeiden, sollte ein besonderer Pool aus “Erstellungsbenutzern”
geschaffen werden, damit vom Daemon gestartete Erstellungsprozesse ihn
benutzen. Diese Erstellungsbenutzer müssen weder eine Shell noch ein
Persönliches Verzeichnis zugewiesen bekommen, sie werden lediglich
benutzt, wenn der Daemon ‘root’-Rechte in Erstellungsprozessen ablegt.
Mehrere solche Benutzer zu haben, ermöglicht es dem Daemon, verschiedene
Erstellungsprozessen unter verschiedenen Benutzeridentifikatoren (UIDs)
zu starten, was garantiert, dass sie einander nicht stören — eine
essenzielle Funktionalität, da Erstellungen als reine Funktionen
angesehen werden (siehe *note Einführung::).

   Auf einem GNU/Linux-System kann ein Pool von Erstellungsbenutzern wie
folgt erzeugt werden (mit Bash-Syntax und den Befehlen von ‘shadow’):

     # groupadd --system guixbuild
     # for i in `seq -w 1 10`;
       do
         useradd -g guixbuild -G guixbuild                  \
                 -d /var/empty -s `which nologin`           \
                 -c "Guix-Erstellungsbenutzer $i" --system  \
                 guixbuilder$i;
       done

Die Anzahl der Erstellungsbenutzer entscheidet, wieviele
Erstellungsaufträge parallel ausgeführt werden können, wie es mit der
Befehlszeilenoption ‘--max-jobs’ vorgegeben werden kann (siehe *note
‘--max-jobs’: Aufruf des guix-daemon.). Um ‘guix system vm’ und ähnliche
Befehle nutzen zu können, müssen Sie die Erstellungsbenutzer unter
Umständen zur ‘kvm’-Benutzergruppe hinzufügen, damit sie Zugriff auf
‘/dev/kvm’ haben, mit ‘-G guixbuild,kvm’ statt ‘-G guixbuild’ (siehe
*note Aufruf von guix system::).

   Das Programm ‘guix-daemon’ kann mit dem folgenden Befehl als ‘root’
gestartet werden(1):

     # guix-daemon --build-users-group=guixbuild

Auf diese Weise startet der Daemon Erstellungsprozesse in einem chroot
als einer der ‘guixbuilder’-Benutzer. Auf GNU/Linux enthält die
chroot-Umgebung standardmäßig nichts außer:

   • einem minimalen ‘/dev’-Verzeichnis, was größtenteils vom ‘/dev’ des
     Wirtssystems unabhängig erstellt wurde(2),

   • dem ‘/proc’-Verzeichnis, es zeigt nur die Prozesse des Containers,
     weil ein separater Namensraum für Prozess-IDs (PIDs) benutzt wird,

   • ‘/etc/passwd’ mit einem Eintrag für den aktuellen Benutzer und
     einem Eintrag für den Benutzer ‘nobody’,

   • ‘/etc/group’ mit einem Eintrag für die Gruppe des Benutzers,

   • ‘/etc/hosts’ mit einem Eintrag, der ‘localhost’ auf ‘127.0.0.1’
     abbildet,

   • einem ‘/tmp’-Verzeichnis mit Schreibrechten.

   Sie können beeinflussen, in welchem Verzeichnis der Daemon
Verzeichnisbäume zur Erstellung unterbringt, indem sie den Wert der
Umgebungsvariablen ‘TMPDIR’ ändern. Allerdings heißt innerhalb des
chroots der Erstellungsbaum immer ‘/tmp/guix-build-NAME.drv-0’, wobei
NAME der Ableitungsname ist — z.B. ‘coreutils-8.24’. Dadurch hat der
Wert von ‘TMPDIR’ keinen Einfluss auf die Erstellungsumgebung, wodurch
Unterschiede vermieden werden, falls Erstellungsprozesse den Namen ihres
Erstellungsbaumes einfangen.

   Der Daemon befolgt außerdem den Wert der Umgebungsvariablen
‘http_proxy’ für von ihm durchgeführte HTTP-Downloads, sei es für
Ableitungen mit fester Ausgabe (siehe *note Ableitungen::) oder für
Substitute (siehe *note Substitute::).

   Wenn Sie Guix als ein Benutzer ohne erweiterte Rechte installieren,
ist es dennoch möglich, ‘guix-daemon’ auszuführen, sofern Sie
‘--disable-chroot’ übergeben. Allerdings können Erstellungsprozesse dann
nicht voneinander und vom Rest des Systems isoliert werden. Daher können
sich Erstellungsprozesse gegenseitig stören und auf Programme,
Bibliotheken und andere Dateien zugreifen, die dem restlichen System zur
Verfügung stehen — was es deutlich schwerer macht, sie als _reine_
Funktionen aufzufassen.

   ---------- Footnotes ----------

   (1) Wenn Ihre Maschine systemd als „init“-System verwendet, genügt
es, die Datei ‘PREFIX/lib/systemd/system/guix-daemon.service’ in
‘/etc/systemd/system’ zu platzieren, damit ‘guix-daemon’ automatisch
gestartet wird. Ebenso können Sie, wenn Ihre Maschine Upstart als
„init“-System benutzt, die Datei
‘PREFIX/lib/upstart/system/guix-daemon.conf’ in ‘/etc/init’ platzieren.

   (2) „Größtenteils“, denn obwohl die Menge an Dateien, die im ‘/dev’
des chroots vorkommen, fest ist, können die meisten dieser Dateien nur
dann erstellt werden, wenn das Wirtssystem sie auch hat.


File: guix.de.info,  Node: Auslagern des Daemons einrichten,  Next: SELinux-Unterstützung,  Prev: Einrichten der Erstellungsumgebung,  Up: Den Daemon einrichten

2.4.2 Nutzung der Auslagerungsfunktionalität
--------------------------------------------

Wenn erwünscht, kann der Erstellungs-Daemon Ableitungserstellungen auf
andere Maschinen “auslagern”, auf denen Guix läuft, mit Hilfe des
‘offload’-“Build-Hooks”(1). Wenn diese Funktionalität aktiviert ist,
wird eine nutzerspezifizierte Liste von Erstellungsmaschinen aus
‘/etc/guix/machines.scm’ gelesen. Wann immer eine Erstellung angefragt
wird, zum Beispiel durch ‘guix build’, versucht der Daemon, sie an eine
der Erstellungsmaschinen auszulagern, die die Einschränkungen der
Ableitung erfüllen, insbesondere ihren Systemtyp — z.B. ‘x86_64-linux’.
Fehlende Voraussetzungen für die Erstellung werden über SSH auf die
Zielmaschine kopiert, welche dann mit der Erstellung weitermacht. Hat
sie Erfolg damit, so werden die Ausgabe oder Ausgaben der Erstellung
zurück auf die ursprüngliche Maschine kopiert.

   Die Datei ‘/etc/guix/machines.scm’ sieht normalerweise so aus:

     (list (build-machine
             (name "eightysix.example.org")
             (system "x86_64-linux")
             (host-key "ssh-ed25519 AAAAC3Nza…")
             (user "bob")
             (speed 2.))     ;unglaublich schnell!

           (build-machine
             (name "meeps.example.org")
             (system "mips64el-linux")
             (host-key "ssh-rsa AAAAB3Nza…")
             (user "alice")
             (private-key
              (string-append (getenv "HOME")
                             "/.ssh/identität-für-guix"))))

Im obigen Beispiel geben wir eine Liste mit zwei Erstellungsmaschinen
vor, eine für die ‘x86_64’-Architektur und eine für die
‘mips64el’-Architektur.

   Tatsächlich ist diese Datei — wenig überraschend! — eine
Scheme-Datei, die ausgewertet wird, wenn der ‘offload’-Hook gestartet
wird. Der Wert, den sie zurückliefert, muss eine Liste von
‘build-machine’-Objekten sein. Obwohl dieses Beispiel eine feste Liste
von Erstellungsmaschinen zeigt, könnte man auch auf die Idee kommen,
etwa mit DNS-SD eine Liste möglicher im lokalen Netzwerk entdeckter
Erstellungsmaschinen zu liefern (siehe *note Guile-Avahi:
(guile-avahi)Einführung.). Der Datentyp ‘build-machine’ wird im
Folgenden weiter ausgeführt.

 -- Datentyp: build-machine
     Dieser Datentyp repräsentiert Erstellungsmaschinen, an die der
     Daemon Erstellungen auslagern darf. Die wichtigen Felder sind:

     ‘name’
          Der Hostname (d.h. der Rechnername) der entfernten Maschine.

     ‘system’
          Der Systemtyp der entfernten Maschine — z.B. ‘"x86_64-linux"’.

     ‘user’
          Das Benutzerkonto, mit dem eine Verbindung zur entfernten
          Maschine über SSH aufgebaut werden soll. Beachten Sie, dass
          das SSH-Schlüsselpaar _nicht_ durch eine Passphrase geschützt
          sein darf, damit nicht-interaktive Anmeldungen möglich sind.

     ‘host-key’
          Dies muss der “öffentliche SSH-Host-Schlüssel” der Maschine im
          OpenSSH-Format sein. Er wird benutzt, um die Identität der
          Maschine zu prüfen, wenn wir uns mit ihr verbinden. Er ist
          eine lange Zeichenkette, die ungefähr so aussieht:

               ssh-ed25519 AAAAC3NzaC…mde+UhL hint@example.org

          Wenn auf der Maschine der OpenSSH-Daemon, ‘sshd’, läuft, ist
          der Host-Schlüssel in einer Datei wie
          ‘/etc/ssh/ssh_host_ed25519_key.pub’ zu finden.

          Wenn auf der Maschine der SSH-Daemon von GNU lsh, nämlich
          ‘lshd’, läuft, befindet sich der Host-Schlüssel in
          ‘/etc/lsh/host-key.pub’ oder einer ähnlichen Datei. Er kann
          ins OpenSSH-Format umgewandelt werden durch ‘lsh-export-key’
          (siehe *note (lsh)Converting keys::):

               $ lsh-export-key --openssh < /etc/lsh/host-key.pub
               ssh-rsa AAAAB3NzaC1yc2EAAAAEOp8FoQAAAQEAs1eB46LV…

     Eine Reihe optionaler Felder kann festgelegt werden:

     ‘port’ (Vorgabe: ‘22’)
          Portnummer des SSH-Servers auf der Maschine.

     ‘private-key’ (Vorgabe: ‘~root/.ssh/id_rsa’)
          Die Datei mit dem privaten SSH-Schlüssel, der beim Verbinden
          zur Maschine genutzt werden soll, im OpenSSH-Format. Dieser
          Schlüssel darf nicht mit einer Passphrase geschützt sein.

          Beachten Sie, dass als Vorgabewert der private Schlüssel _des
          root-Benutzers_ genommen wird. Vergewissern Sie sich, dass er
          existiert, wenn Sie die Standardeinstellung verwenden.

     ‘compression’ (Vorgabe: ‘"zlib@openssh.com,zlib"’)
     ‘compression-level’ (Vorgabe: ‘3’)
          Die Kompressionsmethoden auf SSH-Ebene und das angefragte
          Kompressionsniveau.

          Beachten Sie, dass Auslagerungen SSH-Kompression benötigen, um
          beim Übertragen von Dateien an Erstellungsmaschinen und zurück
          weniger Bandbreite zu benutzen.

     ‘daemon-socket’ (Vorgabe: ‘"/var/guix/daemon-socket/socket"’)
          Dateiname des Unix-Sockets, auf dem ‘guix-daemon’ auf der
          Maschine lauscht.

     ‘parallel-builds’ (Vorgabe: ‘1’)
          Die Anzahl der Erstellungen, die auf der Maschine parallel
          ausgeführt werden können.

     ‘speed’ (Vorgabe: ‘1.0’)
          Ein „relativer Geschwindigkeitsfaktor“. Der Auslagerungsplaner
          gibt tendenziell Maschinen mit höherem Geschwindigkeitsfaktor
          den Vorrang.

     ‘features’ (Vorgabe: ‘'()’)
          Eine Liste von Zeichenketten, die besondere von der Maschine
          unterstützte Funktionalitäten bezeichnen. Ein Beispiel ist
          ‘"kvm"’ für Maschinen, die über die KVM-Linux-Module zusammen
          mit entsprechender Hardware-Unterstützung verfügen.
          Ableitungen können Funktionalitäten dem Namen nach anfragen
          und werden dann auf passenden Erstellungsmaschinen eingeplant.

   Der Befehl ‘guix’ muss sich im Suchpfad der Erstellungsmaschinen
befinden. Um dies nachzuprüfen, können Sie Folgendes ausführen:

     ssh build-machine guix repl --version

   Es gibt noch eine weitere Sache zu tun, sobald ‘machines.scm’
eingerichtet ist. Wie zuvor erklärt, werden beim Auslagern Dateien
zwischen den Stores der Maschinen hin- und hergeschickt. Damit das
funktioniert, müssen Sie als Erstes ein Schlüsselpaar auf jeder Maschine
erzeugen, damit der Daemon signierte Archive mit den Dateien aus dem
Store versenden kann (siehe *note Aufruf von guix archive::):

     # guix archive --generate-key

Jede Erstellungsmaschine muss den Schlüssel der Hauptmaschine
autorisieren, damit diese Store-Objekte von der Hauptmaschine empfangen
kann:

     # guix archive --authorize < öffentlicher-schlüssel-hauptmaschine.txt

Andersherum muss auch die Hauptmaschine den jeweiligen Schlüssel jeder
Erstellungsmaschine autorisieren.

   Der ganze Umstand mit den Schlüsseln soll ausdrücken, dass sich
Haupt- und Erstellungsmaschinen paarweise gegenseitig vertrauen. Konkret
kann der Erstellungs-Daemon auf der Hauptmaschine die Echtheit von den
Erstellungsmaschinen empfangener Dateien gewährleisten (und umgekehrt),
und auch dass sie nicht sabotiert wurden und mit einem autorisierten
Schlüssel signiert wurden.

   Um zu testen, ob Ihr System funktioniert, führen Sie diesen Befehl
auf der Hauptmaschine aus:

     # guix offload test

   Dadurch wird versucht, zu jeder Erstellungsmaschine eine Verbindung
herzustellen, die in ‘/etc/guix/machines.scm’ angegeben wurde,
sichergestellt, dass auf jeder Guile und die Guix-Module nutzbar sind,
und jeweils versucht, etwas auf die Erstellungsmaschine zu exportieren
und von dort zu imporieren. Dabei auftretende Fehler werden gemeldet.

   Wenn Sie stattdessen eine andere Maschinendatei verwenden möchten,
geben Sie diese einfach auf der Befehlszeile an:

     # guix offload test maschinen-qualif.scm

   Letztendlich können Sie hiermit nur die Teilmenge der Maschinen
testen, deren Name zu einem regulären Ausdruck passt:

     # guix offload test maschinen.scm '\.gnu\.org$'

   Um die momentane Auslastung aller Erstellungs-Hosts anzuzeigen,
führen Sie diesen Befehl auf dem Hauptknoten aus:

     # guix offload status

   ---------- Footnotes ----------

   (1) Diese Funktionalität ist nur verfügbar, wenn Guile-SSH
(https://github.com/artyom-poptsov/guile-ssh) vorhanden ist.


File: guix.de.info,  Node: SELinux-Unterstützung,  Prev: Auslagern des Daemons einrichten,  Up: Den Daemon einrichten

2.4.3 SELinux-Unterstützung
---------------------------

Guix enthält eine SELinux-Richtliniendatei („Policy“) unter
‘etc/guix-daemon.cil’, die auf einem System installiert werden kann, auf
dem SELinux aktiviert ist, damit Guix-Dateien gekennzeichnet sind und um
das erwartete Verhalten des Daemons anzugeben. Da Guix System keine
Grundrichtlinie („Base Policy“) für SELinux bietet, kann diese
Richtlinie für den Daemon auf Guix System nicht benutzt werden.

2.4.3.1 Installieren der SELinux-Policy
.......................................

Um die Richtlinie (Policy) zu installieren, führen Sie folgenden Befehl
mit Administratorrechten aus:

     semodule -i etc/guix-daemon.cil

   Kennzeichnen Sie dann das Dateisystem neu mit ‘restorecon’ oder einem
anderen, von Ihrem System angebotenen Mechanismus.

   Sobald die Richtlinie installiert ist, das Dateisystem neu
gekennzeichnet wurde und der Daemon neugestartet wurde, sollte er im
Kontext ‘guix_daemon_t’ laufen. Sie können dies mit dem folgenden Befehl
nachprüfen:

     ps -Zax | grep guix-daemon

   Beobachten Sie die Protokolldateien von SELinux, wenn Sie einen
Befehl wie ‘guix build hello’ ausführen, um sich zu überzeugen, dass
SELinux alle notwendigen Operationen gestattet.

2.4.3.2 Einschränkungen
.......................

Diese Richtlinie ist nicht perfekt. Im Folgenden finden Sie eine Liste
von Einschränkungen oder merkwürdigen Verhaltensweisen, die bedacht
werden sollten, wenn man die mitgelieferte SELinux-Richtlinie für den
Guix-Daemon einspielt.

  1. ‘guix_daemon_socket_t’ wird nicht wirklich benutzt. Keine der
     Socket-Operationen benutzt Kontexte, die irgendetwas mit
     ‘guix_daemon_socket_t’ zu tun haben. Es schadet nicht, diese
     ungenutzte Kennzeichnung zu haben, aber es wäre besser, für die
     Kennzeichnung auch Socket-Regeln festzulegen.

  2. ‘guix gc’ kann nicht auf beliebige Verknüpfungen zu Profilen
     zugreifen. Die Kennzeichnung des Ziels einer symbolischen
     Verknüpfung ist notwendigerweise unabhängig von der
     Dateikennzeichnung der Verknüpfung. Obwohl alle Profile unter
     $localstatedir gekennzeichnet sind, erben die Verknüpfungen auf
     diese Profile die Kennzeichnung desjenigen Verzeichnisses, in dem
     sie sich befinden. Für Verknüpfungen im Persönlichen Verzeichnis
     des Benutzers ist das ‘user_home_t’, aber Verknüpfungen aus dem
     Persönlichen Verzeichnis des Administratornutzers, oder ‘/tmp’,
     oder das Arbeitsverzeichnis des HTTP-Servers, etc., funktioniert
     das nicht. ‘guix gc’ würde es nicht gestattet, diese Verknüpfungen
     auszulesen oder zu verfolgen.

  3. Die vom Daemon gebotene Funktionalität, auf TCP-Verbindungen zu
     lauschen, könnte nicht mehr funktionieren. Dies könnte zusätzliche
     Regeln brauchen, weil SELinux Netzwerk-Sockets anders behandelt als
     Dateien.

  4. Derzeit wird allen Dateien mit einem Namen, der zum regulären
     Ausdruck ‘/gnu/store/.+-(guix-.+|profile)/bin/guix-daemon’ passt,
     die Kennzeichnung ‘guix_daemon_exec_t’ zugewiesen, wodurch _jede
     beliebige_ Datei mit diesem Namen in irgendeinem Profil gestattet
     wäre, in der Domäne ‘guix_daemon_t’ ausgeführt zu werden. Das ist
     nicht ideal. Ein Angreifer könnte ein Paket erstellen, dass solch
     eine ausführbare Datei enthält, und den Nutzer überzeugen, es zu
     installieren und auszuführen. Dadurch käme es in die Domäne
     ‘guix_daemon_t’. Ab diesem Punkt könnte SELinux nicht mehr
     verhindern, dass es auf Dateien zugreift, auf die Prozesse in
     dieser Domäne zugreifen dürfen.

     Wir könnten zum Zeitpunkt der Installation eine wesentlich
     restriktivere Richtlinie generieren, für die nur _genau derselbe_
     Dateiname des gerade installierten ‘guix-daemon’-Programms als
     ‘guix_daemon_exec_t’ gekennzeichnet würde, statt einen vieles
     umfassenden regulären Ausdruck zu benutzen. Aber dann müsste der
     Administratornutzer zum Zeitpunkt der Installation jedes Mal die
     Richtlinie installieren oder aktualisieren müssen, sobald das
     Guix-Paket aktualisiert wird, dass das tatsächlich in Benutzung
     befindliche ‘guix-daemon’-Programm enthält.


File: guix.de.info,  Node: Aufruf des guix-daemon,  Next: Anwendungen einrichten,  Prev: Den Daemon einrichten,  Up: Installation

2.5 Aufruf von ‘guix-daemon’
============================

Das Programm ‘guix-daemon’ implementiert alle Funktionalitäten, um auf
den Store zuzugreifen. Dazu gehört das Starten von Erstellungsprozessen,
das Ausführen des Müllsammlers, das Abfragen, ob ein Erstellungsergebnis
verfügbar ist, etc. Normalerweise wird er so als Administratornutzer
(‘root’) gestartet:

     # guix-daemon --build-users-group=guixbuild

Details, wie Sie ihn einrichten, finden Sie im Abschnitt *note Den
Daemon einrichten::.

   Standardmäßig führt ‘guix-daemon’ Erstellungsprozesse mit
unterschiedlichen UIDs aus, die aus der Erstellungsgruppe stammen, deren
Name mit ‘--build-users-group’ übergeben wurde. Außerdem läuft jeder
Erstellungsprozess in einer chroot-Umgebung, die nur die Teilmenge des
Stores enthält, von der der Erstellungsprozess abhängt, entsprechend
seiner Ableitung (siehe *note derivation: Programmierschnittstelle.),
und ein paar bestimmte Systemverzeichnisse, darunter standardmäßig auch
‘/dev’ und ‘/dev/pts’. Zudem ist die Erstellungsumgebung auf GNU/Linux
ein “Container”: Nicht nur hat er seinen eigenen Dateisystembaum, er hat
auch einen separaten Namensraum zum Einhängen von Dateisystemen, seinen
eigenen Namensraum für PIDs, für Netzwerke, etc. Dies hilft dabei,
reproduzierbare Erstellungen zu garantieren (siehe *note
Funktionalitäten::).

   Wenn der Daemon im Auftrag des Nutzers eine Erstellung durchführt,
erzeugt er ein Erstellungsverzeichnis, entweder in ‘/tmp’ oder im
Verzeichnis, das durch die Umgebungsvariable ‘TMPDIR’ angegeben wurde.
Dieses Verzeichnis wird mit dem Container geteilt, solange die
Erstellung noch läuft, allerdings trägt es im Container stattdessen
immer den Namen „/tmp/guix-build-NAME.drv-0“.

   Nach Abschluss der Erstellung wird das Erstellungsverzeichnis
automatisch entfernt, außer wenn die Erstellung fehlgeschlagen ist und
der Client ‘--keep-failed’ angegeben hat (siehe *note ‘--keep-failed’:
Aufruf von guix build.).

   Der Daemon lauscht auf Verbindungen und erstellt jeweils einen
Unterprozess für jede von einem Client begonnene Sitzung (d.h. von einem
der ‘guix’-Unterbefehle). Der Befehl ‘guix processes’ zeigt Ihnen eine
Übersicht solcher Systemaktivitäten; damit werden Ihnen alle aktiven
Sitzungen und Clients gezeigt. Weitere Informationen finden Sie unter
*note Aufruf von guix processes::.

   Die folgenden Befehlszeilenoptionen werden unterstützt:

‘--build-users-group=GRUPPE’
     Verwende die Benutzerkonten aus der GRUPPE, um Erstellungsprozesse
     auszuführen (siehe *note build users: Den Daemon einrichten.).

‘--no-substitutes’
     Benutze keine Substitute für Erstellungsergebnisse. Das heißt, dass
     alle Objekte lokal erstellt werden müssen, und kein Herunterladen
     von vorab erstellten Binärdateien erlaubt ist (siehe *note
     Substitute::).

     Wenn der Daemon mit ‘--no-substitutes’ ausgeführt wird, können
     Clients trotzdem Substitute explizit aktivieren über den entfernten
     Prozeduraufruf ‘set-build-options’ (siehe *note Der Store::).

‘--substitute-urls=URLS’
     URLS als standardmäßige, leerzeichengetrennte Liste der Quell-URLs
     für Substitute benutzen. Wenn diese Befehlszeilenoption _nicht_
     angegeben wird, wird ‘https://ci.guix.gnu.org’ verwendet.

     Das hat zur Folge, dass Substitute von den URLS heruntergeladen
     werden können, solange sie mit einer Signatur versehen sind, der
     vertraut wird (siehe *note Substitute::).

‘--no-offload’
     Nicht versuchen, an andere Maschinen ausgelagerte Erstellungen zu
     benutzen (siehe *note Auslagern des Daemons einrichten::). Somit
     wird lokal erstellt, statt Erstellungen auf entfernte Maschinen
     auszulagern.

‘--cache-failures’
     Fehler bei der Erstellung zwischenspeichern. Normalerweise werden
     nur erfolgreiche Erstellungen gespeichert.

     Wenn diese Befehlszeilenoption benutzt wird, kann ‘guix gc
     --list-failures’ benutzt werden, um die Menge an Store-Objekten
     abzufragen, die als Fehlschläge markiert sind; ‘guix gc
     --clear-failures’ entfernt Store-Objekte aus der Menge
     zwischengespeicherter Fehlschläge. Siehe *note Aufruf von guix
     gc::.

‘--cores=N’
‘-c N’
     N CPU-Kerne zum Erstellen jeder Ableitung benutzen; ‘0’ heißt, so
     viele wie verfügbar sind.

     Der Vorgabewert ist ‘0’, jeder Client kann jedoch eine abweichende
     Anzahl vorgeben, zum Beispiel mit der Befehlszeilenoption ‘--cores’
     von ‘guix build’ (siehe *note Aufruf von guix build::).

     Dadurch wird die Umgebungsvariable ‘NIX_BUILD_CORES’ im
     Erstellungsprozess definiert, welcher sie benutzen kann, um intern
     parallele Ausführungen zuzulassen — zum Beispiel durch Nutzung von
     ‘make -j$NIX_BUILD_CORES’.

‘--max-jobs=N’
‘-M N’
     Höchstenss N Erstellungsaufträge parallel bearbeiten. Der
     Vorgabewert liegt bei ‘1’. Wird er auf ‘0’ gesetzt, werden keine
     Erstellungen lokal durchgeführt, stattdessen lagert der Daemon sie
     nur aus (siehe *note Auslagern des Daemons einrichten::) oder sie
     schlagen einfach fehl.

‘--max-silent-time=SEKUNDEN’
     Wenn der Erstellungs- oder Substitutionsprozess länger als
     SEKUNDEN-lang keine Ausgabe erzeugt, wird er abgebrochen und ein
     Fehler beim Erstellen gemeldet.

     Der Vorgabewert ist ‘0’, was bedeutet, dass es keine
     Zeitbeschränkung gibt.

     Clients können einen anderen Wert als den hier angegebenen
     verwenden lassen (siehe *note ‘--max-silent-time’: Gemeinsame
     Erstellungsoptionen.).

‘--timeout=SEKUNDEN’
     Entsprechend wird hier der Erstellungs- oder Substitutionsprozess
     abgebrochen und als Fehlschlag gemeldet, wenn er mehr als
     SEKUNDEN-lang dauert.

     Der Vorgabewert ist ‘0’, was bedeutet, dass es keine
     Zeitbeschränkung gibt.

     Clients können einen anderen Wert verwenden lassen (siehe *note
     ‘--timeout’: Gemeinsame Erstellungsoptionen.).

‘--rounds=N’
     Jede Ableitung N-mal hintereinander erstellen und einen Fehler
     melden, wenn nacheinander ausgewertete Erstellungsergebnisse nicht
     Bit für Bit identisch sind. Beachten Sie, dass Clients wie ‘guix
     build’ einen anderen Wert verwenden lassen können (siehe *note
     Aufruf von guix build::).

     Wenn dies zusammen mit ‘--keep-failed’ benutzt wird, bleiben die
     sich unterscheidenden Ausgaben im Store unter dem Namen
     ‘/gnu/store/…-check’. Dadurch können Unterschiede zwischen den
     beiden Ergebnissen leicht erkannt werden.

‘--debug’
     Informationen zur Fehlersuche ausgeben.

     Dies ist nützlich, um Probleme beim Starten des Daemons
     nachzuvollziehen; Clients könn aber auch ein abweichenden Wert
     verwenden lassen, zum Beispiel mit der Befehlszeilenoption
     ‘--verbosity’ von ‘guix build’ (siehe *note Aufruf von guix
     build::).

‘--chroot-directory=VERZEICHNIS’
     Füge das VERZEICHNIS zum chroot von Erstellungen hinzu.

     Dadurch kann sich das Ergebnis von Erstellungsprozessen ändern —
     zum Beispiel, wenn diese optionale Abhängigkeiten aus dem
     VERZEICHNIS verwenden, wenn sie verfügbar sind, und nicht, wenn es
     fehlt. Deshalb ist es nicht empfohlen, dass Sie diese
     Befehlszeilenoption verwenden, besser sollten Sie dafür sorgen,
     dass jede Ableitung alle von ihr benötigten Eingabgen deklariert.

‘--disable-chroot’
     Erstellungen ohne chroot durchführen.

     Diese Befehlszeilenoption zu benutzen, wird nicht empfohlen, denn
     auch dadurch bekämen Erstellungsprozesse Zugriff auf nicht
     deklarierte Abhängigkeiten. Sie ist allerdings unvermeidlich, wenn
     ‘guix-daemon’ auf einem Benutzerkonto ohne ausreichende
     Berechtigungen ausgeführt wird.

‘--log-compression=TYP’
     Erstellungsprotokolle werden entsprechend dem TYP komprimiert, der
     entweder ‘gzip’, ‘bzip2’ oder ‘none’ (für keine Kompression) sein
     muss.

     Sofern nicht ‘--lose-logs’ angegeben wurde, werden alle
     Erstellungsprotokolle in der LOCALSTATEDIR gespeichert. Um Platz zu
     sparen, komprimiert sie der Daemon standardmäßig automatisch mit
     bzip2.

‘--disable-deduplication’
     Automatische Dateien-„Deduplizierung“ im Store ausschalten.

     Standardmäßig werden zum Store hinzugefügte Objekte automatisch
     „dedupliziert“: Wenn eine neue Datei mit einer anderen im Store
     übereinstimmt, wird die neue Datei stattdessen als harte
     Verknüpfung auf die andere Datei angelegt. Dies reduziert den
     Speicherverbrauch auf der Platte merklich, jedoch steigt
     andererseits die Auslastung bei der Ein-/Ausgabe im
     Erstellungsprozess geringfügig. Durch diese Option wird keine
     solche Optimierung durchgeführt.

‘--gc-keep-outputs[=yes|no]’
     Gibt an, ob der Müllsammler (Garbage Collector, GC) die Ausgaben
     lebendiger Ableitungen behalten muss („yes“) oder nicht („no“).

     Für „yes“ behält der Müllsammler die Ausgaben aller lebendigen
     Ableitungen im Store — die ‘.drv’-Dateien. Der Vorgabewert ist aber
     „no“, so dass Ableitungsausgaben nur vorgehalten werden, wenn sie
     von einer Müllsammlerwurzel aus erreichbar sind. Siehe den
     Abschnitt *note Aufruf von guix gc:: für weitere Informationen zu
     Müllsammlerwurzeln.

‘--gc-keep-derivations[=yes|no]’
     Gibt an, ob der Müllsammler (GC) Ableitungen behalten muss („yes“),
     wenn sie lebendige Ausgaben haben, oder nicht („no“).

     Für „yes“, den Vorgabewert, behält der Müllsammler Ableitungen —
     z.B. ‘.drv’-Dateien —, solange zumindest eine ihrer Ausgaben
     lebendig ist. Dadurch können Nutzer den Ursprung der Dateien in
     ihrem Store nachvollziehen. Setzt man den Wert auf „no“, wird ein
     bisschen weniger Speicher auf der Platte verbraucht.

     Auf diese Weise überträgt sich, wenn ‘--gc-keep-derivations’ auf
     „yes“ steht, die Lebendigkeit von Ausgaben auf Ableitungen, und
     wenn ‘--gc-keep-outputs’ auf „yes“ steht, die Lebendigkeit von
     Ableitungen auf Ausgaben. Stehen beide auf „yes“, bleiben so alle
     Erstellungsvoraussetzungen wie Quelldateien, Compiler, Bibliotheken
     und andere Erstellungswerkzeuge lebendiger Objekte im Store
     erhalten, ob sie von einer Müllsammlerwurzel aus erreichbar sind
     oder nicht. Entwickler können sich so erneute Erstellungen oder
     erneutes Herunterladen sparen.

‘--impersonate-linux-2.6’
     Auf Linux-basierten Systemen wird hiermit vorgetäuscht, dass es
     sich um Linux 2.6 handeln würde, indem der Kernel für einen
     ‘uname’-Systemaufruf als Version der Veröffentlichung mit 2.6
     antwortet.

     Dies kann hilfreich sein, um Programme zu erstellen, die
     (normalerweise zu Unrecht) von der Kernel-Versionsnummer abhängen.

‘--lose-logs’
     Keine Protokolle der Erstellungen vorhalten. Normalerweise würden
     solche in ‘LOCALSTATEDIR/guix/log’ gespeichert.

‘--system=SYSTEM’
     Verwende SYSTEM als aktuellen Systemtyp. Standardmäßig ist dies das
     Paar aus Befehlssatz und Kernel, welches beim Aufruf von
     ‘configure’ erkannt wurde, wie zum Beispiel ‘x86_64-linux’.

‘--listen=ENDPUNKT’
     Lausche am ENDPUNKT auf Verbindungen. Dabei wird der ENDPUNKT als
     Dateiname eines Unix-Sockets verstanden, wenn er mit einem ‘/’
     (Schrägstrich) beginnt. Andernfalls wird der ENDPUNKT als Hostname
     (d.h. Rechnername) oder als Hostname-Port-Paar verstanden, auf dem
     gelauscht wird. Hier sind ein paar Beispiele:

     ‘--listen=/gnu/var/daemon’
          Lausche auf Verbindungen am Unix-Socket ‘/gnu/var/daemon’,
          falls nötig wird er dazu erstellt.

     ‘--listen=localhost’
          Lausche auf TCP-Verbindungen an der Netzwerkschnittstelle, die
          ‘localhost’ entspricht, auf Port 44146.

     ‘--listen=128.0.0.42:1234’
          Lausche auf TCP-Verbindungen an der Netzwerkschnittstelle, die
          ‘128.0.0.42’ entspricht, auf Port 1234.

     Diese Befehlszeilenoption kann mehrmals wiederholt werden. In
     diesem Fall akzeptiert ‘guix-daemon’ Verbindungen auf allen
     angegebenen Endpunkten. Benutzer können bei Client-Befehlen
     angeben, mit welchem Endpunkt sie sich verbinden möchten, indem sie
     die Umgebungsvariable ‘GUIX_DAEMON_SOCKET’ festlegen (siehe *note
     ‘GUIX_DAEMON_SOCKET’: Der Store.).

          Anmerkung: Das Daemon-Protokoll ist _weder authentifiziert
          noch verschlüsselt_. Die Benutzung von ‘--listen=HOST’ eignet
          sich für lokale Netzwerke, wie z.B. in Rechen-Clustern, wo
          sich nur solche Knoten mit dem Daemon verbinden, denen man
          vertraut. In Situationen, wo ein Fernzugriff auf den Daemon
          durchgeführt wird, empfehlen wir, über Unix-Sockets in
          Verbindung mit SSH zuzugreifen.

     Wird ‘--listen’ nicht angegeben, lauscht ‘guix-daemon’ auf
     Verbindungen auf dem Unix-Socket, der sich unter
     ‘LOCALSTATEDIR/guix/daemon-socket/socket’ befindet.


File: guix.de.info,  Node: Anwendungen einrichten,  Next: Aktualisieren von Guix,  Prev: Aufruf des guix-daemon,  Up: Installation

2.6 Anwendungen einrichten
==========================

Läuft Guix aufgesetzt auf einer GNU/Linux-Distribution außer Guix System
— einer sogenannten “Fremddistribution” —, so sind ein paar zusätzliche
Schritte bei der Einrichtung nötig. Hier finden Sie manche davon.

2.6.1 Locales
-------------

Über Guix installierte Pakete benutzen nicht die Daten zu Regions- und
Spracheinstellungen (Locales) des Wirtssystems. Stattdessen müssen Sie
erst eines der Locale-Pakete installieren, die für Guix verfügbar sind,
und dann den Wert Ihrer Umgebungsvariablen ‘GUIX_LOCPATH’ passend
festlegen:

     $ guix install glibc-locales
     $ export GUIX_LOCPATH=$HOME/.guix-profile/lib/locale

   Beachten Sie, dass das Paket ‘glibc-locales’ Daten für alle von
GNU libc unterstützten Locales enthält und deswegen um die 917 MiB
wiegt. Alternativ gibt es auch ‘glibc-utf8-locales’, was kleiner, aber
auf ein paar UTF-8-Locales beschränkt ist.

   Die Variable ‘GUIX_LOCPATH’ spielt eine ähnliche Rolle wie ‘LOCPATH’
(siehe *note ‘LOCPATH’: (libc)Locale Names.). Es gibt jedoch zwei
wichtige Unterschiede:

  1. ‘GUIX_LOCPATH’ wird nur von der libc in Guix beachtet und nicht der
     von Fremddistributionen bereitgestellten libc. Mit ‘GUIX_LOCPATH’
     können Sie daher sicherstellen, dass die Programme der
     Fremddistribution keine inkompatiblen Locale-Daten von Guix laden.

  2. libc hängt an jeden ‘GUIX_LOCPATH’-Eintrag ‘/X.Y’ an, wobei ‘X.Y’
     die Version von libc ist — z.B. ‘2.22’. Sollte Ihr Guix-Profil eine
     Mischung aus Programmen enthalten, die an verschiedene
     libc-Versionen gebunden sind, wird jede nur die Locale-Daten im
     richtigen Format zu laden versuchen.

   Das ist wichtig, weil das Locale-Datenformat verschiedener
libc-Versionen inkompatibel sein könnte.

2.6.2 Name Service Switch
-------------------------

Wenn Sie Guix auf einer Fremddistribution verwenden, _empfehlen wir
stärkstens_, dass Sie den “Name Service Cache Daemon” der
GNU-C-Bibliothek, ‘nscd’, laufen lassen, welcher auf dem Socket
‘/var/run/nscd/socket’ lauschen sollte. Wenn Sie das nicht tun, könnten
mit Guix installierte Anwendungen Probleme beim Auflösen von Hostnamen
(d.h. Rechnernamen) oder Benutzerkonten haben, oder sogar abstürzen. Die
nächsten Absätze erklären warum.

   Die GNU-C-Bibliothek implementiert einen “Name Service Switch” (NSS),
welcher einen erweiterbaren Mechanismus zur allgemeinen
„Namensauflösung“ darstellt: Hostnamensauflösung, Benutzerkonten und
weiteres (siehe *note (libc)Name Service Switch::).

   Für die Erweiterbarkeit unterstützt der NSS “Plugins”, welche neue
Implementierungen zur Namensauflösung bieten: Zum Beispiel ermöglicht
das Plugin ‘nss-mdns’ die Namensauflösung für ‘.local’-Hostnamen, das
Plugin ‘nis’ gestattet die Auflösung von Benutzerkonten über den Network
Information Service (NIS) und so weiter. Diese zusätzlichen
„Auflösungsdienste“ werden systemweit konfiguriert in
‘/etc/nsswitch.conf’ und alle auf dem System laufenden Programme halten
sich an diese Einstellungen (siehe *note (libc)NSS Configuration
File::).

   Wenn sie eine Namensauflösung durchführen — zum Beispiel, indem sie
die ‘getaddrinfo’-Funktion in C aufrufen — versuchen die Anwendungen als
Erstes, sich mit dem nscd zu verbinden; ist dies erfolgreich, führt nscd
für sie die weiteren Namensauflösungen durch. Falls nscd nicht läuft,
führen sie selbst die Namensauflösungen durch, indem sie die
Namensauflösungsdienste in ihren eigenen Adressraum laden und ausführen.
Diese Namensauflösungsdienste — die ‘libnss_*.so’-Dateien — werden mit
‘dlopen’ geladen, aber sie kommen von der C-Bibliothek des Wirtssystems
und nicht von der C-Bibliothek, an die die Anwendung gebunden wurde
(also der C-Bibliothek von Guix).

   Und hier kommt es zum Problem: Wenn die Anwendung an die C-Bibliothek
von Guix (etwa glibc 2.24) gebunden wurde und die NSS-Plugins von einer
anderen C-Bibliothek (etwa ‘libnss_mdns.so’ für glibc 2.22) zu laden
versucht, wird sie vermutlich abstürzen oder die Namensauflösungen
werden unerwartet fehlschlagen.

   Durch das Ausführen von ‘nscd’ auf dem System wird, neben anderen
Vorteilen, dieses Problem der binären Inkompatibilität vermieden, weil
diese ‘libnss_*.so’-Dateien vom ‘nscd’-Prozess geladen werden, nicht in
den Anwendungen selbst.

2.6.3 X11-Schriftarten
----------------------

Die Mehrheit der grafischen Anwendungen benutzen Fontconfig zum Finden
und Laden von Schriftarten und für die Darstellung im X11-Client. Im
Paket ‘fontconfig’ in Guix werden Schriftarten standardmäßig in
‘$HOME/.guix-profile’ gesucht. Um es grafischen Anwendungen, die mit
Guix installiert wurden, zu ermöglichen, Schriftarten anzuzeigen, müssen
Sie die Schriftarten auch mit Guix installieren. Essenzielle Pakete für
Schriftarten sind unter anderem ‘gs-fonts’, ‘font-dejavu’ und
‘font-gnu-freefont-ttf’.

   Sobald Sie Schriftarten installiert oder wieder entfernt haben oder
wenn Ihnen auffällt, dass eine Anwendung Schriftarten nicht finden kann,
dann müssen Sie vielleicht Fontconfig installieren und den folgenden
Befehl ausführen, damit dessen Zwischenspeicher für Schriftarten
aktualisiert wird:

     guix install fontconfig
     fc-cache -rv

   Um auf Chinesisch, Japanisch oder Koreanisch verfassten Text in
grafischen Anwendungen anzeigen zu können, möchten Sie vielleicht
‘font-adobe-source-han-sans’ oder ‘font-wqy-zenhei’ installieren.
Ersteres hat mehrere Ausgaben, für jede Sprachfamilie eine (siehe *note
Pakete mit mehreren Ausgaben.::). Zum Beispiel installiert folgender
Befehl Schriftarten für chinesische Sprachen:

     guix install font-adobe-source-han-sans:cn

   Ältere Programme wie ‘xterm’ benutzen kein Fontconfig, sondern
X-Server-seitige Schriftartendarstellung. Solche Programme setzen
voraus, dass der volle Name einer Schriftart mit XLFD (X Logical Font
Description) angegeben wird, z.B. so:

     -*-dejavu sans-medium-r-normal-*-*-100-*-*-*-*-*-1

   Um solche vollen Namen für die in Ihrem Guix-Profil installierten
TrueType-Schriftarten zu verwenden, müssen Sie den Pfad für Schriftarten
(Font Path) des X-Servers anpassen:

     xset +fp $(dirname $(readlink -f ~/.guix-profile/share/fonts/truetype/fonts.dir))

   Danach können Sie den Befehl ‘xlsfonts’ ausführen (aus dem Paket
‘xlsfonts’), um sicherzustellen, dass dort Ihre TrueType-Schriftarten
aufgeführt sind.

2.6.4 X.509-Zertifikate
-----------------------

Das Paket ‘nss-certs’ bietet X.509-Zertifikate, womit Programme die
Identität von Web-Servern authentifizieren können, auf die über HTTPS
zugegriffen wird.

   Wenn Sie Guix auf einer Fremddistribution verwenden, können Sie
dieses Paket installieren und die relevanten Umgebungsvariablen
festlegen, damit Pakete wissen, wo sie Zertifikate finden. Unter *note
X.509-Zertifikate:: stehen genaue Informationen.

2.6.5 Emacs-Pakete
------------------

Wenn Sie Emacs-Pakete mit Guix installieren, werden die Elisp-Dateien
innerhalb des Verzeichnisses ‘share/emacs/site-lisp/’ in demjenigen
Profil platziert, wohin sie installiert werden. Die Elisp-Bibliotheken
werden in Emacs über die ‘EMACSLOADPATH’-Umgebungsvariable verfügbar
gemacht, die durch die Installation von Emacs eingerichtet wird.

   Bei der Initialisierung von Emacs werden „Autoload“-Definitionen
automatisch über die Guix-spezifische Prozedur
‘guix-emacs-autoload-packages’ ausgewertet. Wenn Sie aber aus
irgendeinem Grund die mit Guix installierten Pakete nicht automatisch
laden lassen möchten, können Sie Emacs mit der Befehlszeilenoption
‘--no-site-file’ starten (siehe *note (emacs)Init File::).

2.6.6 GCC-Toolchain
-------------------

Guix bietet individuelle Compiler-Pakete wie etwa ‘gcc’, aber wenn Sie
einen vollständigen Satz an Werkzeugen zum Kompilieren und Binden von
Quellcode brauchen, werden Sie eigentlich das Paket ‘gcc-toolchain’
haben wollen. Das Paket bietet eine vollständige GCC-Toolchain für die
Entwicklung mit C/C++, einschließlich GCC selbst, der GNU-C-Bibliothek
(Header-Dateien und Binärdateien samt Symbolen zur Fehlersuche/Debugging
in der ‘debug’-Ausgabe), Binutils und einen Wrapper für den
Binder/Linker.

   Der Zweck des Wrappers ist, die an den Binder übergebenen
Befehlszeilenoptionen mit ‘-L’ und ‘-l’ zu überprüfen und jeweils
passende Argumente mit ‘-rpath’ anzufügen, womit dann der echte Binder
aufgerufen wird. Standardmäßig weigert sich der Binder-Wrapper, mit
Bibliotheken außerhalb des Stores zu binden, um „Reinheit“ zu
gewährleisten. Das kann aber stören, wenn man die Toolchain benutzt, um
mit lokalen Bibliotheken zu binden. Um Referenzen auf Bibliotheken
außerhalb des Stores zu erlauben, müssen Sie die Umgebungsvariable
‘GUIX_LD_WRAPPER_ALLOW_IMPURITIES’ setzen.


File: guix.de.info,  Node: Aktualisieren von Guix,  Prev: Anwendungen einrichten,  Up: Installation

2.7 Aktualisieren von Guix
==========================

Um Guix zu aktualisieren, führen Sie aus:

     guix pull

   Siehe *note Aufruf von guix pull:: für weitere Informationen.

   Auf einer Fremddistribution können Sie den Erstellungsdaemon
aktualisieren, indem Sie diesen Befehl:

     sudo -i guix pull

gefolgt von diesem ausführen (unter der Annahme, dass Ihre Distribution
zur Dienstverwaltung das systemd-Werkzeug benutzt):

     systemctl restart guix-daemon.service

   Auf Guix System wird der Daemon aktualisiert, indem Sie das System
rekonfigurieren (siehe *note ‘guix system reconfigure’: Aufruf von guix
system.).


File: guix.de.info,  Node: Systeminstallation,  Next: Paketverwaltung,  Prev: Installation,  Up: Top

3 Systeminstallation
********************

Dieser Abschnitt beschreibt, wie Sie „Guix System“ auf einer Maschine
installieren. Guix kann auch als Paketverwaltungswerkzeug ein
bestehendes GNU/Linux-System ergänzen, mehr dazu finden Sie im Abschnitt
*note Installation::.

     Anmerkung: Sie lesen diese Dokumentation mit einem Info-Betrachter.
     Details, wie Sie ihn bedienen, erfahren Sie, indem Sie die
     Eingabetaste (auch „Return“ oder „Enter“ genannt) auf folgender
     Verknüpfung drücken: *note Info reader: (info-stnd)Top. Drücken Sie
     danach ‘l’, um hierher zurückzukommen.

     Führen Sie alternativ ‘info info’ auf einer anderen Konsole (tty)
     aus, um dieses Handbuch offen zu lassen.

* Menu:

* Einschränkungen::         Was Sie erwarten dürfen.
* Hardware-Überlegungen::   Unterstützte Hardware.
* Installation von USB-Stick oder DVD::  Das Installationsmedium
                                           vorbereiten.
* Vor der Installation::     Netzwerkanbindung, Partitionierung etc.
* Geführte grafische Installation::  Leichte grafische Installation.
* Manuelle Installation::    Manuelle Installation für Zauberer.
* Nach der Systeminstallation::  Wenn die Installation erfolgreich war.
* Guix in einer VM installieren::  Ein „Guix System“-Spielplatz.
* Ein Abbild zur Installation erstellen::  Wie ein solches entsteht.


File: guix.de.info,  Node: Einschränkungen,  Next: Hardware-Überlegungen,  Up: Systeminstallation

3.1 Einschränkungen
===================

Wir denken, dass Guix System für viele Anwendungszwecke von Heim- und
Bürorechnern bis hin zu Servern geeignet ist. Die
Verlässlichkeitsgarantien, die es einem bietet — transaktionelle
Aktualisierungen und Rücksetzungen, Reproduzierbarkeit — machen es zu
einer soliden Grundlage.

   Bevor Sie mit der Installation fortfahren, sollten Sie dennoch die
folgenden merklichen Einschränkungen der Version 1.1.0.411-5c10d
beachten:

   • Der Logical Volume Manager (LVM) wird nicht unterstützt.

   • Immer mehr Systemdienste sind verfügbar (siehe *note Dienste::),
     aber manche könnten noch fehlen.

   • GNOME, Xfce, LXDE und Enlightenment stehen zur Verfügung (siehe
     *note Desktop-Dienste::), ebenso eine Reihe von
     X11-Fensterverwaltungsprogrammen, allerdings fehlt KDE zur Zeit
     noch.

   Dies soll allerdings nicht nur ein Hinweis sein, sondern auch als
Einladung aufgefasst werden, uns Fehler (und Erfolgsgeschichten!) zu
melden und bei uns mitzumachen, um Guix zu verbessern. Siehe den
Abschnitt *note Mitwirken::.


File: guix.de.info,  Node: Hardware-Überlegungen,  Next: Installation von USB-Stick oder DVD,  Prev: Einschränkungen,  Up: Systeminstallation

3.2 Hardware-Überlegungen
=========================

GNU Guix legt den Fokus darauf, die Freiheit des Nutzers auf seinem
Rechner zu respektieren. Es baut auf Linux-libre als Kernel auf, wodurch
nur Hardware unterstützt wird, für die Treiber und Firmware existieren,
die freie Software sind. Heutzutage wird ein großer Teil der
handelsüblichen Hardware von GNU/Linux-libre unterstützt — von
Tastaturen bis hin zu Grafikkarten, Scannern und Ethernet-Adaptern.
Leider gibt es noch Bereiche, wo die Hardwareanbieter ihren Nutzern die
Kontrolle über ihren eigenen Rechner verweigern. Solche Hardware wird
von Guix System nicht unterstützt.

   Einer der wichtigsten Bereiche, wo es an freien Treibern und freier
Firmware mangelt, sind WLAN-Geräte. WLAN-Geräte, von denen wir wissen,
dass sie funktionieren, sind unter anderem solche, die die Atheros-Chips
AR9271 und AR7010 verbauen, welche der Linux-libre-Treiber ‘ath9k’
unterstützt, und die, die Broadcom/AirForce-Chips BCM43xx (mit
Wireless-Core Revision 5) verbauen, welche der Linux-libre-Treiber
‘b43-open’ unterstützt. Freie Firmware gibt es für beide und sie wird
von Haus aus mit Guix System als ein Teil von ‘%base-firmware’
mitgeliefert (siehe *note ‘firmware’: „operating-system“-Referenz.).

   Die Free Software Foundation (https://www.fsf.org/) betreibt
“Respects Your Freedom” (https://www.fsf.org/ryf) (RYF), ein
Zertifizierungsprogramm für Hardware-Produkte, die Ihre Freiheit
respektieren, Datenschutz gewährleisten und sicherstellen, dass Sie die
Kontrolle über Ihr Gerät haben. Wir ermutigen Sie dazu, die Liste
RYF-zertifizierter Geräte zu beachten.

   Eine weitere nützliche Ressource ist die Website H-Node
(https://h-node.org/home/index/de). Dort steht ein Katalog von
Hardware-Geräten mit Informationen darüber, wie gut sie von GNU/Linux
unterstützt werden.


File: guix.de.info,  Node: Installation von USB-Stick oder DVD,  Next: Vor der Installation,  Prev: Hardware-Überlegungen,  Up: Systeminstallation

3.3 Installation von USB-Stick oder DVD
=======================================

Sie können ein ISO-9660-Installationsabbild von
‘https://ftp.gnu.org/gnu/guix/guix-system-install-1.1.0.411-5c10d.SYSTEM.iso.xz’
herunterladen, dass Sie auf einen USB-Stick aufspielen oder auf eine DVD
brennen können, wobei Sie für SYSTEM eines der folgenden schreiben
müssen:

‘x86_64-linux’
     für ein GNU/Linux-System auf Intel/AMD-kompatiblen
     64-Bit-Prozessoren,

‘i686-linux’
     für ein 32-Bit-GNU/Linux-System auf Intel-kompatiblen Prozessoren.

   Laden Sie auch die entsprechende ‘.sig’-Datei herunter und
verifizieren Sie damit die Authentizität Ihres Abbilds, indem Sie diese
Befehle eingeben:

     $ wget https://ftp.gnu.org/gnu/guix/guix-system-install-1.1.0.411-5c10d.SYSTEM.iso.xz.sig
     $ gpg --verify guix-system-install-1.1.0.411-5c10d.SYSTEM.iso.xz.sig

   Falls dieser Befehl fehlschlägt, weil Sie nicht über den nötigen
öffentlichen Schlüssel verfügen, können Sie ihn mit diesem Befehl
importieren:

     $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
           -qO - | gpg --import -

und den Befehl ‘gpg --verify’ erneut ausführen.

   Beachten Sie, dass eine Warnung wie „Dieser Schlüssel trägt keine
vertrauenswürdige Signatur!“ normal ist.

   Dieses Abbild enthält die Werkzeuge, die Sie zur Installation
brauchen. Es ist dafür gedacht, _so wie es ist_ auf einen hinreichend
großen USB-Stick oder eine DVD kopiert zu werden.

Kopieren auf einen USB-Stick
----------------------------

Um das Abbild auf einen USB-Stick zu kopieren, führen Sie folgende
Schritte durch:

  1. Entpacken Sie das Abbild mit dem ‘xz’-Befehl:

          xz -d guix-system-install-1.1.0.411-5c10d.SYSTEM.iso.xz

  2. Stecken Sie einen USB-Stick in Ihren Rechner ein, der mindestens
     1 GiB groß ist, und bestimmen Sie seinen Gerätenamen. Ist der
     Gerätename des USB-Sticks ‘/dev/sdX’, dann kopieren Sie das Abbild
     mit dem Befehl:

          dd if=guix-system-install-1.1.0.411-5c10d.SYSTEM.iso of=/dev/sdX
          sync

     Sie benötigen in der Regel Administratorrechte, um auf ‘/dev/sdX’
     zuzugreifen.

Auf eine DVD brennen
--------------------

Um das Abbild auf eine DVD zu kopieren, führen Sie diese Schritte durch:

  1. Entpacken Sie das Abbild mit dem ‘xz’-Befehl:

          xz -d guix-system-install-1.1.0.411-5c10d.SYSTEM.iso.xz

  2. Legen Sie eine unbespielte DVD in Ihren Rechner ein und bestimmen
     Sie ihren Gerätenamen. Angenommen der Name des DVD-Laufwerks ist
     ‘/dev/srX’, kopieren Sie das Abbild mit:

          growisofs -dvd-compat -Z /dev/srX=guix-system-install-1.1.0.411-5c10d.SYSTEM.iso

     Der Zugriff auf ‘/dev/srX’ setzt in der Regel Administratorrechte
     voraus.

Das System starten
------------------

Sobald das erledigt ist, sollten Sie Ihr System neu starten und es vom
USB-Stick oder der DVD hochfahren („booten“) können. Dazu müssen Sie
wahrscheinlich beim Starten des Rechners in das BIOS- oder
UEFI-Boot-Menü gehen, von wo aus Sie auswählen können, dass vom
USB-Stick gebootet werden soll. Um aus Libreboot heraus zu booten,
wechseln Sie in den Befehlsmodus, indem Sie die ‘c’-Taste drücken, und
geben Sie ‘search_grub usb’ ein.

   Lesen Sie den Abschnitt *note Guix in einer VM installieren::, wenn
Sie Guix System stattdessen in einer virtuellen Maschine (VM)
installieren möchten.


File: guix.de.info,  Node: Vor der Installation,  Next: Geführte grafische Installation,  Prev: Installation von USB-Stick oder DVD,  Up: Systeminstallation

3.4 Vor der Installation
========================

Wenn Sie Ihren Rechner gebootet haben, können Sie sich vom grafischen
Installationsprogramm durch den Installationsvorgang führen lassen, was
den Einstieg leicht macht (siehe *note Geführte grafische
Installation::). Alternativ können Sie sich auch für einen „manuellen“
Installationsvorgang entscheiden, wenn Sie bereits mit GNU/Linux
vertraut sind und mehr Kontrolle haben möchten, als sie das grafische
Installationsprogramm bietet (siehe *note Manuelle Installation::).

   Das grafische Installationsprogramm steht Ihnen auf TTY1 zur
Verfügung. Auf den TTYs 3 bis 6 können Sie vor sich eine
Eingabeaufforderung für den Administratornutzer „root“ sehen, nachdem
Sie ‘strg-alt-f3’, ‘strg-alt-f4’ usw. gedrückt haben. TTY2 zeigt Ihnen
dieses Handbuch, das Sie über die Tastenkombination ‘strg-alt-f2’
erreichen. In dieser Dokumentation können Sie mit den Steuerungsbefehlen
Ihres Info-Betrachters blättern (siehe *note (info-stnd)Top::). Auf dem
Installationssystem läuft der GPM-Maus-Daemon, wodurch Sie Text mit der
linken Maustaste markieren und ihn mit der mittleren Maustaste einfügen
können.

     Anmerkung: Für die Installation benötigen Sie Zugang zum Internet,
     damit fehlende Abhängigkeiten Ihrer Systemkonfiguration
     heruntergeladen werden können. Im Abschnitt „Netzwerkkonfiguration“
     weiter unten finden Sie mehr Informationen dazu.


File: guix.de.info,  Node: Geführte grafische Installation,  Next: Manuelle Installation,  Prev: Vor der Installation,  Up: Systeminstallation

3.5 Geführte grafische Installation
===================================

Das grafische Installationsprogramm ist mit einer textbasierten
Benutzeroberfläche ausgestattet. Es kann Sie mit Dialogfeldern durch die
Schritte führen, mit denen Sie GNU Guix System installieren.

   Die ersten Dialogfelder ermöglichen es Ihnen, das System aufzusetzen,
wie Sie es bei der Installation benutzen: Sie können die Sprache und
Tastaturbelegung festlegen und die Netzwerkanbindung einrichten, die
während der Installation benutzt wird. Das folgende Bild zeigt den
Dialog zur Einrichtung der Netzwerkanbindung.

 [image src="images/installer-network.png" alt="Netzwerkanbindung einrichten mit dem
grafischen Installationsprogramm" ]

   Mit den danach kommenden Schritten können Sie Ihre Festplatte
partitionieren, wie im folgenden Bild gezeigt, und auswählen, ob Ihre
Dateisysteme verschlüsselt werden sollen oder nicht. Sie können Ihren
Rechnernamen und das Administratorpasswort (das „root“-Passwort)
festlegen und ein Benutzerkonto einrichten, und noch mehr.

 [image src="images/installer-partitions.png" alt="Partitionieren mit dem grafischen
Installationsprogramm" ]

   Beachten Sie, dass Sie mit dem Installationsprogramm jederzeit den
aktuellen Installationsschritt verlassen und zu einem vorherigen Schritt
zurückkehren können, wie Sie im folgenden Bild sehen können.

 [image src="images/installer-resume.png" alt="Mit einem Installationsschritt
fortfahren" ]

   Sobald Sie fertig sind, erzeugt das Installationsprogramm eine
Betriebssystemkonfiguration und zeigt sie an (siehe *note Das
Konfigurationssystem nutzen::). Zu diesem Zeitpunkt können Sie auf „OK“
drücken und die Installation wird losgehen. Ist sie erfolgreich, können
Sie neu starten und Ihr neues System genießen. Siehe *note Nach der
Systeminstallation:: für Informationen, wie es weitergeht!


File: guix.de.info,  Node: Manuelle Installation,  Next: Nach der Systeminstallation,  Prev: Geführte grafische Installation,  Up: Systeminstallation

3.6 Manuelle Installation
=========================

Dieser Abschnitt beschreibt, wie Sie GNU Guix System auf manuelle Weise
auf Ihrer Maschine installieren. Diese Alternative setzt voraus, dass
Sie bereits mit GNU/Linux, der Shell und üblichen
Administrationswerkzeugen vertraut sind. Wenn Sie glauben, dass das
nichts für Sie ist, dann möchten Sie vielleicht das geführte grafische
Installationsprogramm benutzen (siehe *note Geführte grafische
Installation::).

   Das Installationssystem macht Eingabeaufforderungen auf den TTYs 3
bis 6 zugänglich, auf denen Sie als Administratornutzer Befehle eingeben
können; Sie erreichen diese, indem Sie die Tastenkombinationen
‘strg-alt-f3’, ‘strg-alt-f4’ und so weiter benutzen. Es enthält viele
übliche Werkzeuge, mit denen Sie diese Aufgabe bewältigen können. Da es
sich auch um ein vollständiges „Guix System“-System handelt, können Sie
aber auch andere Pakete mit dem Befehl ‘guix package’ nachinstallieren,
wenn Sie sie brauchen (siehe *note Aufruf von guix package::).

* Menu:

* Tastaturbelegung und Netzwerkanbindung und Partitionierung::  Erstes
                                                                  Einrichten.
* Fortfahren mit der Installation::  Installieren.


File: guix.de.info,  Node: Tastaturbelegung und Netzwerkanbindung und Partitionierung,  Next: Fortfahren mit der Installation,  Up: Manuelle Installation

3.6.1 Tastaturbelegung, Netzwerkanbindung und Partitionierung
-------------------------------------------------------------

Bevor Sie das System installieren können, wollen Sie vielleicht die
Tastaturbelegung ändern, eine Netzwerkverbindung herstellen und die
Zielfestplatte partitionieren. Dieser Abschnitt wird Sie durch diese
Schritte führen.

3.6.1.1 Tastaturbelegung
........................

Das Installationsabbild verwendet die US-amerikanische
QWERTY-Tastaturbelegung. Wenn Sie dies ändern möchten, können Sie den
‘loadkeys’-Befehl benutzen. Mit folgendem Befehl würden Sie zum Beispiel
die Dvorak-Tastaturbelegung auswählen:

     loadkeys dvorak

   Schauen Sie sich an, welche Dateien im Verzeichnis
‘/run/current-system/profile/share/keymaps’ stehen, um eine Liste
verfügbarer Tastaturbelegungen zu sehen. Wenn Sie mehr Informationen
brauchen, führen Sie ‘man loadkeys’ aus.

3.6.1.2 Netzwerkkonfiguration
.............................

Führen Sie folgenden Befehl aus, um zu sehen, wie Ihre
Netzwerkschnittstellen benannt sind:

     ifconfig -a

… oder mit dem GNU/Linux-eigenen ‘ip’-Befehl:

     ip address

   Der Name kabelgebundener Schnittstellen (engl. Interfaces) beginnt
mit dem Buchstaben ‘e’, zum Beispiel heißt die dem ersten fest
eingebauten Ethernet-Adapter entsprechende Schnittstelle ‘eno1’.
Drahtlose Schnittstellen werden mit einem Namen bezeichnet, der mit dem
Buchstaben ‘w’ beginnt, etwa ‘w1p2s0’.

Kabelverbindung
     Um ein kabelgebundenes Netzwerk einzurichten, führen Sie den
     folgenden Befehl aus, wobei Sie statt SCHNITTSTELLE den Namen der
     kabelgebundenen Schnittstelle eintippen, die Sie benutzen möchten.

          ifconfig SCHNITTSTELLE up

     … oder mit dem GNU/Linux-eigenen ‘ip’-Befehl:

          ip link set SCHNITTSTELLE up

Drahtlose Verbindung
     Um Drahtlosnetzwerke einzurichten, können Sie eine
     Konfigurationsdatei für das Konfigurationswerkzeug des
     ‘wpa_supplicant’ schreiben (wo Sie sie speichern, ist nicht
     wichtig), indem Sie eines der verfügbaren Textbearbeitungsprogramme
     wie etwa ‘nano’ benutzen:

          nano wpa_supplicant.conf

     Zum Beispiel können Sie die folgende Formulierung in der Datei
     speichern, die für viele Drahtlosnetzwerke funktioniert, sofern Sie
     die richtige SSID und Passphrase für das Netzwerk eingeben, mit dem
     Sie sich verbinden möchten:

          network={
            ssid="MEINE-SSID"
            key_mgmt=WPA-PSK
            psk="geheime Passphrase des Netzwerks"
          }

     Starten Sie den Dienst für Drahtlosnetzwerke und lassen Sie ihn im
     Hintergrund laufen, indem Sie folgenden Befehl eintippen (ersetzen
     Sie dabei SCHNITTSTELLE durch den Namen der Netzwerkschnittstelle,
     die Sie benutzen möchten):

          wpa_supplicant -c wpa_supplicant.conf -i SCHNITTSTELLE -B

     Führen Sie ‘man wpa_supplicant’ aus, um mehr Informationen zu
     erhalten.

   Zu diesem Zeitpunkt müssen Sie sich eine IP-Adresse beschaffen. Auf
einem Netzwerk, wo IP-Adressen automatisch via DHCP zugewiesen werden,
können Sie das hier ausführen:

     dhclient -v SCHNITTSTELLE

   Versuchen Sie, einen Server zu pingen, um zu prüfen, ob sie mit dem
Internet verbunden sind und alles richtig funktioniert:

     ping -c 3 gnu.org

   Einen Internetzugang herzustellen, ist in jedem Fall nötig, weil das
Abbild nicht alle Software und Werkzeuge enthält, die nötig sein
könnten.

   Wenn HTTP- und HTTPS-Zugriffe bei Ihnen über einen Proxy laufen
sollen, führen Sie folgenden Befehl aus:

     herd set-http-proxy guix-daemon URL

Dabei ist URL die URL des Proxys, zum Beispiel
‘http://example.org:8118’.

   Wenn Sie möchten, können Sie die weitere Installation auch per
Fernwartung durchführen, indem Sie einen SSH-Server starten:

     herd start ssh-daemon

   Vergewissern Sie sich vorher, dass Sie entweder ein Passwort mit
‘passwd’ festgelegt haben, oder dass Sie für OpenSSH eine
Authentifizierung über öffentliche Schlüssel eingerichtet haben, bevor
Sie sich anmelden.

3.6.1.3 Plattenpartitionierung
..............................

Sofern nicht bereits geschehen, ist der nächste Schritt, zu
partitionieren und dann die Zielpartition zu formatieren.

   Auf dem Installationsabbild sind mehrere Partitionierungswerkzeuge zu
finden, einschließlich (siehe *note (parted)Overview::), ‘fdisk’ und
‘cfdisk’. Starten Sie eines davon und partitionieren Sie Ihre Festplatte
oder sonstigen Massenspeicher, wie Sie möchten:

     cfdisk

   Wenn Ihre Platte mit einer „GUID Partition Table“ (GPT) formatiert
ist, und Sie vorhaben, die BIOS-basierte Variante des GRUB-Bootloaders
zu installieren (was der Vorgabe entspricht), stellen Sie sicher, dass
eine Partition als BIOS-Boot-Partition ausgewiesen ist (siehe *note
(grub)BIOS installation::).

   Falls Sie stattdessen einen EFI-basierten GRUB installieren möchten,
muss auf der Platte eine FAT32-formatierte “EFI-Systempartition” (ESP)
vorhanden sein. Diese Partition kann unter dem Pfad ‘/boot/efi’
eingebunden („gemountet“) werden und die ‘esp’-Flag der Partition muss
gesetzt sein. Dazu würden Sie beispielsweise in ‘parted’ eintippen:

     parted /dev/sda set 1 esp on

     Anmerkung: Falls Sie nicht wissen, ob Sie einen EFI- oder
     BIOS-basierten GRUB installieren möchten: Wenn bei Ihnen das
     Verzeichnis ‘/sys/firmware/efi’ im Dateisystem existiert, möchten
     Sie vermutlich eine EFI-Installation durchführen, wozu Sie in Ihrer
     Konfiguration ‘grub-efi-bootloader’ benutzen. Ansonsten sollten Sie
     den BIOS-basierten GRUB benutzen, der mit ‘grub-bootloader’
     bezeichnet wird. Siehe *note Bootloader-Konfiguration::, wenn Sie
     mehr Informationen über Bootloader brauchen.

   Sobald Sie die Platte fertig partitioniert haben, auf die Sie
installieren möchten, müssen Sie ein Dateisystem auf Ihrer oder Ihren
für Guix System vorgesehenen Partition(en) erzeugen(1). Wenn Sie eine
ESP brauchen und dafür die Partition ‘/dev/sda1’ vorgesehen haben,
müssen Sie diesen Befehl ausführen:

     mkfs.fat -F32 /dev/sda1

   Geben Sie Ihren Dateisystemen auch besser eine Bezeichnung („Label“),
damit Sie sie zuverlässig wiedererkennen und später in den
‘file-system’-Deklarationen darauf Bezug nehmen können (siehe *note
Dateisysteme::). Dazu benutzen Sie typischerweise die
Befehlszeilenoption ‘-L’ des Befehls ‘mkfs.ext4’ oder entsprechende
Optionen für andere Befehle. Wenn wir also annehmen, dass ‘/dev/sda2’
die Partition ist, auf der Ihr Wurzeldateisystem (englisch „root“)
wohnen soll, können Sie dort mit diesem Befehl ein Dateisystem mit der
Bezeichnung ‘my-root’ erstellen:

     mkfs.ext4 -L my-root /dev/sda2

   Falls Sie aber vorhaben, die Partition mit dem Wurzeldateisystem zu
verschlüsseln, können Sie dazu die Cryptsetup-/LUKS-Werkzeuge verwenden
(siehe ‘man cryptsetup’, um mehr darüber zu erfahren). Angenommen Sie
wollen die Partition für das Wurzeldateisystem verschlüsselt auf
‘/dev/sda2’ installieren, dann brauchen Sie eine Befehlsfolge ähnlich
wie diese:

     cryptsetup luksFormat /dev/sda2
     cryptsetup open --type luks /dev/sda2 my-partition
     mkfs.ext4 -L my-root /dev/mapper/my-partition

   Sobald das erledigt ist, binden Sie dieses Dateisystem als
Installationsziel mit dem Einhängepunkt ‘/mnt’ ein, wozu Sie einen
Befehl wie hier eintippen (auch hier unter der Annahme, dass ‘my-root’
die Bezeichnung des künftigen Wurzeldateisystems ist):

     mount LABEL=my-root /mnt

   Binden Sie auch alle anderen Dateisysteme ein, die Sie auf dem
Zielsystem benutzen möchten, mit Einhängepunkten relativ zu diesem Pfad.
Wenn Sie sich zum Beispiel für einen Einhängepunkt ‘/boot/efi’ für die
EFI-Systempartition entschieden haben, binden Sie sie jetzt als
‘/mnt/boot/efi’ ein, damit ‘guix system init’ sie später findet.

   Wenn Sie zudem auch vorhaben, eine oder mehrere Swap-Partitionen zu
benutzen (siehe *note swap space: (libc)Memory Concepts.),
initialisieren Sie diese nun mit ‘mkswap’. Angenommen Sie haben eine
Swap-Partition auf ‘/dev/sda3’, dann würde der Befehl so lauten:

     mkswap /dev/sda3
     swapon /dev/sda3

   Alternativ können Sie eine Swap-Datei benutzen. Angenommen, Sie
wollten die Datei ‘/swapdatei’ im neuen System als eine Swapdatei
benutzen, dann müssten Sie Folgendes ausführen(2):

     # Das bedeutet 10 GiB Swapspeicher. "count" anpassen zum ändern.
     dd if=/dev/zero of=/mnt/swapfile bs=1MiB count=10240
     # Zur Sicherheit darf nur der Administrator lesen und schreiben.
     chmod 600 /mnt/swapfile
     mkswap /mnt/swapfile
     swapon /mnt/swapfile

   Bedenken Sie, dass, wenn Sie die Partition für das Wurzeldateisystem
(„root“) verschlüsselt und eine Swap-Datei in diesem Dateisystem wie
oben beschrieben erstellt haben, die Verschlüsselung auch die Swap-Datei
schützt, genau wie jede andere Datei in dem Dateisystem.

   ---------- Footnotes ----------

   (1) Derzeit unterstützt Guix System nur die Dateisystemtypen ext4,
btrfs und JFS. Insbesondere funktioniert Guix-Code, der
Dateisystem-UUIDs und -Labels ausliest, nur auf diesen Dateisystemtypen.

   (2) Dieses Beispiel wird auf vielen Arten von Dateisystemen
funktionieren (z.B. auf ext4). Auf Dateisystemen mit Copy-on-Write (wie
z.B. btrfs) können sich die nötigen Schritte unterscheiden. Details
finden Sie in der Dokumentation auf den Handbuchseiten von ‘mkswap’ und
‘swapon’.


File: guix.de.info,  Node: Fortfahren mit der Installation,  Prev: Tastaturbelegung und Netzwerkanbindung und Partitionierung,  Up: Manuelle Installation

3.6.2 Fortfahren mit der Installation
-------------------------------------

Wenn die Partitionen des Installationsziels bereit sind und dessen
Wurzeldateisystem unter ‘/mnt’ eingebunden wurde, kann es losgehen mit
der Installation. Führen Sie zuerst aus:

     herd start cow-store /mnt

   Dadurch wird ‘/gnu/store’ copy-on-write, d.h. dorthin von Guix
erstellte Pakete werden in ihrer Installationsphase auf dem unter ‘/mnt’
befindlichen Zieldateisystem gespeichert, statt den Arbeitsspeicher
auszulasten. Das ist nötig, weil die erste Phase des Befehls ‘guix
system init’ (siehe unten) viele Dateien nach ‘/gnu/store’ herunterlädt
oder sie erstellt, Änderungen am ‘/gnu/store’ aber bis dahin wie das
übrige Installationssystem nur im Arbeitsspeicher gelagert werden
konnten.

   Als Nächstes müssen Sie eine Datei bearbeiten und dort eine
Deklaration des Betriebssystems, das Sie installieren möchten,
hineinschreiben. Zu diesem Zweck sind im Installationssystem drei
Texteditoren enthalten. Wir empfehlen, dass Sie GNU nano benutzen (siehe
*note (nano)Top::), welcher Syntax und zueinander gehörende Klammern
hervorheben kann. Andere mitgelieferte Texteditoren, die Sie benutzen
können, sind GNU Zile (ein Emacs-Klon) und nvi (ein Klon des
ursprünglichen ‘vi’-Editors von BSD). Wir empfehlen sehr, dass Sie diese
Datei im Zieldateisystem der Installation speichern, etwa als
‘/mnt/etc/config.scm’, weil Sie Ihre Konfigurationsdatei im frisch
installierten System noch brauchen werden.

   Der Abschnitt *note Das Konfigurationssystem nutzen:: gibt einen
Überblick über die Konfigurationsdatei. Die in dem Abschnitt
diskutierten Beispielkonfigurationen sind im Installationsabbild im
Verzeichnis ‘/etc/configuration’ zu finden. Um also mit einer
Systemkonfiguration anzufangen, die einen grafischen Anzeigeserver
(einen „Display-Server“ zum Darstellen einer „Desktop“-Arbeitsumgebung)
bietet, könnten Sie so etwas ausführen:

     # mkdir /mnt/etc
     # cp /etc/configuration/desktop.scm /mnt/etc/config.scm
     # nano /mnt/etc/config.scm

   Achten Sie darauf, was in Ihrer Konfigurationsdatei steht, und
besonders auf Folgendes:

   • Ihre ‘bootloader-configuration’-Form muss sich auf dasjenige Ziel
     beziehen, auf das Sie GRUB installieren möchten. Sie sollte genau
     dann ‘grub-bootloader’ nennen, wenn Sie GRUB im alten BIOS-Modus
     installieren, und für neuere UEFI-Systeme sollten Sie
     ‘grub-efi-bootloader’ nennen. Bei Altsystemen bezeichnet das
     ‘target’-Feld ein Gerät wie ‘/dev/sda’, bei UEFI-Systemen
     bezeichnet es den Pfad zu einer eingebundenen EFI-Partition wie
     ‘/boot/efi’; stellen Sie sicher, dass die ESP tatsächlich dort
     eingebunden ist und ein ‘file-system’-Eintrag dafür in Ihrer
     Konfiguration festgelegt wurde.

   • Dateisystembezeichnungen müssen mit den jeweiligen ‘device’-Feldern
     in Ihrer ‘file-system’-Konfiguration übereinstimmen, sofern Sie in
     Ihrer ‘file-system’-Konfiguration die Prozedur ‘file-system-label’
     für ihre ‘device’-Felder benutzen.

   • Gibt es verschlüsselte Partitionen oder RAID-Partitionen, dann
     müssen sie im ‘mapped-devices’-Feld genannt werden (siehe *note
     Zugeordnete Geräte::).

   Wenn Sie damit fertig sind, Ihre Konfigurationsdatei vorzubereiten,
können Sie das neue System initialisieren (denken Sie daran, dass
zukünftige Wurzeldateisystem muss unter ‘/mnt’ wie bereits beschrieben
eingebunden sein):

     guix system init /mnt/etc/config.scm /mnt

Dies kopiert alle notwendigen Dateien und installiert GRUB auf
‘/dev/sdX’, sofern Sie nicht noch die Befehlszeilenoption
‘--no-bootloader’ benutzen. Weitere Informationen finden Sie im
Abschnitt *note Aufruf von guix system::. Der Befehl kann das
Herunterladen oder Erstellen fehlender Softwarepakete auslösen, was
einige Zeit in Anspruch nehmen kann.

   Sobald der Befehl erfolgreich — hoffentlich! — durchgelaufen ist,
können Sie mit dem Befehl ‘reboot’ das neue System booten lassen. Der
Administratornutzer ‘root’ hat im neuen System zunächst ein leeres
Passwort, und Passwörter der anderen Nutzer müssen Sie später setzen,
indem Sie den Befehl ‘passwd’ als ‘root’ ausführen, außer Ihre
Konfiguration enthält schon Passwörter (siehe *note Passwörter für
Benutzerkonten: user-account-password.). Siehe *note Nach der
Systeminstallation:: für Informationen, wie es weiter geht!


File: guix.de.info,  Node: Nach der Systeminstallation,  Next: Guix in einer VM installieren,  Prev: Manuelle Installation,  Up: Systeminstallation

3.7 Nach der Systeminstallation
===============================

Sie haben es geschafft: Sie haben Guix System erfolgreich gebootet! Von
jetzt an können Sie Guix System aktualisieren, wann Sie möchten, indem
Sie zum Beispiel das hier ausführen:

     guix pull
     sudo guix system reconfigure /etc/config.scm

Dadurch wird eine neue Systemgeneration aus den neuesten Paketen und
Diensten erstellt (siehe *note Aufruf von guix system::). Wir empfehlen,
diese Schritte regelmäßig zu wiederholen, damit Ihr System die aktuellen
Sicherheitsaktualisierungen benutzt (siehe *note
Sicherheitsaktualisierungen::).

     Anmerkung: Beachten Sie, dass bei Nutzung von ‘sudo guix’ der
     ‘guix’-Befehl des aktiven Benutzers ausgeführt wird und _nicht_ der
     des Administratornutzers „root“, weil ‘sudo’ die Umgebungsvariable
     ‘PATH’ unverändert lässt. Um ausdrücklich das ‘guix’-Programm des
     Administrators aufzurufen, müssen Sie ‘sudo -i guix …’ eintippen.

     Das macht hier einen Unterschied, weil ‘guix pull’ den
     ‘guix’-Befehl und Paketdefinitionen nur für dasjenige Benutzerkonto
     aktualisiert, mit dem es ausgeführt wird. Würden Sie stattdessen in
     der Anmelde-Shell des „root“-Nutzers ‘guix system reconfigure’
     ausführen, müssten Sie auch für ihn ‘guix pull’ ausführen.

   Besuchen Sie uns auf ‘#guix’ auf dem Freenode-IRC-Netzwerk oder auf
der Mailing-Liste ‘guix-devel@gnu.org’, um uns Rückmeldung zu geben!


File: guix.de.info,  Node: Guix in einer VM installieren,  Next: Ein Abbild zur Installation erstellen,  Prev: Nach der Systeminstallation,  Up: Systeminstallation

3.8 Guix in einer virtuellen Maschine installieren
==================================================

Wenn Sie Guix System auf einer virtuellen Maschine (VM) oder einem
„Virtual Private Server“ (VPS) statt auf Ihrer echten Maschine
installieren möchten, ist dieser Abschnitt hier richtig für Sie.

   Um eine virtuelle Maschine für QEMU (https://qemu.org/) aufzusetzen,
mit der Sie Guix System in ein „Disk-Image“ installieren können (also in
eine Datei mit einem Abbild eines Plattenspeichers), gehen Sie so vor:

  1. Zunächst laden Sie das Installationsabbild des Guix-Systems wie
     zuvor beschrieben herunter und entpacken es (siehe *note
     Installation von USB-Stick oder DVD::).

  2. Legen Sie nun ein Disk-Image an, das das System nach der
     Installation enthalten soll. Um ein qcow2-formatiertes Disk-Image
     zu erstellen, benutzen Sie den Befehl ‘qemu-img’:

          qemu-img create -f qcow2 guix-system.img 50G

     Die Datei, die Sie herausbekommen, wird wesentlich kleiner als 50
     GB sein (typischerweise kleiner als 1 MB), vergrößert sich aber,
     wenn der virtualisierte Speicher gefüllt wird.

  3. Starten Sie das USB-Installationsabbild auf einer virtuellen
     Maschine:

          qemu-system-x86_64 -m 1024 -smp 1 -enable-kvm \
            -nic user,model=virtio-net-pci -boot menu=on,order=d \
            -drive file=guix-system.img \
            -drive media=cdrom,file=guix-system-install-1.1.0.411-5c10d.SYSTEM.iso

     ‘-enable-kvm’ ist optional, verbessert die Rechenleistung aber
     erheblich, siehe *note Guix in einer VM starten::.

  4. Sie sind nun in der virtuellen Maschine als Administratornutzer
     ‘root’ angemeldet und können mit der Installation wie gewohnt
     fortfahren. Folgen Sie der Anleitung im Abschnitt *note Vor der
     Installation::.

   Wurde die Installation abgeschlossen, können Sie das System starten,
das sich nun als Abbild in der Datei ‘guix-system.img’ befindet. Der
Abschnitt *note Guix in einer VM starten:: erklärt, wie Sie das tun
können.


File: guix.de.info,  Node: Ein Abbild zur Installation erstellen,  Prev: Guix in einer VM installieren,  Up: Systeminstallation

3.9 Ein Abbild zur Installation erstellen
=========================================

Das oben beschriebene Installationsabbild wurde mit dem Befehl ‘guix
system’ erstellt, genauer gesagt mit:

     guix system disk-image --file-system-type=iso9660 \
       gnu/system/install.scm

   Die Datei ‘gnu/system/install.scm’ finden Sie im Quellbaum von Guix.
Schauen Sie sich die Datei und auch den Abschnitt *note Aufruf von guix
system:: an, um mehr Informationen über das Installationsabbild zu
erhalten.

3.10 Abbild zur Installation für ARM-Rechner erstellen
======================================================

Viele ARM-Chips funktionieren nur mit ihrer eigenen speziellen Variante
des U-Boot-Bootloaders (https://www.denx.de/wiki/U-Boot/).

   Wenn Sie ein Disk-Image erstellen und der Bootloader nicht
anderweitig schon installiert ist (auf einem anderen Laufwerk), ist es
ratsam, ein Disk-Image zu erstellen, was den Bootloader enthält, mit dem
Befehl:

     guix system disk-image --system=armhf-linux -e '((@ (gnu system install) os-with-u-boot) (@ (gnu system install) installation-os) "A20-OLinuXino-Lime2")'

   ‘A20-OLinuXino-Lime2’ ist der Name des Chips. Wenn Sie einen
ungültigen Namen eingeben, wird eine Liste möglicher Chip-Namen
ausgegeben.


File: guix.de.info,  Node: Paketverwaltung,  Next: Entwicklung,  Prev: Systeminstallation,  Up: Top

4 Paketverwaltung
*****************

Der Zweck von GNU Guix ist, Benutzern die leichte Installation,
Aktualisierung und Entfernung von Software-Paketen zu ermöglichen, ohne
dass sie ihre Erstellungsprozeduren oder Abhängigkeiten kennen müssen.
Guix kann natürlich noch mehr als diese offensichtlichen
Funktionalitäten.

   Dieses Kapitel beschreibt die Hauptfunktionalitäten von Guix, sowie
die von Guix angebotenen Paketverwaltungswerkzeuge. Zusätzlich zu den im
Folgenden beschriebenen Befehlszeilen-Benutzerschnittstellen (siehe
*note ‘guix package’: Aufruf von guix package.) können Sie auch mit der
Emacs-Guix-Schnittstelle (siehe *note (emacs-guix)Top::) arbeiten,
nachdem Sie das Paket ‘emacs-guix’ installiert haben (führen Sie zum
Einstieg in Emacs-Guix den Emacs-Befehl ‘M-x guix-help’ aus):

     guix install emacs-guix

* Menu:

* Funktionalitäten::        Wie Guix Ihr Leben schöner machen wird.
* Aufruf von guix package::  Pakete installieren, entfernen usw.
* Substitute::               Vorerstelle Binärdateien herunterladen.
* Pakete mit mehreren Ausgaben.::  Ein Quellpaket, mehrere Ausgaben.
* Aufruf von guix gc::       Den Müllsammler laufen lassen.
* Aufruf von guix pull::     Das neueste Guix samt Distribution laden.
* Kanäle::                  Die Paketsammlung anpassen.
* Aufruf von time-machine::  Alte Guix-Versionen verwenden.
* Untergeordnete::           Mit einer anderen Version von Guix
                               interagieren.
* Aufruf von guix describe::  Informationen über Ihre Guix-Version
                                anzeigen.
* Aufruf von guix archive::  Import und Export von Store-Dateien.


File: guix.de.info,  Node: Funktionalitäten,  Next: Aufruf von guix package,  Up: Paketverwaltung

4.1 Funktionalitäten
====================

Wenn Sie Guix benutzen, landet jedes Paket schließlich im “Paket-Store”
in seinem eigenen Verzeichnis — der Name ist ähnlich wie
‘/gnu/store/xxx-package-1.2’, wobei ‘xxx’ eine Zeichenkette in
Base32-Darstellung ist.

   Statt diese Verzeichnisse direkt anzugeben, haben Nutzer ihr eigenes
“Profil”, welches auf diejenigen Pakete zeigt, die sie tatsächlich
benutzen wollen. Diese Profile sind im Persönlichen Verzeichnis des
jeweiligen Nutzers gespeichert als ‘$HOME/.guix-profile’.

   Zum Beispiel installiert ‘alice’ GCC 4.7.2. Dadurch zeigt dann
‘/home/alice/.guix-profile/bin/gcc’ auf
‘/gnu/store/…-gcc-4.7.2/bin/gcc’. Auf demselben Rechner hat ‘bob’
bereits GCC 4.8.0 installiert. Das Profil von ‘bob’ zeigt dann einfach
weiterhin auf ‘/gnu/store/…-gcc-4.8.0/bin/gcc’ — d.h. beide Versionen
von GCC koexistieren auf demselben System, ohne sich zu stören.

   Der Befehl ‘guix package’ ist das zentrale Werkzeug, um Pakete zu
verwalten (siehe *note Aufruf von guix package::). Es arbeitet auf dem
eigenen Profil jedes Nutzers und kann _mit normalen Benutzerrechten_
ausgeführt werden.

   Der Befehl stellt die offensichtlichen Installations-, Entfernungs-
und Aktualisierungsoperationen zur Verfügung. Jeder Aufruf ist
tatsächlich eine eigene _Transaktion_: Entweder die angegebene Operation
wird erfolgreich durchgeführt, oder gar nichts passiert. Wenn also der
Prozess von ‘guix package’ während der Transaktion beendet wird, oder es
zum Stromausfall während der Transaktion kommt, dann bleibt der alte,
nutzbare Zustands des Nutzerprofils erhalten.

   Zudem kann jede Pakettransaktion _zurückgesetzt_ werden (Rollback).
Wird also zum Beispiel durch eine Aktualisierung eine neue Version eines
Pakets installiert, die einen schwerwiegenden Fehler zur Folge hat,
können Nutzer ihr Profil einfach auf die vorherige Profilinstanz
zurücksetzen, von der sie wissen, dass sie gut lief. Ebenso unterliegt
bei Guix auch die globale Systemkonfiguration transaktionellen
Aktualisierungen und Rücksetzungen (siehe *note Das Konfigurationssystem
nutzen::).

   Alle Pakete im Paket-Store können vom _Müllsammler_ (Garbage
Collector) gelöscht werden. Guix ist in der Lage, festzustellen, welche
Pakete noch durch Benutzerprofile referenziert werden, und entfernt nur
diese, die nachweislich nicht mehr referenziert werden (siehe *note
Aufruf von guix gc::). Benutzer können auch ausdrücklich alte
Generationen ihres Profils löschen, damit die zugehörigen Pakete vom
Müllsammler gelöscht werden können.

   Guix verfolgt einen “rein funktionalen” Ansatz bei der
Paketverwaltung, wie er in der Einleitung beschrieben wurde (siehe *note
Einführung::). Jedes Paketverzeichnis im ‘/gnu/store’ hat einen Hash all
seiner bei der Erstellung benutzten Eingaben im Namen — Compiler,
Bibliotheken, Erstellungs-Skripts etc. Diese direkte Entsprechung
ermöglicht es Benutzern, eine Paketinstallation zu benutzen, die sicher
dem aktuellen Stand ihrer Distribution entspricht. Sie maximiert auch
die “Reproduzierbarkeit der Erstellungen” zu maximieren: Dank der
isolierten Erstellungsumgebungen, die benutzt werden, resultiert eine
Erstellung wahrscheinlich in bitweise identischen Dateien, auch wenn sie
auf unterschiedlichen Maschinen durchgeführt wird (siehe *note
container: Aufruf des guix-daemon.).

   Auf dieser Grundlage kann Guix “transparent Binär- oder Quelldateien
ausliefern”. Wenn eine vorerstellte Binärdatei für ein
‘/gnu/store’-Objekt von einer externen Quelle verfügbar ist — ein
“Substitut” —, lädt Guix sie einfach herunter und entpackt sie,
andernfalls erstellt Guix das Paket lokal aus seinem Quellcode (siehe
*note Substitute::). Weil Erstellungsergebnisse normalerweise Bit für
Bit reproduzierbar sind, müssen die Nutzer den Servern, die Substitute
anbieten, nicht blind vertrauen; sie können eine lokale Erstellung
erzwingen und Substitute _anfechten_ (siehe *note Aufruf von guix
challenge::).

   Kontrolle über die Erstellungsumgebung ist eine auch für Entwickler
nützliche Funktionalität. Der Befehl ‘guix environment’ ermöglicht es
Entwicklern eines Pakets, schnell die richtige Entwicklungsumgebung für
ihr Paket einzurichten, ohne manuell die Abhängigkeiten des Pakets in
ihr Profil installieren zu müssen (siehe *note Aufruf von guix
environment::).

   Ganz Guix und all seine Paketdefinitionen stehen unter
Versionskontrolle und ‘guix pull’ macht es möglich, auf dem Verlauf der
Entwicklung von Guix selbst „in der Zeit zu reisen“ (siehe *note Aufruf
von guix pull::). Dadurch kann eine Instanz von Guix auf einer anderen
Maschine oder zu einem späteren Zeitpunkt genau nachgebildet werden,
wodurch auch _vollständige Software-Umgebungen gänzlich nachgebildet_
werden können, mit genauer “Provenienzverfolgung”, wo diese Software
herkommt.


File: guix.de.info,  Node: Aufruf von guix package,  Next: Substitute,  Prev: Funktionalitäten,  Up: Paketverwaltung

4.2 ‘guix package’ aufrufen
===========================

Der Befehl ‘guix package’ ist ein Werkzeug, womit Nutzer Pakete
installieren, aktualisieren, entfernen und auf vorherige Konfigurationen
zurücksetzen können. Dabei wird nur das eigene Profil des Nutzers
verwendet, und es funktioniert mit normalen Benutzerrechten, ohne
Administratorrechte (siehe *note Funktionalitäten::). Die Syntax ist:

     guix package OPTIONEN

   In erster Linie geben die OPTIONEN an, welche Operationen in der
Transaktion durchgeführt werden sollen. Nach Abschluss wird ein neues
Profil erzeugt, aber vorherige “Generationen” des Profils bleiben
verfügbar, falls der Benutzer auf sie zurückwechseln will.

   Um zum Beispiel ‘lua’ zu entfernen und ‘guile’ und ‘guile-cairo’ in
einer einzigen Transaktion zu installieren:

     guix package -r lua -i guile guile-cairo

   Um es Ihnen einfacher zu machen, bieten wir auch die folgenden
Alias-Namen an:

   • ‘guix search’ ist eine andere Schreibweise für ‘guix package -s’,
   • ‘guix install’ ist eine andere Schreibweise für ‘guix package -i’,
   • ‘guix remove’ ist eine andere Schreibweise für ‘guix package -r’,
   • ‘guix upgrade’ ist eine andere Schreibweise für ‘guix package -u’
   • und ‘guix show’ ist eine andere Schreibweise für ‘guix package
     --show=’.

   Diese Alias-Namen sind weniger ausdrucksstark als ‘guix package’ und
stellen weniger Befehlszeilenoptionen bereit, deswegen werden Sie
vermutlich manchmal ‘guix package’ direkt benutzen wollen.

   ‘guix package’ unterstützt auch ein “deklaratives Vorgehen”, wobei
der Nutzer die genaue Menge an Paketen, die verfügbar sein sollen,
festlegt und über die Befehlszeilenoption ‘--manifest’ übergibt (siehe
*note ‘--manifest’: profile-manifest.).

   Für jeden Benutzer wird automatisch eine symbolische Verknüpfung zu
seinem Standardprofil angelegt als ‘$HOME/.guix-profile’. Diese
symbolische Verknüpfung zeigt immer auf die aktuelle Generation des
Standardprofils des Benutzers. Somit können Nutzer
‘$HOME/.guix-profile/bin’ z.B. zu ihrer Umgebungsvariablen ‘PATH’
hinzufügen. Wenn Sie _nicht_ Guix System benutzen, sollten Sie in
Betracht ziehen, folgende Zeilen zu Ihrem ‘~/.bash_profile’ hinzuzufügen
(siehe *note (bash)Bash Startup Files::), damit in neu erzeugten Shells
alle Umgebungsvariablen richtig definiert werden:

     GUIX_PROFILE="$HOME/.guix-profile" ; \
     source "$HOME/.guix-profile/etc/profile"

   Ist Ihr System für mehrere Nutzer eingerichtet, werden Nutzerprofile
an einem Ort gespeichert, der als “Müllsammlerwurzel” registriert ist,
auf die ‘$HOME/.guix-profile’ zeigt (siehe *note Aufruf von guix gc::).
Dieses Verzeichnis ist normalerweise
‘LOCALSTATEDIR/guix/profiles/per-user/BENUTZER’, wobei LOCALSTATEDIR der
an ‘configure’ als ‘--localstatedir’ übergebene Wert ist und BENUTZER
für den jeweiligen Benutzernamen steht. Das ‘per-user’-Verzeichnis wird
erstellt, wenn ‘guix-daemon’ gestartet wird, und das Unterverzeichnis
BENUTZER wird durch ‘guix package’ erstellt.

   Als OPTIONEN kann vorkommen:

‘--install=PAKET …’
‘-i PAKET …’
     Die angegebenen PAKETe installieren.

     Jedes PAKET kann entweder einfach durch seinen Paketnamen
     aufgeführt werden, wie ‘guile’, oder als Paketname gefolgt von
     einem At-Zeichen @ und einer Versionsnummer, wie ‘guile@1.8.8’ oder
     auch nur ‘guile@1.8’ (in letzterem Fall wird die neueste Version
     mit Präfix ‘1.8’ ausgewählt.)

     Wird keine Versionsnummer angegeben, wird die neueste verfügbare
     Version ausgewählt. Zudem kann im PAKET ein Doppelpunkt auftauchen,
     gefolgt vom Namen einer der Ausgaben des Pakets, wie ‘gcc:doc’ oder
     ‘binutils@2.22:lib’ (siehe *note Pakete mit mehreren Ausgaben.::).
     Pakete mit zugehörigem Namen (und optional der Version) werden
     unter den Modulen der GNU-Distribution gesucht (siehe *note
     Paketmodule::).

     Manchmal haben Pakete “propagierte Eingaben”: Als solche werden
     Abhängigkeiten bezeichnet, die automatisch zusammen mit dem
     angeforderten Paket installiert werden (im Abschnitt *note
     ‘propagated-inputs’ in ‘package’ objects:
     package-propagated-inputs. sind weitere Informationen über
     propagierte Eingaben in Paketdefinitionen zu finden).

     Ein Beispiel ist die GNU-MPC-Bibliothek: Ihre C-Headerdateien
     verweisen auf die der GNU-MPFR-Bibliothek, welche wiederum auf die
     der GMP-Bibliothek verweisen. Wenn also MPC installiert wird,
     werden auch die MPFR- und GMP-Bibliotheken in das Profil
     installiert; entfernt man MPC, werden auch MPFR und GMP entfernt —
     außer sie wurden noch auf andere Art ausdrücklich vom Nutzer
     installiert.

     Abgesehen davon setzen Pakete manchmal die Definition von
     Umgebungsvariablen für ihre Suchpfade voraus (siehe die Erklärung
     von ‘--search-paths’ weiter unten). Alle fehlenden oder womöglich
     falschen Definitionen von Umgebungsvariablen werden hierbei
     gemeldet.

‘--install-from-expression=AUSDRUCK’
‘-e AUSDRUCK’
     Das Paket installieren, zu dem der AUSDRUCK ausgewertet wird.

     Beim AUSDRUCK muss es sich um einen Scheme-Ausdruck handeln, der zu
     einem ‘<package>’-Objekt ausgewertet wird. Diese Option ist
     besonders nützlich, um zwischen gleichnamigen Varianten eines
     Pakets zu unterscheiden, durch Ausdrücke wie ‘(@ (gnu packages
     base) guile-final)’.

     Beachten Sie, dass mit dieser Option die erste Ausgabe des
     angegebenen Pakets installiert wird, was unzureichend sein kann,
     wenn eine bestimmte Ausgabe eines Pakets mit mehreren Ausgaben
     gewünscht ist.

‘--install-from-file=DATEI’
‘-f DATEI’
     Das Paket installieren, zu dem der Code in der DATEI ausgewertet
     wird.

     Zum Beispiel könnte die DATEI eine Definition wie diese enthalten
     (siehe *note Pakete definieren::):

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     Entwickler könnten es für nützlich erachten, eine solche
     ‘guix.scm’-Datei im Quellbaum ihres Projekts abzulegen, mit der
     Zwischenstände der Entwicklung getestet und reproduzierbare
     Erstellungsumgebungen aufgebaut werden können (siehe *note Aufruf
     von guix environment::).

     The FILE may also contain a JSON representation of one or more
     package definitions. Running ‘guix package -f’ on ‘hello.json’ with
     the following contents would result in installing the package
     ‘greeter’ after building ‘myhello’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--remove=PAKET …’
‘-r PAKET …’
     Die angegebenen PAKETe entfernen.

     Wie auch bei ‘--install’ kann jedes PAKET neben dem Paketnamen auch
     eine Versionsnummer und/oder eine Ausgabe benennen. Zum Beispiel
     würde ‘-r glibc:debug’ die ‘debug’-Ausgabe von ‘glibc’ aus dem
     Profil entfernen.

‘--upgrade[=REGEXP …]’
‘-u [REGEXP …]’
     Alle installierten Pakete aktualisieren. Wenn einer oder mehr
     reguläre Ausdrücke (Regexps) angegeben wurden, werden nur
     diejenigen installierten Pakete aktualisiert, deren Name zu einer
     der REGEXPs passt. Siehe auch weiter unten die Befehlszeilenoption
     ‘--do-not-upgrade’.

     Beachten Sie, dass das Paket so auf die neueste Version unter den
     Paketen gebracht wird, die in der aktuell installierten
     Distribution vorliegen. Um jedoch Ihre Distribution zu
     aktualisieren, sollten Sie regelmäßig ‘guix pull’ ausführen (siehe
     *note Aufruf von guix pull::).

‘--do-not-upgrade[=REGEXP …]’
     In Verbindung mit der Befehlszeilenoption ‘--upgrade’, führe
     _keine_ Aktualisierung von Paketen durch, deren Name zum regulären
     Ausdruck REGEXP passt. Um zum Beispiel alle Pakete im aktuellen
     Profil zu aktualisieren mit Ausnahme derer, die „emacs“ im Namen
     haben:

          $ guix package --upgrade . --do-not-upgrade emacs

‘--manifest=DATEI’
‘-m DATEI’
     Erstellt eine neue Generation des Profils aus dem vom Scheme-Code
     in DATEI gelieferten Manifest-Objekt. Wenn diese
     Befehlszeilenoption mehrmals wiederholt angegeben wird, werden die
     Manifeste aneinandergehängt.

     Dadurch könnrn Sie den Inhalt des Profils _deklarieren_, statt ihn
     durch eine Folge von Befehlen wie ‘--install’ u.Ä. zu generieren.
     Der Vorteil ist, dass die DATEI unter Versionskontrolle gestellt
     werden kann, auf andere Maschinen zum Reproduzieren desselben
     Profils kopiert werden kann und Ähnliches.

     Der Code in der DATEI muss ein “Manifest”-Objekt liefern, was
     ungefähr einer Liste von Paketen entspricht:

          (use-package-modules guile emacs)

          (packages->manifest
           (list emacs
                 guile-2.0
                 ;; Eine bestimmte Paketausgabe nutzen.
                 (list guile-2.0 "debug")))

     In diesem Beispiel müssen wir wissen, welche Module die Variablen
     ‘emacs’ und ‘guile-2.0’ definieren, um die richtige Angabe mit
     ‘use-package-modules’ machen zu können, was umständlich sein kann.
     Wir können auch normale Paketnamen angeben und sie durch
     ‘specifications->manifest’ zu den entsprechenden Paketobjekten
     auflösen, zum Beispiel so:

          (specifications->manifest
           '("emacs" "guile@2.2" "guile@2.2:debug"))

‘--roll-back’
     Wechselt zur vorherigen “Generation” des Profils zurück — d.h.
     macht die letzte Transaktion rückgängig.

     In Verbindung mit Befehlszeilenoptionen wie ‘--install’ wird zuerst
     zurückgesetzt, bevor andere Aktionen durchgeführt werden.

     Ein Rücksetzen der ersten Generation, die installierte Pakete
     enthält, wechselt das Profil zur “nullten Generation”, die
     keinerlei Dateien enthält, abgesehen von Metadaten über sich
     selbst.

     Nach dem Zurücksetzen überschreibt das Installieren, Entfernen oder
     Aktualisieren von Paketen vormals zukünftige Generationen, d.h. der
     Verlauf der Generationen eines Profils ist immer linear.

‘--switch-generation=MUSTER’
‘-S MUSTER’
     Wechselt zu der bestimmten Generation, die durch das MUSTER
     bezeichnet wird.

     Als MUSTER kann entweder die Nummer einer Generation oder eine
     Nummer mit vorangestelltem „+“ oder „-“ dienen. Letzteres springt
     die angegebene Anzahl an Generationen vor oder zurück. Zum Beispiel
     kehrt ‘--switch-generation=+1’ nach einem Zurücksetzen wieder zur
     neueren Generation zurück.

     Der Unterschied zwischen ‘--roll-back’ und ‘--switch-generation=-1’
     ist, dass ‘--switch-generation’ keine nullte Generation erzeugen
     wird; existiert die angegebene Generation nicht, bleibt schlicht
     die aktuelle Generation erhalten.

‘--search-paths[=ART]’
     Führe die Definitionen von Umgebungsvariablen auf, in Bash-Syntax,
     die nötig sein könnten, um alle installierten Pakete nutzen zu
     können. Diese Umgebungsvariablen werden benutzt, um die “Suchpfade”
     für Dateien festzulegen, die von einigen installierten Paketen
     benutzt werden.

     Zum Beispiel braucht GCC die Umgebungsvariablen ‘CPATH’ und
     ‘LIBRARY_PATH’, um zu wissen, wo sich im Benutzerprofil Header und
     Bibliotheken befinden (siehe *note (gcc)Environment Variables::).
     Wenn GCC und, sagen wir, die C-Bibliothek im Profil installiert
     sind, schlägt ‘--search-paths’ also vor, diese Variablen jeweils
     auf ‘PROFILE/include’ und ‘PROFILE/lib’ verweisen zu lassen.

     Die typische Nutzung ist, in der Shell diese Variablen zu
     definieren:

          $ eval `guix package --search-paths`

     Als ART kann entweder ‘exact’, ‘prefix’ oder ‘suffix’ gewählt
     werden, wodurch die gelieferten Definitionen der Umgebungsvariablen
     entweder exakt die Einstellungen für Guix meldet, oder sie als
     Präfix oder Suffix an den aktuellen Wert dieser Variablen anhängt.
     Gibt man keine ART an, wird der Vorgabewert ‘exact’ verwendet.

     Diese Befehlszeilenoption kann auch benutzt werden, um die
     _kombinierten_ Suchpfade mehrerer Profile zu berechnen. Betrachten
     Sie dieses Beispiel:

          $ guix package -p foo -i guile
          $ guix package -p bar -i guile-json
          $ guix package -p foo -p bar --search-paths

     Der letzte Befehl oben meldet auch die Definition der
     Umgebungsvariablen ‘GUILE_LOAD_PATH’, obwohl für sich genommen
     weder ‘foo’ noch ‘bar’ zu dieser Empfehlung führen würden.

‘--profile=PROFIL’
‘-p PROFIL’
     Auf PROFIL anstelle des Standardprofils des Benutzers arbeiten.

     Als PROFIL muss der Name einer Datei angegeben werden, die dann
     nach Abschluss der Transaktion erzeugt wird. Konkret wird PROFIL
     nur zu einer symbolischen Verknüpfung („Symlink“) auf das
     eigentliche Profil gemacht, in das Pakete installiert werden.

          $ guix install hello -p ~/code/mein-profil
          …
          $ ~/code/mein-profil/bin/hello
          Hallo, Welt!

     Um das Profil loszuwerden, genügt es, die symbolische Verknüpfung
     und damit einhergehende Verknüpfungen, die auf bestimmte
     Generationen verweisen, zu entfernen:

          $ rm ~/code/mein-profil ~/code/mein-profil-*-link

‘--list-profiles’
     Alle Profile des Benutzers auflisten:

          $ guix package --list-profiles
          /home/charlie/.guix-profile
          /home/charlie/code/my-profile
          /home/charlie/code/devel-profile
          /home/charlie/tmp/test

     Wird es als Administratornutzer „root“ ausgeführt, werden die
     Profile aller Benutzer aufgelistet.

‘--allow-collisions’
     Kollidierende Pakete im neuen Profil zulassen. Benutzung auf eigene
     Gefahr!

     Standardmäßig wird ‘guix package’ “Kollisionen” als Fehler
     auffassen und melden. Zu Kollisionen kommt es, wenn zwei oder mehr
     verschiedene Versionen oder Varianten desselben Pakets im Profil
     landen.

‘--bootstrap’
     Erstellt das Profil mit dem Bootstrap-Guile. Diese Option ist nur
     für Entwickler der Distribution nützlich.

   Zusätzlich zu diesen Aktionen unterstützt ‘guix package’ folgende
Befehlszeilenoptionen, um den momentanen Zustand eines Profils oder die
Verfügbarkeit von Paketen nachzulesen:

‘--search=REGEXP’
‘-s REGEXP’
     Führt alle verfügbaren Pakete auf, deren Name, Zusammenfassung oder
     Beschreibung zum regulären Ausdruck REGEXP passt, ohne Groß- und
     Kleinschreibung zu unterscheiden und sortiert nach ihrer Relevanz.
     Alle Metadaten passender Pakete werden im ‘recutils’-Format
     geliefert (siehe *note GNU recutils databases: (recutils)Top.).

     So können bestimmte Felder mit dem Befehl ‘recsel’ extrahiert
     werden, zum Beispiel:

          $ guix package -s malloc | recsel -p name,version,relevance
          name: jemalloc
          version: 4.5.0
          relevance: 6

          name: glibc
          version: 2.25
          relevance: 1

          name: libgc
          version: 7.6.0
          relevance: 1

     Ebenso kann der Name aller zu den Bedingungen der GNU LGPL, Version
     3, verfügbaren Pakete ermittelt werden:

          $ guix package -s "" | recsel -p name -e 'license ~ "LGPL 3"'
          name: elfutils

          name: gmp
          …

     Es ist auch möglich, Suchergebnisse näher einzuschränken, indem Sie
     ‘-s’ mehrmals an ‘guix package’ übergeben, oder mehrere Argumente
     an ‘guix search’ übergeben. Zum Beispiel liefert folgender Befehl
     eines Liste von Brettspielen:

          $ guix search '\<board\>' game | recsel -p name
          name: gnubg
          …

     Würden wir ‘-s game’ weglassen, bekämen wir auch Software-Pakete
     aufgelistet, die mit „printed circuit boards“ (elektronischen
     Leiterplatten) zu tun haben; ohne die spitzen Klammern um ‘board’
     bekämen wir auch Pakete, die mit „keyboards“ (Tastaturen, oder
     musikalischen Keyboard) zu tun haben.

     Es ist Zeit für ein komplexeres Beispiel. Folgender Befehl sucht
     kryptografische Bibliotheken, filtert Haskell-, Perl-, Python- und
     Ruby-Bibliotheken heraus und gibt Namen und Zusammenfassung
     passender Pakete aus:

          $ guix search crypto library | \
              recsel -e '! (name ~ "^(ghc|perl|python|ruby)")' -p name,synopsis

     Siehe *note (recutils)Selection Expressions::, es enthält weitere
     Informationen über “Auswahlausdrücke” mit ‘recsel -e’.

‘--show=PAKET’
     Zeigt Details über das PAKET aus der Liste verfügbarer Pakete, im
     ‘recutils’-Format (siehe *note GNU recutils databases:
     (recutils)Top.).

          $ guix package --show=python | recsel -p name,version
          name: python
          version: 2.7.6

          name: python
          version: 3.3.5

     Sie können auch den vollständigen Namen eines Pakets angeben, um
     Details nur über diese Version angezeigt zu bekommen (diesmal
     benutzen wir die andere Schreibweise ‘guix show’):
          $ guix show python@3.4 | recsel -p name,version
          name: python
          version: 3.4.3

‘--list-installed[=REGEXP]’
‘-I [REGEXP]’
     Listet die derzeit installierten Pakete im angegebenen Profil auf,
     die zuletzt installierten Pakete zuletzt. Wenn ein regulärer
     Ausdruck REGEXP angegeben wird, werden nur installierte Pakete
     aufgeführt, deren Name zu REGEXP passt.

     Zu jedem installierten Paket werden folgende Informationen
     angezeigt, durch Tabulatorzeichen getrennt: der Paketname, die
     Version als Zeichenkette, welche Teile des Pakets installiert sind
     (zum Beispiel ‘out’, wenn die Standard-Paketausgabe installiert
     ist, ‘include’, wenn seine Header installiert sind, usw.) und an
     welchem Pfad das Paket im Store zu finden ist.

‘--list-available[=REGEXP]’
‘-A [REGEXP]’
     Listet Pakete auf, die in der aktuell installierten Distribution
     dieses Systems verfügbar sind (siehe *note GNU-Distribution::).
     Wenn ein regulärer Ausdruck REGEXP angegeben wird, werden nur
     Pakete aufgeführt, deren Name zum regulären Ausdruck REGEXP passt.

     Zu jedem Paket werden folgende Informationen getrennt durch
     Tabulatorzeichen ausgegeben: der Name, die Version als
     Zeichenkette, die Teile des Programms (siehe *note Pakete mit
     mehreren Ausgaben.::) und die Stelle im Quellcode, an der das Paket
     definiert ist.

‘--list-generations[=MUSTER]’
‘-l [MUSTER]’
     Liefert eine Liste der Generationen zusammen mit dem Datum, an dem
     sie erzeugt wurden; zu jeder Generation werden zudem die
     installierten Pakete angezeigt, zuletzt installierte Pakete
     zuletzt. Beachten Sie, dass die nullte Generation niemals angezeigt
     wird.

     Zu jedem installierten Paket werden folgende Informationen durch
     Tabulatorzeichen getrennt angezeigt: der Name des Pakets, die
     Version als Zeichenkette, welcher Teil des Pakets installiert ist
     (siehe *note Pakete mit mehreren Ausgaben.::) und an welcher Stelle
     sich das Paket im Store befindet.

     Wenn ein MUSTER angegeben wird, liefert der Befehl nur dazu
     passende Generationen. Gültige Muster sind zum Beispiel:

        • _Ganze Zahlen und kommagetrennte ganze Zahlen_. Beide Muster
          bezeichnen Generationsnummern. Zum Beispiel liefert
          ‘--list-generations=1’ die erste Generation.

          Durch ‘--list-generations=1,8,2’ werden drei Generationen in
          der angegebenen Reihenfolge angezeigt. Weder Leerzeichen noch
          ein Komma am Schluss der Liste ist erlaubt.

        • _Bereiche_. ‘--list-generations=2..9’ gibt die angegebenen
          Generationen und alles dazwischen aus. Beachten Sie, dass der
          Bereichsanfang eine kleinere Zahl als das Bereichsende sein
          muss.

          Sie können auch kein Bereichsende angeben, zum Beispiel
          liefert ‘--list-generations=2..’ alle Generationen ab der
          zweiten.

        • _Zeitdauern_. Sie können auch die letzten _N_ Tage, Wochen
          oder Monate angeben, indem Sie eine ganze Zahl gefolgt von
          jeweils „d“, „w“ oder „m“ angeben (dem ersten Buchstaben der
          Maßeinheit der Dauer im Englischen). Zum Beispiel listet
          ‘--list-generations=20d’ die Generationen auf, die höchstens
          20 Tage alt sind.

‘--delete-generations[=MUSTER]’
‘-d [MUSTER]’
     Wird kein MUSTER angegeben, werden alle Generationen außer der
     aktuellen entfernt.

     Dieser Befehl akzeptiert dieselben Muster wie ‘--list-generations’.
     Wenn ein MUSTER angegeben wird, werden die passenden Generationen
     gelöscht. Wenn das MUSTER für eine Zeitdauer steht, werden
     diejenigen Generationen gelöscht, die _älter_ als die angegebene
     Dauer sind. Zum Beispiel löscht ‘--delete-generations=1m’ die
     Generationen, die mehr als einen Monat alt sind.

     Falls die aktuelle Generation zum Muster passt, wird sie _nicht_
     gelöscht. Auch die nullte Generation wird niemals gelöscht.

     Beachten Sie, dass Sie auf gelöschte Generationen nicht
     zurückwechseln können. Dieser Befehl sollte also nur mit Vorsicht
     benutzt werden.

   Zu guter Letzt können Sie, da ‘guix package’ Erstellungsprozesse zu
starten vermag, auch alle gemeinsamen Erstellungsoptionen (siehe *note
Gemeinsame Erstellungsoptionen::) verwenden. Auch
Paketumwandlungsoptionen wie ‘--with-source’ sind möglich (siehe *note
Paketumwandlungsoptionen::). Beachten Sie jedoch, dass die verwendeten
Paketumwandlungsoptionen verloren gehen, nachdem Sie die Pakete
aktualisiert haben. Damit Paketumwandlungen über Aktualisierungen hinweg
erhalten bleiben, sollten Sie Ihre eigene Paketvariante in einem
Guile-Modul definieren und zur Umgebungsvariablen ‘GUIX_PACKAGE_PATH’
hinzufügen (siehe *note Pakete definieren::).


File: guix.de.info,  Node: Substitute,  Next: Pakete mit mehreren Ausgaben.,  Prev: Aufruf von guix package,  Up: Paketverwaltung

4.3 Substitute
==============

Guix kann transparent Binär- oder Quelldateien ausliefern. Das heißt,
Dinge können sowohl lokal erstellt, als auch als vorerstellte Objekte
von einem Server heruntergeladen werden, oder beides gemischt. Wir
bezeichnen diese vorerstellten Objekte als “Substitute” — sie
substituieren lokale Erstellungsergebnisse. In vielen Fällen geht das
Herunterladen eines Substituts wesentlich schneller, als Dinge lokal zu
erstellen.

   Substitute können alles sein, was das Ergebnis einer
Ableitungserstellung ist (siehe *note Ableitungen::). Natürlich sind sie
üblicherweise vorerstellte Paket-Binärdateien, aber wenn zum Beispiel
ein Quell-Tarball das Ergebnis einer Ableitungserstellung ist, kann auch
er als Substitut verfügbar sein.

* Menu:

* Offizieller Substitut-Server::  Eine besondere Quelle von Substituten.
* Substitut-Server autorisieren::  Wie man Substitute an- und abschaltet.
* Substitutauthentifizierung::  Wie Guix Substitute verifiziert.
* Proxy-Einstellungen::      Wie Sie Substitute über einen Proxy beziehen.
* Fehler bei der Substitution::  Was passiert, wenn die Substitution
                                   fehlschlägt.
* Vom Vertrauen gegenüber Binärdateien::  Wie können Sie diesem binären
                                              Blob trauen?


File: guix.de.info,  Node: Offizieller Substitut-Server,  Next: Substitut-Server autorisieren,  Up: Substitute

4.3.1 Offizieller Substitut-Server
----------------------------------

Der Server ‘ci.guix.gnu.org’ ist die Fassade für eine offizielle
Erstellungsfarm („Build-Farm“), die kontinuierlich Guix-Pakete für
einige Prozessorarchitekturen erstellt und sie als Substitute zur
Verfügung stellt. Dies ist die standardmäßige Quelle von Substituten;
durch Übergeben der Befehlszeilenoption ‘--substitute-urls’ an entweder
den ‘guix-daemon’ (siehe *note ‘guix-daemon --substitute-urls’:
daemon-substitute-urls.) oder Client-Werkzeuge wie ‘guix package’ (siehe
*note die Befehlszeilenoption ‘--substitute-urls’ beim Client:
client-substitute-urls.) kann eine abweichende Einstellung benutzt
werden.

   Substitut-URLs können entweder HTTP oder HTTPS sein. HTTPS wird
empfohlen, weil die Kommunikation verschlüsselt ist; umgekehrt kann bei
HTTP die Kommunikation belauscht werden, wodurch der Angreifer zum
Beispiel erfahren könnte, ob Ihr System über noch nicht behobene
Sicherheitsschwachstellen verfügt.

   Substitute von der offiziellen Erstellungsfarm sind standardmäßig
erlaubt, wenn Sie Guix System verwenden (siehe *note
GNU-Distribution::). Auf Fremddistributionen sind sie allerdings
standardmäßig ausgeschaltet, solange Sie sie nicht ausdrücklich in einem
der empfohlenen Installationsschritte erlaubt haben (siehe *note
Installation::). Die folgenden Absätze beschreiben, wie Sie Substitute
für die offizielle Erstellungsfarm an- oder ausschalten; dieselbe
Prozedur kann auch benutzt werden, um Substitute für einen beliebigen
anderen Substitutserver zu erlauben.


File: guix.de.info,  Node: Substitut-Server autorisieren,  Next: Substitutauthentifizierung,  Prev: Offizieller Substitut-Server,  Up: Substitute

4.3.2 Substitut-Server autorisieren
-----------------------------------

Um es Guix zu gestatten, Substitute von ‘ci.guix.gnu.org’ oder einem
Spiegelserver davon herunterzuladen, müssen Sie den zugehörigen
öffentlichen Schlüssel zur Access Control List (ACL,
Zugriffssteuerungsliste) für Archivimporte hinzufügen, mit Hilfe des
Befehls ‘guix archive’ (siehe *note Aufruf von guix archive::). Dies
impliziert, dass Sie darauf vertrauen, dass ‘ci.guix.gnu.org’ nicht
kompromittiert wurde und echte Substitute liefert.

   Der öffentliche Schlüssel für ‘ci.guix.gnu.org’ wird zusammen mit
Guix installiert, in das Verzeichnis
‘PREFIX/share/guix/hydra.gnu.org.pub’, wobei PREFIX das bei der
Installation angegebene Präfix von Guix ist. Wenn Sie Guix aus seinem
Quellcode heraus installieren, sollten Sie sichergehen, dass Sie die
GPG-Signatur (auch „Beglaubigung“ genannt) von
‘guix-1.1.0.411-5c10d.tar.gz’ prüfen, worin sich dieser öffentliche
Schlüssel befindet. Dann können Sie so etwas wie hier ausführen:

     # guix archive --authorize < PREFIX/share/guix/ci.guix.gnu.org.pub

   Sobald es eingerichtet wurde, sollte sich die Ausgabe eines Befehls
wie ‘guix build’ von so etwas:

     $ guix build emacs --dry-run
     Folgende Ableitungen würden erstellt:
        /gnu/store/yr7bnx8xwcayd6j95r2clmkdl1qh688w-emacs-24.3.drv
        /gnu/store/x8qsh1hlhgjx6cwsjyvybnfv2i37z23w-dbus-1.6.4.tar.gz.drv
        /gnu/store/1ixwp12fl950d15h2cj11c73733jay0z-alsa-lib-1.0.27.1.tar.bz2.drv
        /gnu/store/nlma1pw0p603fpfiqy7kn4zm105r5dmw-util-linux-2.21.drv
     …

in so etwas verwandeln:

     $ guix build emacs --dry-run
     112.3 MB würden heruntergeladen:
        /gnu/store/pk3n22lbq6ydamyymqkkz7i69wiwjiwi-emacs-24.3
        /gnu/store/2ygn4ncnhrpr61rssa6z0d9x22si0va3-libjpeg-8d
        /gnu/store/71yz6lgx4dazma9dwn2mcjxaah9w77jq-cairo-1.12.16
        /gnu/store/7zdhgp0n1518lvfn8mb96sxqfmvqrl7v-libxrender-0.9.7
     …

Der Text hat sich von „Folgende Ableitungen würden erstellt“ zu „112.3
MB würden heruntergeladen“ geändert. Das zeigt an, dass Substitute von
‘ci.guix.gnu.org’ nutzbar sind und für zukünftige Erstellungen
heruntergeladen werden, wann immer es möglich ist.

   Der Substitutsmechanismus kann global ausgeschaltet werden, indem Sie
dem ‘guix-daemon’ beim Starten die Befehlszeilenoption
‘--no-substitutes’ übergeben (siehe *note Aufruf des guix-daemon::). Er
kann auch temporär ausgeschaltet werden, indem Sie ‘--no-substitutes’ an
‘guix package’, ‘guix build’ und andere Befehlszeilenwerkzeuge
übergeben.


File: guix.de.info,  Node: Substitutauthentifizierung,  Next: Proxy-Einstellungen,  Prev: Substitut-Server autorisieren,  Up: Substitute

4.3.3 Substitutauthentifizierung
--------------------------------

Guix erkennt, wenn ein verfälschtes Substitut benutzt würde, und meldet
einen Fehler. Ebenso werden Substitute ignoriert, die nich signiert
sind, oder nicht mit einem in der ACL aufgelisteten Schlüssel signiert
sind.

   Es gibt nur eine Ausnahme: Wenn ein unautorisierter Server Substitute
anbietet, die _Bit für Bit identisch_ mit denen von einem autorisierten
Server sind, können sie auch vom unautorisierten Server heruntergeladen
werden. Zum Beispiel, angenommen wir haben zwei Substitutserver mit
dieser Befehlszeilenoption ausgewählt:

     --substitute-urls="https://a.example.org https://b.example.org"

Wenn in der ACL nur der Schlüssel für ‘b.example.org’ aufgeführt wurde,
aber ‘a.example.org’ _exakt dieselben_ Substitute anbietet, wird Guix
auch Substitute von ‘a.example.org’ herunterladen, weil es in der Liste
zuerst kommt und als Spiegelserver für ‘b.example.org’ aufgefasst werden
kann. In der Praxis haben unabhängige Maschinen bei der Erstellung
normalerweise dieselben Binärdateien als Ergebnis, dank
bit-reproduzierbarer Erstellungen (siehe unten).

   Wenn Sie HTTPS benutzen, wird das X.509-Zertifikat des Servers
_nicht_ validiert (mit anderen Worten, die Identität des Servers wird
nicht authentifiziert), entgegen dem, was HTTPS-Clients wie Web-Browser
normalerweise tun. Da Guix Substitutinformationen selbst überprüft, wie
oben erklärt, wäre es unnötig (wohingegen mit X.509-Zertifikaten geprüft
wird, ob ein Domain-Name zu öffentlichen Schlüsseln passt).


File: guix.de.info,  Node: Proxy-Einstellungen,  Next: Fehler bei der Substitution,  Prev: Substitutauthentifizierung,  Up: Substitute

4.3.4 Proxy-Einstellungen
-------------------------

Substitute werden über HTTP oder HTTPS heruntergeladen. Die
Umgebungsvariable ‘http_proxy’ kann in der Umgebung von ‘guix-daemon’
definiert werden und wirkt sich dann auf das Herunterladen von
Substituten aus. Beachten Sie, dass der Wert von ‘http_proxy’ in der
Umgebung, in der ‘guix build’, ‘guix package’ und andere Client-Befehle
ausgeführt werden, _keine Rolle spielt_.


File: guix.de.info,  Node: Fehler bei der Substitution,  Next: Vom Vertrauen gegenüber Binärdateien,  Prev: Proxy-Einstellungen,  Up: Substitute

4.3.5 Fehler bei der Substitution
---------------------------------

Selbst wenn ein Substitut für eine Ableitung verfügbar ist, schlägt die
versuchte Substitution manchmal fehl. Das kann aus vielen Gründen
geschehen: die Substitutsserver könnten offline sein, das Substitut
könnte kürzlich gelöscht worden sein, die Netzwerkverbindunge könnte
unterbrochen worden sein, usw.

   Wenn Substitute aktiviert sind und ein Substitut für eine Ableitung
zwar verfügbar ist, aber die versuchte Substitution fehlschlägt, kann
Guix versuchen, die Ableitung lokal zu erstellen, je nachdem, ob
‘--fallback’ übergeben wurde (siehe *note common build option
‘--fallback’: fallback-option.). Genauer gesagt, wird keine lokale
Erstellung durchgeführt, solange kein ‘--fallback’ angegeben wurde, und
die Ableitung wird als Fehlschlag angesehen. Wenn ‘--fallback’ übergeben
wurde, wird Guix versuchen, die Ableitung lokal zu erstellen, und ob die
Ableitung erfolgreich ist oder nicht, hängt davon ab, ob die lokale
Erstellung erfolgreich ist oder nicht. Beachten Sie, dass, falls
Substitute ausgeschaltet oder erst gar kein Substitut verfügbar ist,
_immer_ eine lokale Erstellung durchgeführt wird, egal ob ‘--fallback’
übergeben wurde oder nicht.

   Um eine Vorstellung zu bekommen, wieviele Substitute gerade verfügbar
sind, können Sie den Befehl ‘guix weather’ benutzen (siehe *note Aufruf
von guix weather::). Dieser Befehl zeigt Statistiken darüber an, wie es
um die von einem Server verfügbaren Substitute steht.


File: guix.de.info,  Node: Vom Vertrauen gegenüber Binärdateien,  Prev: Fehler bei der Substitution,  Up: Substitute

4.3.6 Vom Vertrauen gegenüber Binärdateien
------------------------------------------

Derzeit hängt die Kontrolle jedes Individuums über seine Rechner von
Institutionen, Unternehmen und solchen Gruppierungen ab, die über genug
Macht und Entschlusskraft verfügen, die Rechnerinfrastruktur zu
sabotieren und ihre Schwachstellen auszunutzen. Auch wenn es bequem ist,
Substitute von ‘ci.guix.gnu.org’ zu benutzen, ermuntern wir Nutzer, auch
selbst Erstellungen durchzuführen oder gar ihre eigene Erstellungsfarm
zu betreiben, damit ‘ci.guix.gnu.org’ ein weniger interessantes Ziel
wird. Eine Art, uns zu helfen, ist, die von Ihnen erstellte Software mit
dem Befehl ‘guix publish’ zu veröffentlichen, damit andere eine größere
Auswahl haben, von welchem Server sie Substitute beziehen möchten (siehe
*note Aufruf von guix publish::).

   Guix hat die richtigen Grundlagen, um die Reproduzierbarkeit von
Erstellungen zu maximieren (siehe *note Funktionalitäten::). In den
meisten Fällen sollten unabhängige Erstellungen eines bestimmten Pakets
zu bitweise identischen Ergebnissen führen. Wir können also mit Hilfe
einer vielschichtigen Menge an unabhängigen Paketerstellungen die
Integrität unseres Systems besser gewährleisten. Der Befehl ‘guix
challenge’ hat das Ziel, Nutzern zu ermöglichen, Substitutserver zu
beurteilen, und Entwickler dabei zu unterstützen, nichtdeterministische
Paketerstellungen zu finden (siehe *note Aufruf von guix challenge::).
Ebenso ermöglicht es die Befehlszeilenoption ‘--check’ von ‘guix build’,
dass Nutzer bereits installierte Substitute auf Echtheit zu prüfen,
indem sie lokal nachgebaut werden (siehe *note ‘guix build --check’:
build-check.).

   In Zukunft wollen wir, dass Sie mit Guix Binärdateien von
Netzwerkteilnehmer zu Netzwerkteilnehmer („peer-to-peer“)
veröffentlichen und empfangen können. Wenn Sie mit uns dieses Projekt
diskutieren möchten, kommen Sie auf unsere Mailing-Liste
<guix-devel@gnu.org>.


File: guix.de.info,  Node: Pakete mit mehreren Ausgaben.,  Next: Aufruf von guix gc,  Prev: Substitute,  Up: Paketverwaltung

4.4 Pakete mit mehreren Ausgaben.
=================================

Oft haben in Guix definierte Pakete eine einzige “Ausgabe” — d.h. aus
dem Quellpaket entsteht genau ein Verzeichnis im Store. Wenn Sie ‘guix
install glibc’ ausführen, wird die Standard-Paketausgabe des
GNU-libc-Pakets installiert; die Standardausgabe wird ‘out’ genannt,
aber ihr Name kann weggelassen werden, wie Sie am obigen Befehl sehen.
In diesem speziellen Fall enthält die Standard-Paketausgabe von ‘glibc’
alle C-Headerdateien, gemeinsamen Bibliotheken („Shared Libraries“),
statischen Bibliotheken („Static Libraries“), Dokumentation für Info
sowie andere zusätzliche Dateien.

   Manchmal ist es besser, die verschiedenen Arten von Dateien, die aus
einem einzelnen Quellpaket hervorgehen, in getrennte Ausgaben zu
unterteilen. Zum Beispiel installiert die GLib-C-Bibliothek (die von GTK
und damit zusammenhängenden Paketen benutzt wird) mehr als 20 MiB an
HTML-Seiten mit Referenzdokumentation. Um den Nutzern, die das nicht
brauchen, Platz zu sparen, wird die Dokumentation in einer separaten
Ausgabe abgelegt, genannt ‘doc’. Um also die Hauptausgabe von GLib zu
installieren, zu der alles außer der Dokumentation gehört, ist der
Befehl:

     guix install glib

   Der Befehl, um die Dokumentation zu installieren, ist:

     guix install glib:doc

   Manche Pakete installieren Programme mit unterschiedlich großem
„Abhängigkeiten-Fußabdruck“. Zum Beispiel installiert das Paket WordNet
sowohl Befehlszeilenwerkzeuge als auch grafische Benutzerschnittstellen
(GUIs). Erstere hängen nur von der C-Bibliothek ab, während Letztere
auch von Tcl/Tk und den zu Grunde liegenden X-Bibliotheken abhängen.
Jedenfalls belassen wir deshalb die Befehlszeilenwerkzeuge in der
Standard-Paketausgabe, während sich die GUIs in einer separaten Ausgabe
befinden. So können Benutzer, die die GUIs nicht brauchen, Platz sparen.
Der Befehl ‘guix size’ kann dabei helfen, solche Situationen zu erkennen
(siehe *note Aufruf von guix size::). ‘guix graph’ kann auch helfen
(siehe *note Aufruf von guix graph::).

   In der GNU-Distribution gibt es viele solche Pakete mit mehreren
Ausgaben. Andere Konventionen für Ausgabenamen sind zum Beispiel ‘lib’
für Bibliotheken und eventuell auch ihre Header-Dateien,, ‘bin’ für
eigenständige Programme und ‘debug’ für Informationen zur
Fehlerbehandlung (siehe *note Dateien zur Fehlersuche installieren::).
Die Ausgaben eines Pakets stehen in der dritten Spalte der Anzeige von
‘guix package --list-available’ (siehe *note Aufruf von guix package::).


File: guix.de.info,  Node: Aufruf von guix gc,  Next: Aufruf von guix pull,  Prev: Pakete mit mehreren Ausgaben.,  Up: Paketverwaltung

4.5 ‘guix gc’ aufrufen
======================

Pakete, die zwar installiert sind, aber nicht benutzt werden, können vom
“Müllsammler” entfernt werden. Mit dem Befehl ‘guix gc’ können Benutzer
den Müllsammler ausdrücklich aufrufen, um Speicher im Verzeichnis
‘/gnu/store’ freizugeben. Dies ist der _einzige_ Weg, Dateien aus
‘/gnu/store’ zu entfernen — das manuelle Entfernen von Dateien kann den
Store irreparabel beschädigen!

   Der Müllsammler kennt eine Reihe von “Wurzeln”: Jede Datei in
‘/gnu/store’, die von einer Wurzel aus erreichbar ist, gilt als
“lebendig” und kann nicht entfernt werden; jede andere Datei gilt als
“tot” und ist ein Kandidat, gelöscht zu werden. Die Menge der
Müllsammlerwurzeln (kurz auch „GC-Wurzeln“, von englisch „Garbage
Collector“) umfasst Standard-Benutzerprofile; standardmäßig werden diese
Müllsammlerwurzeln durch symbolische Verknüpfungen in
‘/var/guix/gcroots’ dargestellt. Neue Müllsammlerwurzeln können zum
Beispiel mit ‘guix build --root’ festgelegt werden (siehe *note Aufruf
von guix build::). Der Befehl ‘guix gc --list-roots’ listet sie auf.

   Bevor Sie mit ‘guix gc --collect-garbage’ Speicher freimachen, wollen
Sie vielleicht alte Generationen von Benutzerprofilen löschen, damit
alte Paketerstellungen von diesen Generationen entfernt werden können.
Führen Sie dazu ‘guix package --delete-generations’ aus (siehe *note
Aufruf von guix package::).

   Unsere Empfehlung ist, dass Sie den Müllsammler regelmäßig laufen
lassen und wenn Sie wenig freien Speicherplatz zur Verfügung haben. Um
zum Beispiel sicherzustellen, dass Sie mindestens 5 GB auf Ihrer Platte
zur Verfügung haben, benutzen Sie einfach:

     guix gc -F 5G

   Es ist völlig sicher, dafür eine nicht interaktive, regelmäßige
Auftragsausführung vorzugeben (siehe *note Geplante Auftragsausführung::
für eine Erklärung, wie man das tun kann). ‘guix gc’ ohne
Befehlszeilenargumente auszuführen, lässt so viel Müll wie möglich
sammeln, aber das ist oft nicht, was man will, denn so muss man unter
Umständen Software erneut erstellen oder erneut herunterladen, weil der
Müllsammler sie als „tot“ ansieht, sie aber zur Erstellung anderer
Software wieder gebraucht wird — das trifft zum Beispiel auf die
Compiler-Toolchain zu.

   Der Befehl ‘guix gc’ hat drei Arbeitsmodi: Er kann benutzt werden, um
als Müllsammler tote Dateien zu entfernen (das Standardverhalten), um
ganz bestimmte, angegebene Datein zu löschen (mit der
Befehlszeilenoption ‘--delete’), um Müllsammlerinformationen auszugeben
oder fortgeschrittenere Anfragen zu verarbeiten. Die
Müllsammler-Befehlszeilenoptionen sind wie folgt:

‘--collect-garbage[=MINIMUM]’
‘-C [MINIMUM]’
     Lässt Müll sammeln — z.B. nicht erreichbare Dateien in ‘/gnu/store’
     und seinen Unterverzeichnissen. Wird keine andere
     Befehlszeilenoption angegeben, wird standardmäßig diese
     durchgeführt.

     Wenn ein MINIMUM angegeben wurde, hört der Müllsammler auf, sobald
     MINIMUM Bytes gesammelt wurden. Das MINIMUM kann die Anzahl der
     Bytes bezeichnen oder mit einer Einheit als Suffix versehen sein,
     wie etwa ‘MiB’ für Mebibytes und ‘GB’ für Gigabytes (siehe *note
     size specifications: (coreutils)Block size.).

     Wird kein MINIMUM angegeben, sammelt der Müllsammler allen Müll.

‘--free-space=MENGE’
‘-F MENGE’
     Sammelt Müll, bis die angegebene MENGE an freiem Speicher in
     ‘/gnu/store’ zur Verfügung steht, falls möglich; die MENGE ist eine
     Speichergröße wie ‘500MiB’, wie oben beschrieben.

     Wenn die angegebene MENGE oder mehr bereits in ‘/gnu/store’ frei
     verfügbar ist, passiert nichts.

‘--delete-generations[=DAUER]’
‘-d [DAUER]’
     Bevor der Müllsammelvorgang beginnt, werden hiermit alle
     Generationen von allen Benutzerprofilen gelöscht, die älter sind
     als die angegebene DAUER; wird es als Administratornutzer „root“
     ausgeführt, geschieht dies mit den Profilen _von allen Benutzern_.

     Zum Beispiel löscht der folgende Befehl alle Generationen Ihrer
     Profile, die älter als zwei Monate sind (ausgenommen die momentanen
     Generationen), und schmeißt dann den Müllsammler an, um Platz
     freizuräumen, bis mindestens 10 GiB verfügbar sind:

          guix gc -d 2m -F 10G

‘--delete’
‘-D’
     Versucht, alle als Argumente angegebenen Dateien oder Verzeichnisse
     im Store zu löschen. Dies schlägt fehl, wenn manche der Dateien
     oder Verzeichnisse nicht im Store oder noch immer lebendig sind.

‘--list-failures’
     Store-Objekte auflisten, die zwischengespeicherten
     Erstellungsfehlern entsprechen.

     Hierbei wird nichts ausgegeben, sofern der Daemon nicht mit
     ‘--cache-failures’ gestartet wurde (siehe *note ‘--cache-failures’:
     Aufruf des guix-daemon.).

‘--list-roots’
     Die Müllsammlerwurzeln auflisten, die dem Nutzer gehören. Wird der
     Befehl als Administratornutzer ausgeführt, werden _alle_
     Müllsammlerwurzeln aufgelistet.

‘--list-busy’
     Solche Store-Objekte auflisten, die von aktuell laufenden Prozessen
     benutzt werden. Diese Store-Objekte werden praktisch wie
     Müllsammlerwurzeln behandelt; sie können nicht gelöscht werden.

‘--clear-failures’
     Die angegebenen Store-Objekte aus dem Zwischenspeicher für
     fehlgeschlagene Erstellungen entfernen.

     Auch diese Option macht nur Sinn, wenn der Daemon mit
     ‘--cache-failures’ gestartet wurde. Andernfalls passiert nichts.

‘--list-dead’
     Zeigt die Liste toter Dateien und Verzeichnisse an, die sich noch
     im Store befinden — das heißt, Dateien, die von keiner Wurzel mehr
     erreichbar sind.

‘--list-live’
     Zeige die Liste lebendiger Store-Dateien und -Verzeichnisse.

   Außerdem können Referenzen unter bestehenden Store-Dateien gefunden
werden:

‘--references’
‘--referrers’
     Listet die referenzierten bzw. sie referenzierenden Objekte der
     angegebenen Store-Dateien auf.

‘--requisites’
‘-R’
     Listet alle Voraussetzungen der als Argumente übergebenen
     Store-Dateien auf. Voraussetzungen sind die Store-Dateien selbst,
     ihre Referenzen sowie die Referenzen davon, rekursiv. Mit anderen
     Worten, die zurückgelieferte Liste ist der “transitive Abschluss”
     dieser Store-Dateien.

     Der Abschnitt *note Aufruf von guix size:: erklärt ein Werkzeug, um
     den Speicherbedarf des Abschlusses eines Elements zu ermitteln.
     Siehe *note Aufruf von guix graph:: für ein Werkzeug, um den
     Referenzgraphen zu veranschaulichen.

‘--derivers’
     Liefert die Ableitung(en), die zu den angegebenen Store-Objekten
     führen (siehe *note Ableitungen::).

     Zum Beispiel liefert dieser Befehl:

          guix gc --derivers `guix package -I ^emacs$ | cut -f4`

     die ‘.drv’-Datei(en), die zum in Ihrem Profil installierten
     ‘emacs’-Paket führen.

     Beachten Sie, dass es auch sein kann, dass keine passenden
     ‘.drv’-Dateien existieren, zum Beispiel wenn diese Dateien bereits
     dem Müllsammler zum Opfer gefallen sind. Es kann auch passieren,
     dass es mehr als eine passende ‘.drv’ gibt, bei Ableitungen mit
     fester Ausgabe.

   Zuletzt können Sie mit folgenden Befehlszeilenoptionen die Integrität
des Stores prüfen und den Plattenspeicherverbrauch im Zaum halten.

‘--verify[=OPTIONEN]’
     Die Integrität des Stores verifizieren

     Standardmäßig wird sichergestellt, dass alle Store-Objekte, die in
     der Datenbank des Daemons als gültig markiert wurden, auch
     tatsächlich in ‘/gnu/store’ existieren.

     Wenn angegeben, müssen die OPTIONEN eine kommagetrennte Liste aus
     mindestens einem der Worte ‘contents’ und ‘repair’ sein.

     Wenn Sie ‘--verify=contents’ übergeben, berechnet der Daemon den
     Hash des Inhalts jedes Store-Objekts und vergleicht ihn mit dem
     Hash in der Datenbank. Sind die Hashes ungleich, wird eine
     Datenbeschädigung gemeldet. Weil dabei _alle Dateien im Store_
     durchlaufen werden, kann der Befehl viel Zeit brauchen, besonders
     auf Systemen mit langsamer Platte.

     Mit ‘--verify=repair’ oder ‘--verify=contents,repair’ versucht der
     Daemon, beschädigte Store-Objekte zu reparieren, indem er
     Substitute für selbige herunterlädt (siehe *note Substitute::).
     Weil die Reparatur nicht atomar und daher womöglich riskant ist,
     kann nur der Systemadministrator den Befehl benutzen. Eine weniger
     aufwendige Alternative, wenn Sie wissen, welches Objekt beschädigt
     ist, ist, ‘guix build --repair’ zu benutzen (siehe *note Aufruf von
     guix build::).

‘--optimize’
     Den Store durch Nutzung harter Verknüpfungen für identische Dateien
     optimieren — mit anderen Worten wird der Store “dedupliziert”.

     Der Daemon führt Deduplizierung automatisch nach jeder
     erfolgreichen Erstellung und jedem Importieren eines Archivs durch,
     sofern er nicht mit ‘--disable-deduplication’ (siehe *note
     ‘--disable-deduplication’: Aufruf des guix-daemon.) gestartet
     wurde. Diese Befehlszeilenoption brauchen Sie also in erster Linie
     dann, wenn der Daemon zuvor mit ‘--disable-deduplication’ gestartet
     worden ist.


File: guix.de.info,  Node: Aufruf von guix pull,  Next: Kanäle,  Prev: Aufruf von guix gc,  Up: Paketverwaltung

4.6 ‘guix pull’ aufrufen
========================

Nach der Installation oder Aktualisierung wird stets die neueste Version
von Paketen verwendet, die in der aktuell installierten Distribution
verfügbar ist. Um die Distribution und die Guix-Werkzeuge zu
aktualisieren, führen Sie ‘guix pull’ aus. Der Befehl lädt den neuesten
Guix-Quellcode einschließlich Paketbeschreibungen herunter und
installiert ihn. Quellcode wird aus einem Git-Repository
(https://git-scm.com) geladen, standardmäßig dem offiziellen Repository
von GNU Guix, was Sie aber auch ändern können.

   Genauer gesagt lädt ‘guix pull’ Code von den “Kanälen” herunter
(siehe *note Kanäle::), die an einer der folgenden Stellen, in dieser
Reihenfolge, angegeben wurden:

  1. die Befehlszeilenoption ‘--channels’,
  2. die Datei ‘~/.config/guix/channels.scm’ des Benutzers,
  3. die systemweite ‘/etc/guix/channels.scm’-Datei,
  4. die eingebauten vorgegebenen Kanäle, wie sie in der Variablen
     ‘%default-channels’ festgelegt sind.

   Danach wird ‘guix package’ Pakete und ihre Versionen entsprechend der
gerade heruntergeladenen Kopie von Guix benutzen. Nicht nur das, auch
alle Guix-Befehle und Scheme-Module werden aus der neuesten Version von
Guix kommen. Neue ‘guix’-Unterbefehle, die durch die Aktualisierung
hinzugekommen sind, werden also auch verfügbar.

   Jeder Nutzer kann seine Kopie von Guix mittels ‘guix pull’
aktualisieren, wodurch sich nur für den Nutzer etwas verändert, der
‘guix pull’ ausgeführt hat. Wenn also zum Beispiel der
Administratornutzer ‘root’ den Befehl ‘guix pull’ ausführt, hat das
keine Auswirkungen auf die für den Benutzer ‘alice’ sichtbare
Guix-Version, und umgekehrt.

   Das Ergebnis von ‘guix pull’ ist ein als ‘~/.config/guix/current’
verfügbares “Profil” mit dem neuesten Guix. Stellen Sie sicher, dass es
am Anfang Ihres Suchpfades steht, damit Sie auch wirklich das neueste
Guix und sein Info-Handbuch sehen (siehe *note Dokumentation::):

     export PATH="$HOME/.config/guix/current/bin:$PATH"
     export INFOPATH="$HOME/.config/guix/current/share/info:$INFOPATH"

   Die Befehlszeilenoption ‘--list-generations’ oder kurz ‘-l’ listet
ältere von ‘guix pull’ erzeugte Generationen auf, zusammen mit
Informationen zu deren Provenienz.

     $ guix pull -l
     Generation 1	Jun 10 2018 00:18:18
       guix 65956ad
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: origin/master
         commit: 65956ad3526ba09e1f7a40722c96c6ef7c0936fe

     Generation 2	Jun 11 2018 11:02:49
       guix e0cc7f6
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: origin/master
         commit: e0cc7f669bec22c37481dd03a7941c7d11a64f1d
       2 new packages: keepalived, libnfnetlink
       6 packages upgraded: emacs-nix-mode@2.0.4,
         guile2.0-guix@0.14.0-12.77a1aac, guix@0.14.0-12.77a1aac,
         heimdal@7.5.0, milkytracker@1.02.00, nix@2.0.4

     Generation 3	Jun 13 2018 23:31:07	(current)
       guix 844cc1c
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: origin/master
         commit: 844cc1c8f394f03b404c5bb3aee086922373490c
       28 new packages: emacs-helm-ls-git, emacs-helm-mu, …
       69 packages upgraded: borg@1.1.6, cheese@3.28.0, …

   Im Abschnitt *note ‘guix describe’: Aufruf von guix describe. werden
andere Möglichkeiten erklärt, sich den momentanen Zustand von Guix
beschreiben zu lassen.

   Das Profil ‘~/.config/guix/current’ verhält sich genau wie die durch
‘guix package’ erzeugten Profile (siehe *note Aufruf von guix
package::). Das bedeutet, Sie können seine Generationen auflisten und es
auf die vorherige Generation — also das vorherige Guix — zurücksetzen
und so weiter:

     $ guix pull --roll-back
     Von Generation „3“ zu „2“ gewechselt
     $ guix pull --delete-generations=1
     /var/guix/profiles/per-user/charlie/current-guix-1-link wird gelöscht

   Sie können auch ‘guix package’ benutzen (siehe *note Aufruf von guix
package::), um das Profil zu verwalten, indem Sie es explizit angeben.:
     $ guix package -p ~/.config/guix/current --roll-back
     switched from generation 3 to 2
     $ guix package -p ~/.config/guix/current --delete-generations=1
     deleting /var/guix/profiles/per-user/charlie/current-guix-1-link

   Der Befehl ‘guix pull’ wird in der Regel ohne Befehlszeilenargumente
aufgerufen, aber er versteht auch folgende Befehlszeilenoptionen:

‘--url=URL’
‘--commit=COMMIT’
‘--branch=BRANCH’
     Code wird für den ‘guix’-Kanal von der angegebenen URL für den
     angegebenen COMMIT (eine gültige Commit-ID, dargestellt als
     hexadezimale Zeichenkette) oder BRANCH heruntergeladen.

     Diese Befehlszeilenoptionen sind manchmal bequemer, aber Sie können
     Ihre Konfiguration auch in der Datei ‘~/.config/guix/channels.scm’
     oder über die Option ‘--channels’ angeben (siehe unten).

‘--channels=DATEI’
‘-C DATEI’
     Die Liste der Kanäle aus der angegebenen DATEI statt aus
     ‘~/.config/guix/channels.scm’ oder aus ‘/etc/guix/channels.scm’
     auslesen. Die DATEI muss Scheme-Code enthalten, der zu einer Liste
     von Kanalobjekten ausgewertet wird. Siehe *note Kanäle:: für nähere
     Informationen.

‘--news’
‘-N’
     Die Liste anzeigen, welche Pakete seit der vorherigen Generation
     hinzugefügt oder aktualisiert wurden, und gelegentlich auch, welche
     Neuigkeiten die Kanalautoren für ihre Nutzer geschrieben haben
     (siehe *note Writing Channel News: Kanäle.).

     Die Paketinformationen sind dieselben, die auch nach Abschluss von
     ‘guix pull’ angezeigt werden, aber ohne Auslassungen; sie ähnelt
     auch der Ausgabe von ‘guix pull -l’ für die neueste Generation
     (siehe unten).

‘--list-generations[=MUSTER]’
‘-l [MUSTER]’
     Alle Generationen von ‘~/.config/guix/current’ bzw., wenn ein
     MUSTER angegeben wird, die dazu passenden Generationen auflisten.
     Die Syntax für das MUSTER ist dieselbe wie bei ‘guix package
     --list-generations’ (siehe *note Aufruf von guix package::).

‘--roll-back’
     Zur vorherigen “Generation” von ‘~/.config/guix/current’
     zurückwechseln — d.h. die letzte Transaktion rückgängig machen.

‘--switch-generation=MUSTER’
‘-S MUSTER’
     Wechselt zu der bestimmten Generation, die durch das MUSTER
     bezeichnet wird.

     Als MUSTER kann entweder die Nummer einer Generation oder eine
     Nummer mit vorangestelltem „+“ oder „-“ dienen. Letzteres springt
     die angegebene Anzahl an Generationen vor oder zurück. Zum Beispiel
     kehrt ‘--switch-generation=+1’ nach einem Zurücksetzen wieder zur
     neueren Generation zurück.

‘--delete-generations[=MUSTER]’
‘-d [MUSTER]’
     Wird kein MUSTER angegeben, werden alle Generationen außer der
     aktuellen entfernt.

     Dieser Befehl akzeptiert dieselben Muster wie ‘--list-generations’.
     Wenn ein MUSTER angegeben wird, werden die passenden Generationen
     gelöscht. Wenn das MUSTER für eine Zeitdauer steht, werden
     diejenigen Generationen gelöscht, die _älter_ als die angegebene
     Dauer sind. Zum Beispiel löscht ‘--delete-generations=1m’ die
     Generationen, die mehr als einen Monat alt sind.

     Falls die aktuelle Generation zum Muster passt, wird sie _nicht_
     gelöscht.

     Beachten Sie, dass Sie auf gelöschte Generationen nicht
     zurückwechseln können. Dieser Befehl sollte also nur mit Vorsicht
     benutzt werden.

     Im Abschnitt *note ‘guix describe’: Aufruf von guix describe. wird
     eine Möglichkeit erklärt, sich Informationen nur über die aktuelle
     Generation anzeigen zu lassen.

‘--profile=PROFIL’
‘-p PROFIL’
     Auf PROFIL anstelle von ‘~/.config/guix/current’ arbeiten.

‘--dry-run’
‘-n’
     Anzeigen, welche(r) Commit(s) für die Kanäle benutzt würde(n) und
     was jeweils erstellt oder substituiert würde, ohne es tatsächlich
     durchzuführen.

‘--system=SYSTEM’
‘-s SYSTEM’
     Versuchen, für die angegebene Art von SYSTEM geeignete Binärdateien
     zu erstellen — z.B. ‘i686-linux’ — statt für die Art von System,
     das die Erstellung durchführt.

‘--verbose’
     Ausführliche Informationen ausgeben und Erstellungsprotokolle auf
     der Standardfehlerausgabe ausgeben.

‘--bootstrap’
     Das neueste Guix mit dem Bootstrap-Guile erstellen. Diese
     Befehlszeilenoption ist nur für Guix-Entwickler von Nutzen.

   Mit Hilfe von “Kanälen” können Sie ‘guix pull’ anweisen, von welchem
Repository und welchem Branch Guix aktualisiert werden soll, sowie von
welchen _weiteren_ Repositorys Paketmodule bezogen werden sollen. Im
Abschnitt *note Kanäle:: finden Sie nähere Informationen.

   Außerdem unterstützt ‘guix pull’ alle gemeinsamen Erstellungsoptionen
(siehe *note Gemeinsame Erstellungsoptionen::).


File: guix.de.info,  Node: Kanäle,  Next: Aufruf von time-machine,  Prev: Aufruf von guix pull,  Up: Paketverwaltung

4.7 Kanäle
==========

Guix und die Sammlung darin verfügbarer Pakete können Sie durch
Ausführen von ‘guix pull’ aktualisieren (siehe *note Aufruf von guix
pull::). Standardmäßig lädt ‘guix pull’ Guix selbst vom offiziellen
Repository von GNU Guix herunter und installiert es. Diesen Vorgang
können Sie anpassen, indem Sie “Kanäle” in der Datei
‘~/.config/guix/channels.scm’ angeben. Ein Kanal enthält eine Angabe
einer URL und eines Branches eines zu installierenden Git-Repositorys
und Sie können ‘guix pull’ veranlassen, die Aktualisierungen von einem
oder mehreren Kanälen zu beziehen. Mit anderen Worten können Kanäle
benutzt werden, um Guix _anzupassen_ und zu _erweitern_, wie wir im
Folgenden sehen werden.

4.7.1 Einen eigenen Guix-Kanal benutzen
---------------------------------------

Der Kanal namens ‘guix’ gibt an, wovon Guix selbst — seine
Befehlszeilenwerkzeuge und seine Paketsammlung — heruntergeladen werden
sollen. Wenn Sie zum Beispiel mit Ihrer eigenen Kopie des
Guix-Repositorys arbeiten möchten und diese auf ‘example.org’ zu finden
ist, und zwar im Branch namens ‘super-hacks’, dann schreiben Sie
folgende Spezifikation in ‘~/.config/guix/channels.scm’:

     ;; 'guix pull' mein eigenes Repository benutzen lassen.
     (list (channel
             (name 'guix)
             (url "https://example.org/my-guix.git")
             (branch "super-hacks")))

Ab dann wird ‘guix pull’ seinen Code vom Branch ‘super-hacks’ des
Repositorys auf ‘example.org’ beziehen.

4.7.2 Weitere Kanäle angeben
----------------------------

Sie können auch _weitere Kanäle_ als Bezugsquelle angeben. Sagen wir,
Sie haben ein paar eigene Paketvarianten oder persönliche Pakete, von
denen Sie meinen, dass sie _nicht_ geeignet sind, ins Guix-Projekt
selbst aufgenommen zu werden, die Ihnen aber dennoch wie andere Pakete
auf der Befehlszeile zur Verfügung stehen sollen. Dann würden Sie
zunächst Module mit diesen Paketdefinitionen schreiben (siehe *note
Paketmodule::) und diese dann in einem Git-Repository verwalten, welches
Sie selbst oder jeder andere dann als zusätzlichen Kanal eintragen
können, von dem Pakete geladen werden. Klingt gut, oder?

     Warnung: Bevor Sie, verehrter Nutzer, ausrufen: „Wow, das ist
     _soooo coool_!“, und Ihren eigenen Kanal der Welt zur Verfügung
     stellen, möchten wir Ihnen auch ein paar Worte der Warnung mit auf
     den Weg geben:

        • Bevor Sie einen Kanal veröffentlichen, überlegen Sie sich
          bitte erst, ob Sie die Pakete nicht besser zum eigentlichen
          Guix-Projekt beisteuern (siehe *note Mitwirken::). Das
          Guix-Projekt ist gegenüber allen Arten freier Software offen
          und zum eigentlichen Guix gehörende Pakete stehen allen
          Guix-Nutzern zur Verfügung, außerdem profitieren sie von Guix’
          Qualitätssicherungsprozess.

        • Wenn Sie Paketdefinitionen außerhalb von Guix betreuen, sehen
          wir Guix-Entwickler es als _Ihre Aufgabe an, deren
          Kompatibilität sicherzstellen_. Bedenken Sie, dass Paketmodule
          und Paketdefinitionen nur Scheme-Code sind, der verschiedene
          Programmierschnittstellen (APIs) benutzt. Wir nehmen uns das
          Recht heraus, diese APIs jederzeit zu ändern, damit wir Guix
          besser machen können, womöglich auf eine Art, wodurch Ihr
          Kanal nicht mehr funktioniert. Wir ändern APIs nie einfach so,
          werden aber auch _nicht_ versprechen, APIs nicht zu verändern.

        • Das bedeutet auch, dass Sie, wenn Sie einen externen Kanal
          verwenden und dieser kaputt geht, Sie dies bitte _den Autoren
          des Kanals_ und nicht dem Guix-Projekt melden.

     Wir haben Sie gewarnt! Allerdings denken wir auch, dass externe
     Kanäle eine praktische Möglichkeit sind, die Paketsammlung von Guix
     zu ergänzen und Ihre Verbesserungen mit anderen zu teilen, wie es
     dem Grundgedanken freier Software
     (https://www.gnu.org/philosophy/free-sw.html) entspricht. Bitte
     schicken Sie eine E-Mail an <guix-devel@gnu.org>, wenn Sie dies
     diskutieren möchten.

   Um einen Kanal zu benutzen, tragen Sie ihn in
‘~/.config/guix/channels.scm’ ein, damit ‘guix pull’ diesen Kanal
_zusätzlich_ zu den standardmäßigen Guix-Kanälen als Paketquelle
verwendet:

     ;; Meine persönlichen Pakete zu denen von Guix dazunehmen.
     (cons (channel
             (name 'meine-persönlichen-pakete)
             (url "https://example.org/personal-packages.git"))
           %default-channels)

Beachten Sie, dass der obige Schnipsel (wie immer!) Scheme-Code ist; mit
‘cons’ fügen wir einen Kanal zur Liste der Kanäle hinzu, an die die
Variable ‘%default-channels’ gebunden ist (siehe *note ‘cons’ and lists:
(guile)Pairs.). Mit diesem Dateiinhalt wird ‘guix pull’ nun nicht mehr
nur Guix, sondern auch die Paketmodule aus Ihrem Repository erstellen.
Das Ergebnis in ‘~/.config/guix/current’ ist so die Vereinigung von Guix
und Ihren eigenen Paketmodulen.

     $ guix pull --list-generations
     …
     Generation 19	Aug 27 2018 16:20:48
       guix d894ab8
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: master
         commit: d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300
       meine-persönlichen-pakete dd3df5e
         repository URL: https://example.org/personal-packages.git
         branch: master
         commit: dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb
       11 new packages: mein-gimp, mein-emacs-mit-coolen-features, …
       4 packages upgraded: emacs-racket-mode@0.0.2-2.1b78827, …

Obige Ausgabe von ‘guix pull’ zeigt an, dass Generation 19 sowohl Guix
als auch Pakete aus dem Kanal ‘meine-persönlichen-pakete’ enthält. Unter
den aufgeführten neuen und aktualisierten Paketen kommen vielleicht
manche wie ‘mein-gimp’ und ‘mein-emacs-mit-coolen-features’ aus
‘meine-persönlichen-pakete’, während andere aus dem Standard-Guix-Kanal
kommen.

   Um einen Kanal zu erzeugen, müssen Sie ein Git-Repository mit Ihren
eigenen Paketmodulen erzeugen und den Zugriff darauf ermöglichen. Das
Repository kann beliebigen Inhalt haben, aber wenn es ein nützlicher
Kanal sein soll, muss es Guile-Module enthalten, die Pakete exportieren.
Sobald Sie anfangen, einen Kanal zu benutzen, verhält sich Guix, als
wäre das Wurzelverzeichnis des Git-Repositorys des Kanals in Guiles
Ladepfad enthalten (siehe *note (guile)Load Paths::). Wenn Ihr Kanal
also zum Beispiel eine Datei als ‘my-packages/my-tools.scm’ enthält, die
ein Guile-Modul definiert, dann wird das Modul unter dem Namen
‘(my-packages my-tools)’ verfügbar sein und Sie werden es wie jedes
andere Modul benutzen können (siehe *note (guile)Module::).

4.7.3 Kanalabhängigkeiten deklarieren
-------------------------------------

Kanalautoren können auch beschließen, die Paketsammlung von anderen
Kanälen zu erweitern. Dazu können sie in einer Metadatendatei
‘.guix-channel’ deklarieren, dass ihr Kanal von anderen Kanälen abhängt.
Diese Datei muss im Wurzelverzeichnis des Kanal-Repositorys platziert
werden.

   Die Metadatendatei sollte einen einfachen S-Ausdruck wie diesen
enthalten:

     (channel
      (version 0)
      (dependencies
       (channel
        (name irgendeine-sammlung)
        (url "https://example.org/erste-sammlung.git"))
       (channel
        (name eine-andere-sammlung)
        (url "https://example.org/zweite-sammlung.git")
        (branch "testing"))))

   Im Beispiel oben wird deklariert, dass dieser Kanal von zwei anderen
Kanälen abhängt, die beide automatisch geladen werden. Die vom Kanal
angebotenen Module werden in einer Umgebung kompiliert, in der die
Module all dieser deklarierten Kanäle verfügbar sind.

   Um Verlässlichkeit und Wartbarkeit zu gewährleisten, sollten Sie
darauf verzichten, eine Abhängigkeit von Kanälen herzustellen, die Sie
nicht kontrollieren, außerdem sollten Sie sich auf eine möglichst kleine
Anzahl von Abhängigkeiten beschränken.

4.7.4 Paketmodule in einem Unterverzeichnis
-------------------------------------------

Als Kanalautor möchten Sie vielleicht Ihre Kanalmodule in einem
Unterverzeichnis anlegen. Wenn sich Ihre Module im Unterverzeichnis
‘guix’ befinden, müssen Sie eine Datei ‘.guix-channel’ mit Metadaten
einfügen:

     (channel
       (version 0)
       (directory "guix"))

4.7.5 Kanalneuigkeiten verfassen
--------------------------------

Kanalautoren möchten ihren Nutzern vielleicht manchmal Informationen
über wichtige Änderungen im Kanal zukommen lassen. Man könnte allen eine
E-Mail schicken, aber das wäre unbequem.

   Stattdessen können Kanäle eine Datei mit Neuigkeiten („News File“)
anbieten: Wenn die Kanalnutzer ‘guix pull’ ausführen, wird diese Datei
automatisch ausgelesen. Mit ‘guix pull --news’ kann man sich die
Ankündigungen anzeigen lassen, die den neu gepullten Commits
entsprechen, falls es welche gibt.

   Dazu müssen Kanalautoren zunächst den Namen der Datei mit Neuigkeiten
in der Datei ‘.guix-channel’ nennen:

     (channel
       (version 0)
       (news-file "etc/news.txt"))

   Die Datei mit Neuigkeiten, ‘etc/news.txt’ in diesem Beispiel, muss
selbst etwa so aussehen:

     (channel-news
       (version 0)
       (entry (tag "the-bug-fix")
              (title (en "Fixed terrible bug")
                     (fr "Oh la la"))
              (body (en "@emph{Good news}!  It's fixed!")
                    (eo "Certe ĝi pli bone funkcias nun!")))
       (entry (commit "bdcabe815cd28144a2d2b4bc3c5057b051fa9906")
              (title (en "Added a great package")
                     (ca "Què vol dir guix?"))
              (body (en "Don't miss the @code{hello} package!"))))

   Die Datei setzt sich aus einer Liste von Einträgen mit Neuigkeiten
(„News Entries“) zusammen. Jeder Eintrag ist mit einem Commit oder einem
Tag assoziiert und beschreibt die Änderungen, die in diesem oder auch
vorangehenden Commits gemacht wurden. Benutzer sehen die Einträge nur
beim erstmaligen Übernehmen des Commits, auf den sich der jeweilige
Eintrag bezieht.

   Das ‘title’-Feld sollte eine einzeilige Zusammenfassung sein, während
‘body’ beliebig lang sein kann. Beide können Texinfo-Auszeichnungen
enthalten (siehe *note (texinfo)Overview::). Sowohl ‘title’ als auch
‘body’ sind dabei eine Liste aus Tupeln mit jeweils Sprachcode und
Mitteilung, wodurch ‘guix pull’ Neuigkeiten in derjenigen Sprache
anzeigen kann, die der vom Nutzer eingestellten Locale entspricht.

   Wenn Sie Neuigkeiten mit einem gettext-basierten Arbeitsablauf
übersetzen möchten, können Sie übersetzbare Zeichenketten mit ‘xgettext’
extrahieren (siehe *note (gettext)xgettext Invocation::). Unter der
Annahme, dass Sie Einträge zu Neuigkeiten zunächst auf Englisch
verfassen, können Sie mit diesem Befehl eine PO-Datei erzeugen, die die
zu übersetzenden Zeichenketten enthält:

     xgettext -o news.po -l scheme -ken etc/news.scm

   Kurz gesagt, ja, Sie können Ihren Kanal sogar als Blog missbrauchen.
Aber das ist _nicht ganz_, was Ihre Nutzer erwarten dürften.

4.7.6 Guix nachbilden
---------------------

Die Ausgabe von ‘guix pull --list-generations’ oben zeigt genau, aus
welchen Commits diese Guix-Instanz erstellt wurde. Wir können Guix so
zum Beispiel auf einer anderen Maschine nachbilden, indem wir eine
Kanalspezifikation in ‘~/.config/guix/channels.scm’ angeben, die auf
diese Commits „festgesetzt“ ist.

     ;; Ganz bestimmte Commits der relevanten Kanäle installieren.
     (list (channel
            (name 'guix)
            (url "https://git.savannah.gnu.org/git/guix.git")
            (commit "d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300"))
           (channel
            (name 'meine-persönlichen-pakete)
            (url "https://example.org/personal-packages.git")
            (commit "dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb")))

   Der Befehl ‘guix describe --format=channels’ kann diese Kanalliste
sogar direkt erzeugen (siehe *note Aufruf von guix describe::). Die
erzeugte Datei kann mit den ‘-C’ genannten Befehlszeilenoptionen von
‘guix pull’ (siehe *note Aufruf von guix pull::) oder von ‘guix
time-machine’ (siehe *note Aufruf von time-machine::) benutzt werden.

   Somit läuft auf beiden Maschinen _genau dasselbe Guix_ und es hat
Zugang zu _genau denselben Paketen_. Die Ausgabe von ‘guix build gimp’
auf der einen Maschine wird Bit für Bit genau dieselbe wie die desselben
Befehls auf der anderen Maschine sein. Das bedeutet auch, dass beide
Maschinen Zugang zum gesamten Quellcode von Guix und daher auch
transitiv Zugang zum Quellcode jedes davon definierten Pakets haben.

   Das verleiht Ihnen Superkräfte, mit denen Sie die Provenienz binärer
Artefakte sehr feinkörnig nachverfolgen können und Software-Umgebungen
nach Belieben nachbilden können. Sie können es als eine Art Fähigkeit
zur „Meta-Reproduzierbarkeit“ auffassen, wenn Sie möchten. Der Abschnitt
*note Untergeordnete:: beschreibt eine weitere Möglichkeit, diese
Superkräfte zu nutzen.


File: guix.de.info,  Node: Aufruf von time-machine,  Next: Untergeordnete,  Prev: Kanäle,  Up: Paketverwaltung

4.8 ‘guix time-machine’ aufrufen
================================

Der Befehl ‘guix time-machine’ erleichtert den Zugang zu anderen
Versionen von Guix. Damit können ältere Versionen von Paketen
installiert werden oder eine Berechnung in einer identischen Umgebung
reproduziert werden. Die zu benutzende Guix-Version wird über eine
Commit-Angabe oder eine Kanalbeschreibungsdatei, wie sie durch ‘guix
describe’ erzeugt werden kann, festgelegt (siehe *note Aufruf von guix
describe::).

   Die allgemeine Syntax lautet:

     guix time-machine OPTIONEN… -- BEFEHL ARGUMENT…

   Dabei werden der BEFEHL und jedes ARGUMENT… unverändert an den
‘guix’-Befehl der angegebenen Version übergeben. Die OPTIONEN, die die
Version definieren, sind dieselben wie bei ‘guix pull’ (siehe *note
Aufruf von guix pull::):

‘--url=URL’
‘--commit=COMMIT’
‘--branch=BRANCH’
     Den ‘guix’-Kanal von der angegebenen URL benutzen, für den
     angegebenen COMMIT (eine gültige Commit-ID, dargestellt als
     hexadezimale Zeichenkette) oder BRANCH.

‘--channels=DATEI’
‘-C DATEI’
     Die Liste der Kanäle aus der angegebenen DATEI auslesen. Die DATEI
     muss Scheme-Code enthalten, der zu einer Liste von Kanalobjekten
     ausgewertet wird. Siehe *note Kanäle:: für nähere Informationen.

   Wie bei ‘guix pull’ wird in Ermangelung anderer Optionen der letzte
Commit auf dem master-Branch benutzt. Mit dem Befehl

     guix time-machine -- build hello

   wird dementsprechend das Paket ‘hello’ erstellt, so wie es auf dem
master-Branch definiert ist, was in der Regel einer neueren Guix-Version
entspricht als der, die Sie installiert haben. Zeitreisen funktionieren
also in beide Richtungen!

   Beachten Sie, dass durch ‘guix time-machine’ Erstellungen von Kanälen
und deren Abhängigkeiten ausgelöst werden können, welche durch die
gemeinsamen Erstellungsoptionen gesteuert werden können (siehe *note
Gemeinsame Erstellungsoptionen::).


File: guix.de.info,  Node: Untergeordnete,  Next: Aufruf von guix describe,  Prev: Aufruf von time-machine,  Up: Paketverwaltung

4.9 Untergeordnete
==================

     Anmerkung: Die hier beschriebenen Funktionalitäten sind in der
     Version 1.1.0.411-5c10d bloß eine „Technologie-Vorschau“, daher
     kann sich die Schnittstelle in Zukunft noch ändern.

   Manchmal könnten Sie Pakete aus der gerade laufenden Fassung von Guix
mit denen mischen wollen, die in einer anderen Guix-Version verfügbar
sind. Guix-“Untergeordnete” ermöglichen dies, indem Sie verschiedene
Guix-Versionen beliebig mischen können.

   Aus technischer Sicht ist ein „Untergeordneter“ im Kern ein separater
Guix-Prozess, der über eine REPL (siehe *note Aufruf von guix repl::)
mit Ihrem Haupt-Guix-Prozess verbunden ist. Das Modul ‘(guix inferior)’
ermöglicht es Ihnen, Untergeordnete zu erstellen und mit ihnen zu
kommunizieren. Dadurch steht Ihnen auch eine hochsprachliche
Schnittstelle zur Verfügung, um die von einem Untergeordneten
angebotenen Pakete zu durchsuchen und zu verändern — “untergeordnete
Pakete”.

   In Kombination mit Kanälen (siehe *note Kanäle::) bieten
Untergeordnete eine einfache Möglichkeit, mit einer anderen Version von
Guix zu interagieren. Nehmen wir zum Beispiel an, Sie wollen das
aktuelle ‘guile’-Paket in Ihr Profil installieren, zusammen mit dem
‘guile-json’, wie es in einer früheren Guix-Version existiert hat —
vielleicht weil das neuere ‘guile-json’ eine inkompatible API hat und
Sie daher Ihren Code mit der alten API benutzen möchten. Dazu könnten
Sie ein Manifest für ‘guix package --manifest’ schreiben (siehe *note
Aufruf von guix package::); in diesem Manifest würden Sie einen
Untergeordneten für diese alte Guix-Version erzeugen, für die Sie sich
interessieren, und aus diesem Untergeordneten das ‘guile-json’-Paket
holen:

     (use-modules (guix inferior) (guix channels)
                  (srfi srfi-1))   ;für die Prozedur 'first'

     (define channels
       ;; Dies ist die alte Version, aus der wir
       ;; guile-json extrahieren möchten.
       (list (channel
              (name 'guix)
              (url "https://git.savannah.gnu.org/git/guix.git")
              (commit
               "65956ad3526ba09e1f7a40722c96c6ef7c0936fe"))))

     (define inferior
       ;; Ein Untergeordneter, der obige Version repräsentiert.
       (inferior-for-channels channels))

     ;; Daraus erzeugen wir jetzt ein Manifest mit dem aktuellen
     ;; „guile“-Paket und dem alten „guile-json“-Paket.
     (packages->manifest
      (list (first (lookup-inferior-packages inferior "guile-json"))
            (specification->package "guile")))

   Bei seiner ersten Ausführung könnte für ‘guix package --manifest’
erst der angegebene Kanal erstellt werden müssen, bevor der
Untergeordnete erstellt werden kann; nachfolgende Durchläufe sind
wesentlich schneller, weil diese Guix-Version bereits
zwischengespeichert ist.

   Folgende Prozeduren werden im Modul ‘(guix inferior)’ angeboten, um
einen Untergeordneten zu öffnen:

 -- Scheme-Prozedur: inferior-for-channels KANÄLE [#:cache-directory]
          [#:ttl] Liefert einen Untergeordneten für die
     KANÄLE, einer Liste von Kanälen. Dazu wird der Zwischenspeicher im
     Verzeichnis CACHE-DIRECTORY benutzt, dessen Einträge nach TTL
     Sekunden gesammelt werden dürfen. Mit dieser Prozedur wird eine
     neue Verbindung zum Erstellungs-Daemon geöffnet.

     Als Nebenwirkung erstellt oder substituiert diese Prozedur unter
     Umständen Binärdateien für die KANÄLE, was einige Zeit in Anspruch
     nehmen kann.

 -- Scheme-Prozedur: open-inferior VERZEICHNIS [#:command "bin/guix"]
          Öffnet das untergeordnete Guix mit dem Befehl
     COMMAND im angegebenen VERZEICHNIS durch Ausführung von
     ‘VERZEICHNIS/COMMAND repl’ oder entsprechend. Liefert ‘#f’, wenn
     der Untergeordnete nicht gestartet werden konnte.

   Die im Folgenden aufgeführten Prozeduren ermöglichen es Ihnen,
untergeordnete Pakete abzurufen und zu verändern.

 -- Scheme-Prozedur: inferior-packages UNTERGEORDNETER
     Liefert die Liste der Pakete in UNTERGEORDNETER.

 -- Scheme-Prozedur: lookup-inferior-packages UNTERGEORDNETER NAME
          [VERSION] Liefert die sortierte Liste der untergeordneten
          Pakete in
     UNTERGEORDNETER, die zum Muster NAME in UNTERGEORDNETER passen,
     dabei kommen höhere Versionsnummern zuerst. Wenn VERSION auf wahr
     gesetzt ist, werden nur Pakete geliefert, deren Versionsnummer mit
     dem Präfix VERSION beginnt.

 -- Scheme-Prozedur: inferior-package? OBJEKT
     Liefert wahr, wenn das OBJ ein Untergeordneter ist.

 -- Scheme-Prozedur: inferior-package-name PAKET
 -- Scheme-Prozedur: inferior-package-version PAKET
 -- Scheme-Prozedur: inferior-package-synopsis PAKET
 -- Scheme-Prozedur: inferior-package-description PAKET
 -- Scheme-Prozedur: inferior-package-home-page PAKET
 -- Scheme-Prozedur: inferior-package-location PAKET
 -- Scheme-Prozedur: inferior-package-inputs PAKET
 -- Scheme-Prozedur: inferior-package-native-inputs PAKET
 -- Scheme-Prozedur: inferior-package-propagated-inputs PAKET
 -- Scheme-Prozedur: inferior-package-transitive-propagated-inputs PAKET
 -- Scheme-Prozedur: inferior-package-native-search-paths PAKET
 -- Scheme-Prozedur: inferior-package-transitive-native-search-paths
          PAKET
 -- Scheme-Prozedur: inferior-package-search-paths PAKET
     Diese Prozeduren sind das Gegenstück zu den Zugriffsmethoden des
     Verbunds „package“ für Pakete (siehe *note „package“-Referenz::).
     Die meisten davon funktionieren durch eine Abfrage auf dem
     Untergeordneten, von dem das PAKET kommt, weshalb der
     Untergeordnete noch lebendig sein muss, wenn Sie diese Prozeduren
     aufrufen.

   Untergeordnete Pakete können transparent wie jedes andere Paket oder
dateiartige Objekt in G-Ausdrücken verwendet werden (siehe *note
G-Ausdrücke::). Sie werden auch transparent wie reguläre Pakete von der
Prozedur ‘packages->manifest’ behandelt, welche oft in Manifesten
benutzt wird (siehe *note siehe die Befehlszeilenoption ‘--manifest’ von
‘guix package’: Aufruf von guix package.). Somit können Sie ein
untergeordnetes Paket ziemlich überall dort verwenden, wo Sie ein
reguläres Paket einfügen würden: in Manifesten, im Feld ‘packages’ Ihrer
‘operating-system’-Deklaration und so weiter.


File: guix.de.info,  Node: Aufruf von guix describe,  Next: Aufruf von guix archive,  Prev: Untergeordnete,  Up: Paketverwaltung

4.10 ‘guix describe’ aufrufen
=============================

Sie könnten sich des Öfteren Fragen stellen wie: „Welche Version von
Guix benutze ich gerade?“ oder „Welche Kanäle benutze ich?“ Diese
Informationen sind in vielen Situationen nützlich: wenn Sie eine
Umgebung auf einer anderen Maschine oder mit einem anderen Benutzerkonto
_nachbilden_ möchten, wenn Sie einen Fehler melden möchten, wenn Sie
festzustellen versuchen, welche Änderung an den von Ihnen verwendeten
Kanälen diesen Fehler verursacht hat, oder wenn Sie Ihren Systemzustand
zum Zweck der Reproduzierbarkeit festhalten möchten. Der Befehl ‘guix
describe’ gibt Ihnen Antwort auf diese Fragen.

   Wenn Sie ihn aus einem mit ‘guix pull’ bezogenen ‘guix’ heraus
ausführen, zeigt Ihnen ‘guix describe’ die Kanäle an, aus denen es
erstellt wurde, jeweils mitsamt ihrer Repository-URL und Commit-ID
(siehe *note Kanäle::):

     $ guix describe
     Generation 10	Sep 03 2018 17:32:44	(current)
       guix e0fa68c
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: master
         commit: e0fa68c7718fffd33d81af415279d6ddb518f727

   Wenn Sie mit dem Versionskontrollsystem Git vertraut sind, erkennen
Sie vielleicht die Ähnlichkeit zu ‘git describe’; die Ausgabe ähnelt
auch der von ‘guix pull --list-generations’ eingeschränkt auf die
aktuelle Generation (siehe *note die Befehlszeilenoption
‘--list-generations’: Aufruf von guix pull.). Weil die oben gezeigte
Git-Commit-ID eindeutig eine bestimmte Version von Guix bezeichnet,
genügt diese Information, um die von Ihnen benutzte Version von Guix zu
beschreiben, und auch, um sie nachzubilden.

   Damit es leichter ist, Guix nachzubilden, kann Ihnen ‘guix describe’
auch eine Liste der Kanäle statt einer menschenlesbaren Beschreibung wie
oben liefern:

     $ guix describe -f channels
     (list (channel
             (name 'guix)
             (url "https://git.savannah.gnu.org/git/guix.git")
             (commit
               "e0fa68c7718fffd33d81af415279d6ddb518f727")))

Sie können die Ausgabe in einer Datei speichern, die Sie an ‘guix pull
-C’ auf einer anderen Maschine oder zu einem späteren Zeitpunkt
übergeben, wodurch dann eine Instanz _von genau derselben Guix-Version_
installiert wird (siehe *note die Befehlszeilenoption ‘-C’: Aufruf von
guix pull.). Daraufhin können Sie, weil Sie jederzeit dieselbe Version
von Guix installieren können, auch gleich _eine vollständige
Softwareumgebung genau nachbilden_. Wir halten das trotz aller
Bescheidenheit für _klasse_ und hoffen, dass Ihnen das auch gefällt!

   Die genauen Befehlszeilenoptionen, die ‘guix describe’ unterstützt,
lauten wie folgt:

‘--format=FORMAT’
‘-f FORMAT’
     Die Ausgabe im angegebenen FORMAT generieren, was eines der
     Folgenden sein muss:

     ‘human’
          für menschenlesbare Ausgabe,
     ‘Kanäle’
          eine Liste von Kanalspezifikationen erzeugen, die an ‘guix
          pull -C’ übergeben werden oder als
          ‘~/.config/guix/channels.scm’ eingesetzt werden können (siehe
          *note Aufruf von guix pull::),
     ‘json’
          generiert eine Liste von Kanalspezifikationen im JSON-Format,
     ‘recutils’
          generiert eine Liste von Kanalspezifikationen im
          Recutils-Format.

‘--profile=PROFIL’
‘-p PROFIL’
     Informationen über das PROFIL anzeigen.


File: guix.de.info,  Node: Aufruf von guix archive,  Prev: Aufruf von guix describe,  Up: Paketverwaltung

4.11 ‘guix archive’ aufrufen
============================

Der Befehl ‘guix archive’ ermöglicht es Nutzern, Dateien im Store in
eine einzelne Archivdatei zu “exportieren” und diese später auf einer
Maschine, auf der Guix läuft, zu “importieren”. Insbesondere können so
Store-Objekte von einer Maschine in den Store einer anderen Maschine
übertragen werden.

     Anmerkung: Wenn Sie nach einer Möglichkeit suchen, Archivdateien
     für andere Werkzeuge als Guix zu erstellen, finden Sie
     Informationen dazu im Abschnitt *note Aufruf von guix pack::.

   Führen Sie Folgendes aus, um Store-Dateien als ein Archiv auf die
Standardausgabe zu exportieren:

     guix archive --export OPTIONEN SPEZIFIKATIONEN…

   SPEZIFIKATIONEN sind dabei entweder die Namen von Store-Dateien oder
Paketspezifikationen wie bei ‘guix package’ (siehe *note Aufruf von guix
package::). Zum Beispiel erzeugt der folgende Befehl ein Archiv der
‘gui’-Ausgabe des Pakets ‘git’ sowie die Hauptausgabe von ‘emacs’:

     guix archive --export git:gui /gnu/store/…-emacs-24.3 > groß.nar

   Wenn die angegebenen Pakete noch nicht erstellt worden sind, werden
sie durch ‘guix archive’ automatisch erstellt. Der Erstellungsprozess
kann durch die gemeinsamen Erstellungsoptionen gesteuert werden (siehe
*note Gemeinsame Erstellungsoptionen::).

   Um das ‘emacs’-Paket auf eine über SSH verbundene Maschine zu
übertragen, würde man dies ausführen:

     guix archive --export -r emacs | ssh die-maschine guix archive --import

Auf gleiche Art kann auch ein vollständiges Benutzerprofil von einer
Maschine auf eine andere übertragen werden:

     guix archive --export -r $(readlink -f ~/.guix-profile) | \
       ssh die-maschine guix archive --import

Jedoch sollten Sie in beiden Beispielen beachten, dass alles, was zu
‘emacs’, dem Profil oder deren Abhängigkeiten (wegen ‘-r’) gehört,
übertragen wird, egal ob es schon im Store der Zielmaschine vorhanden
ist oder nicht. Mit der Befehlszeilenoption ‘--missing’ lässt sich
herausfinden, welche Objekte im Ziel-Store noch fehlen. Der Befehl ‘guix
copy’ vereinfacht und optimiert diesen gesamten Prozess, ist also, was
Sie in diesem Fall wahrscheinlich eher benutzen wollten (siehe *note
Aufruf von guix copy::).

   Archive werden als „Normalisiertes Archiv“, kurz „Nar“, formatiert.
Diese Technik folgt einem ähnlichen Gedanken wie beim „tar“-Format,
unterscheidet sich aber auf eine für unsere Zwecke angemessene Art.
Erstens werden im Nar-Format nicht sämtliche Unix-Metadaten aller
Dateien aufgenommen, sondern nur der Dateityp (ob es sich um eine
reguläre Datei, ein Verzeichnis oder eine symbolische Verknüpfung
handelt). Unix-Dateiberechtigungen sowie Besitzer und Gruppe werden
nicht gespeichert. Zweitens entspricht die Reihenfolge, in der der
Inhalt von Verzeichnissen abgelegt wird, immer der Reihenfolge, in der
die Dateinamen gemäß der C-Locale sortiert würden. Dadurch wird die
Erstellung von Archivdateien völlig deterministisch.

   Beim Exportieren versieht der Daemon den Inhalt des Archivs mit einer
digitalen Signatur, auch Beglaubigung genannt. Diese digitale Signatur
wird an das Archiv angehängt. Beim Importieren verifiziert der Daemon
die Signatur und lehnt den Import ab, falls die Signatur ungültig oder
der signierende Schlüssel nicht autorisiert ist.

   Die wichtigsten Befehlszeilenoptionen sind:

‘--export’
     Exportiert die angegebenen Store-Dateien oder Pakete (siehe unten)
     und schreibt das resultierende Archiv auf die Standardausgabe.

     Abhängigkeiten _fehlen_ in der Ausgabe, außer wenn ‘--recursive’
     angegeben wurde.

‘-r’
‘--recursive’
     Zusammen mit ‘--export’ wird ‘guix archive’ hiermit angewiesen,
     Abhängigkeiten der angegebenen Objekte auch ins Archiv aufzunehmen.
     Das resultierende Archiv ist somit eigenständig; es enthält den
     Abschluss der exportierten Store-Objekte.

‘--import’
     Ein Archiv von der Standardeingabe lesen und darin enthaltende
     Dateien in den Store importieren. Der Import bricht ab, wenn das
     Archiv keine gültige digitale Signatur hat oder wenn es von einem
     öffentlichen Schlüssel signiert wurde, der keiner der autorisierten
     Schlüssel ist (siehe ‘--authorize’ weiter unten).

‘--missing’
     Eine Liste der Store-Dateinamen von der Standardeingabe lesen, je
     ein Name pro Zeile, und auf die Standardausgabe die Teilmenge
     dieser Dateien schreiben, die noch nicht im Store vorliegt.

‘--generate-key[=PARAMETER]’
     Ein neues Schlüsselpaar für den Daemon erzeugen. Dies ist
     erforderlich, damit Archive mit ‘--export’ exportiert werden
     können. Beachten Sie, dass diese Option normalerweise einige Zeit
     in Anspruch nimmt, da erst Entropie für die Erzeugung des
     Schlüsselpaares gesammelt werden muss.

     Das erzeugte Schlüsselpaar wird typischerweise unter ‘/etc/guix’
     gespeichert, in den Dateien ‘signing-key.pub’ (für den öffentlichen
     Schlüssel) und ‘signing-key.sec’ (für den privaten Schlüssel, der
     geheim gehalten werden muss). Wurden keine PARAMETERS angegeben,
     wird ein ECDSA-Schlüssel unter Verwendung der Kurve Ed25519
     erzeugt, oder, falls die Libgcrypt-Version älter als 1.6.0 ist, ein
     4096-Bit-RSA-Schlüssel. Sonst geben die PARAMETER für Libgcrypt
     geeignete Parameter für ‘genkey’ an (siehe *note ‘gcry_pk_genkey’:
     (gcrypt)General public-key related Functions.).

‘--authorize’
     Mit dem auf der Standardeingabe übergebenen öffentlichen Schlüssel
     signierte Importe autorisieren. Der öffentliche Schlüssel muss als
     „advanced“-formatierter S-Ausdruck gespeichert sein, d.h. im selben
     Format wie die Datei ‘signing-key.pub’.

     Die Liste autorisierter Schlüssel wird in der Datei ‘/etc/guix/acl’
     gespeichert, die auch von Hand bearbeitet werden kann. Die Datei
     enthält „advanced“-formatierte S-Ausdrücke
     (https://people.csail.mit.edu/rivest/Sexp.txt) und ist als eine
     Access Control List für die Simple Public-Key Infrastructure (SPKI)
     (https://theworld.com/~cme/spki.txt) aufgebaut.

‘--extract=VERZEICHNIS’
‘-x VERZEICHNIS’
     Ein Archiv mit einem einzelnen Objekt lesen, wie es von
     Substitutservern geliefert wird (siehe *note Substitute::), und ins
     VERZEICHNIS entpacken. Dies ist eine systemnahe Operation, die man
     nur selten direkt benutzt; siehe unten.

     Zum Beispiel entpackt folgender Befehl das Substitut für Emacs, wie
     es von ‘ci.guix.gnu.org’ geliefert wird, nach ‘/tmp/emacs’:

          $ wget -O - \
            https://ci.guix.gnu.org/nar/gzip/...-emacs-24.5 \
            | gunzip | guix archive -x /tmp/emacs

     Archive mit nur einem einzelnen Objekt unterscheiden sich von
     Archiven für mehrere Dateien, wie sie ‘guix archive --export’
     erzeugt; sie enthalten nur ein einzelnes Store-Objekt und _keine_
     eingebettete Signatur. Beim Entpacken findet also _keine_
     Signaturprüfung statt und ihrer Ausgabe sollte so erst einmal nicht
     vertraut werden.

     The primary purpose of this operation is to facilitate inspection
     of archive contents coming from possibly untrusted substitute
     servers (*note Aufruf von guix challenge::).

‘--list’
‘-t’
     Ein Archiv mit einem einzelnen Objekt lesen, wie es von
     Substitutservern geliefert wird (siehe *note Substitute::), und die
     Dateien darin ausgeben, wie in diesem Beispiel:

          $ wget -O - \
            https://ci.guix.gnu.org/nar/lzip/…-emacs-26.3 \
            | lzip -d | guix archive -t


File: guix.de.info,  Node: Entwicklung,  Next: Programmierschnittstelle,  Prev: Paketverwaltung,  Up: Top

5 Entwicklung
*************

Wenn Sie ein Software-Entwickler sind, gibt Ihnen Guix Werkzeuge an die
Hand, die Sie für hilfreich erachten dürften — ganz unabhängig davon, in
welcher Sprache Sie entwickeln. Darum soll es in diesem Kapitel gehen.

   Der Befehl ‘guix environment’ stellt eine bequeme Möglichkeit dar,
wie Sie eine “Entwicklungsumgebung” aufsetzen können, in der all die
Abhängigkeiten und Werkzeuge enthalten sind, die Sie brauchen, wenn Sie
an Ihrem Lieblingssoftwarepaket arbeiten. Der Befehl ‘guix pack’ macht
es Ihnen möglich, “Anwendungsbündel” zu erstellen, die leicht an Nutzer
verteilt werden können, die kein Guix benutzen.

* Menu:

* Aufruf von guix environment::  Entwicklungsumgebungen einrichten.
* Aufruf von guix pack::     Software-Bündel erstellen.


File: guix.de.info,  Node: Aufruf von guix environment,  Next: Aufruf von guix pack,  Up: Entwicklung

5.1 ‘guix environment’ aufrufen
===============================

Der Zweck von ‘guix environment’ ist es, Hacker beim Aufbau einer
reproduzierbaren Entwicklungsumgebung zu unterstützen, ohne dass diese
ihr Paketprofil verunreinigen müssen. Das Werkzeug ‘guix environment’
nimmt eines oder mehrere Pakete entgegen und erstellt erst all ihre
Eingaben, um dann eine Shell-Umgebung herzustellen, in der diese benutzt
werden können.

   Die allgemeine Syntax lautet:

     guix environment OPTIONEN PAKET…

   Folgendes Beispiel zeigt, wie eine neue Shell gestartet wird, auf der
alles für die Entwicklung von GNU Guile eingerichtet ist:

     guix environment guile

   Wenn benötigte Abhängigkeiten noch nicht erstellt worden sind, wird
‘guix environment’ sie automatisch erstellen lassen. Die Umgebung der
neuen Shell ist eine ergänzte Version der Umgebung, in der ‘guix
environment’ ausgeführt wurde. Sie enthält neben den existierenden
Umgebungsvariablen auch die nötigen Suchpfade, um das angegebene Paket
erstellen zu können. Um eine „reine“ Umgebung zu erstellen, in der die
ursprünglichen Umgebungsvariablen nicht mehr vorkommen, kann die
Befehlszeilenoption ‘--pure’ benutzt werden(1).

   ‘guix environment’ definiert die Variable ‘GUIX_ENVIRONMENT’ in der
neu erzeugten Shell. Ihr Wert ist der Dateiname des Profils dieser neuen
Umgebung. Das könnten Nutzer verwenden, um zum Beispiel eine besondere
Prompt als Eingabeaufforderung für Entwicklungsumgebungen in ihrer
‘.bashrc’ festzulegen (siehe *note (bash)Bash Startup Files::):

     if [ -n "$GUIX_ENVIRONMENT" ]
     then
         export PS1="\u@\h \w [dev]\$ "
     fi

… oder um ihr Profil durchzusehen:

     $ ls "$GUIX_ENVIRONMENT/bin"

   Des Weiteren kann mehr als ein Paket angegeben werden. In diesem Fall
wird die Vereinigung der Eingaben der jeweiligen Pakete zugänglich
gemacht. Zum Beispiel erzeugt der folgende Befehl eine Shell, in der
alle Abhängigkeiten von sowohl Guile als auch Emacs verfügbar sind:

     guix environment guile emacs

   Manchmal will man keine interaktive Shell-Sitzung. Ein beliebiger
Befehl kann aufgerufen werden, indem man nach Angabe der Pakete noch
‘--’ vor den gewünschten Befehl schreibt, um ihn von den übrigen
Argumenten abzutrennen:

     guix environment guile -- make -j4

   In anderen Situationen ist es bequemer, aufzulisten, welche Pakete in
der Umgebung benötigt werden. Zum Beispiel führt der folgende Befehl
‘python’ aus einer Umgebung heraus aus, in der Python 2.7 und NumPy
enthalten sind:

     guix environment --ad-hoc python2-numpy python-2.7 -- python

   Man kann auch sowohl die Abhängigkeiten eines Pakets haben wollen,
als auch ein paar zusätzliche Pakete, die nicht Erstellungs- oder
Laufzeitabhängigkeiten davon sind, aber trotzdem bei der Entwicklung
nützlich sind. Deshalb hängt die Wirkung von der Position der
Befehlszeilenoption ‘--ad-hoc’ ab. Pakete, die links von ‘--ad-hoc’
stehen, werden als Pakete interpretiert, deren Abhängigkeiten zur
Umgebung hinzugefügt werden. Pakete, die rechts stehen, werden selbst
zur Umgebung hinzugefügt. Zum Beispiel erzeugt der folgende Befehl eine
Guix-Entwicklungsumgebung, die zusätzlich Git und strace umfasst:

     guix environment --pure guix --ad-hoc git strace

   Manchmal ist es wünschenswert, die Umgebung so viel wie möglich zu
isolieren, um maximale Reinheit und Reproduzierbarkeit zu bekommen.
Insbesondere ist es wünschenswert, den Zugriff auf ‘/usr/bin’ und andere
Systemressourcen aus der Entwicklungsumgebung heraus zu verhindern, wenn
man Guix auf einer fremden Wirtsdistribution benutzt, die nicht Guix
System ist. Zum Beispiel startet der folgende Befehl eine Guile-REPL in
einer isolierten Umgebung, einem sogenannten „Container“, in der nur der
Store und das aktuelle Arbeitsverzeichnis eingebunden sind:

     guix environment --ad-hoc --container guile -- guile

     Anmerkung: Die Befehlszeilenoption ‘--container’ funktioniert nur
     mit Linux-libre 3.19 oder neuer.

   Im Folgenden werden die verfügbaren Befehlszeilenoptionen
zusammengefasst.

‘--root=DATEI’
‘-r DATEI’
     Die DATEI zu einer symbolischen Verknüpfung auf das Profil dieser
     Umgebung machen und als eine Müllsammlerwurzel registrieren.

     Das ist nützlich, um seine Umgebung vor dem Müllsammler zu schützen
     und sie „persistent“ zu machen.

     Wird diese Option weggelassen, ist die Umgebung nur, solange die
     Sitzung von ‘guix environment’ besteht, vor dem Müllsammler sicher.
     Das bedeutet, wenn Sie das nächste Mal dieselbe Umgebung neu
     erzeugen, müssen Sie vielleicht Pakete neu erstellen oder neu
     herunterladen. *note Aufruf von guix gc:: hat mehr Informationen
     über Müllsammlerwurzeln.

‘--expression=AUSDRUCK’
‘-e AUSDRUCK’
     Eine Umgebung für das Paket oder die Liste von Paketen erzeugen, zu
     der der AUSDRUCK ausgewertet wird.

     Zum Beispiel startet dies:

          guix environment -e '(@ (gnu packages maths) petsc-openmpi)'

     eine Shell mit der Umgebung für eben diese bestimmte Variante des
     Pakets PETSc.

     Wenn man dies ausführt:

          guix environment --ad-hoc -e '(@ (gnu) %base-packages)'

     bekommt man eine Shell, in der alle Basis-Pakete verfügbar sind.

     Die obigen Befehle benutzen nur die Standard-Ausgabe des jeweiligen
     Pakets. Um andere Ausgaben auszuwählen, können zweielementige Tupel
     spezifiziert werden:

          guix environment --ad-hoc -e '(list (@ (gnu packages bash) bash) "include")'

‘--load=DATEI’
‘-l DATEI’
     Eine Umgebung erstellen für das Paket oder die Liste von Paketen,
     zu der der Code in der DATEI ausgewertet wird.

     Zum Beispiel könnte die DATEI eine Definition wie diese enthalten
     (siehe *note Pakete definieren::):

          (use-modules (guix)
                       (gnu packages gdb)
                       (gnu packages autotools)
                       (gnu packages texinfo))
          
          ;; Augment the package definition of GDB with the build tools
          ;; needed when developing GDB (and which are not needed when
          ;; simply installing it.)
          (package (inherit gdb)
            (native-inputs `(("autoconf" ,autoconf-2.64)
                             ("automake" ,automake)
                             ("texinfo" ,texinfo)
                             ,@(package-native-inputs gdb))))

‘--manifest=DATEI’
‘-m DATEI’
     Eine Umgebung für die Pakete erzeugen, die im Manifest-Objekt
     enthalten sind, das vom Scheme-Code in der DATEI geliefert wird.
     Wenn diese Befehlszeilenoption mehrmals wiederholt angegeben wird,
     werden die Manifeste aneinandergehängt.

     Dies verhält sich ähnlich wie die gleichnamige Option des Befehls
     ‘guix package’ (siehe *note ‘--manifest’: profile-manifest.) und
     benutzt auch dieselben Manifestdateien.

‘--ad-hoc’
     Alle angegebenen Pakete in der resultierenden Umgebung
     einschließen, als wären sie Eingaben eines ad hoc definierten
     Pakets. Diese Befehlszeilenoption ist nützlich, um schnell
     Umgebungen aufzusetzen, ohne dafür einen Paketausdruck schreiben zu
     müssen, der die gewünschten Eingaben enthält.

     Zum Beispiel wird mit diesem Befehl:

          guix environment --ad-hoc guile guile-sdl -- guile

     ‘guile’ in einer Umgebung ausgeführt, in der sowohl Guile als auch
     Guile-SDL zur Verfügung stehen.

     Beachten Sie, dass in diesem Beispiel implizit die vorgegebene
     Ausgabe von ‘guile’ und ‘guile-sdl’ verwendet wird, es aber auch
     möglich ist, eine bestimmte Ausgabe auszuwählen — z.B. wird mit
     ‘glib:bin’ die Ausgabe ‘bin’ von ‘glib’ gewählt (siehe *note Pakete
     mit mehreren Ausgaben.::).

     Diese Befehlszeilenoption kann mit dem standardmäßigen Verhalten
     von ‘guix environment’ verbunden werden. Pakete, die vor ‘--ad-hoc’
     aufgeführt werden, werden als Pakete interpretiert, deren
     Abhängigkeiten zur Umgebung hinzugefügt werden, was dem
     standardmäßigen Verhalten entspricht. Pakete, die danach aufgeführt
     werden, werden selbst zur Umgebung hinzugefügt.

‘--pure’
     Bestehende Umgebungsvariable deaktivieren, wenn die neue Umgebung
     erzeugt wird, mit Ausnahme der mit ‘--preserve’ angegebenen
     Variablen (siehe unten). Dies bewirkt, dass eine Umgebung erzeugt
     wird, in der die Suchpfade nur Paketeingaben nennen und sonst
     nichts.

‘--preserve=REGEXP’
‘-E REGEXP’
     Wenn das hier zusammen mit ‘--pure’ angegeben wird, bleiben die zum
     regulären Ausdruck REGEXP passenden Umgebungsvariablen erhalten —
     mit anderen Worten werden sie auf eine „weiße Liste“ von
     Umgebungsvariablen gesetzt, die erhalten bleiben müssen. Diese
     Befehlszeilenoption kann mehrmals wiederholt werden.

          guix environment --pure --preserve=^SLURM --ad-hoc openmpi … \
            -- mpirun …

     In diesem Beispiel wird ‘mpirun’ in einem Kontext ausgeführt, in
     dem die einzig definierten Umgebungsvariablen ‘PATH’ und solche
     sind, deren Name mit ‘SLURM’ beginnt, sowie die üblichen besonders
     „kostbaren“ Variablen (‘HOME’, ‘USER’, etc.).

‘--search-paths’
     Die Umgebungsvariablendefinitionen anzeigen, aus denen die Umgebung
     besteht.

‘--system=SYSTEM’
‘-s SYSTEM’
     Versuchen, für das angegebene SYSTEM zu erstellen — z.B.
     ‘i686-linux’.

‘--container’
‘-C’
     Den BEFEHL in einer isolierten Umgebung (einem sogenannten
     „Container“) ausführen. Das aktuelle Arbeitsverzeichnis außerhalb
     des Containers wird in den Container zugeordnet. Zusätzlich wird,
     wenn es mit der Befehlszeilenoption ‘--user’ nicht anders
     spezifiziert wurde, ein stellvertretendes persönliches Verzeichnis
     erzeugt, dessen Inhalt der des wirklichen persönlichen
     Verzeichnisses ist, sowie eine passend konfigurierte Datei
     ‘/etc/passwd’.

     Der erzeugte Prozess läuft außerhalb des Containers als der
     momentane Nutzer. Innerhalb des Containers hat er dieselbe UID und
     GID wie der momentane Nutzer, außer die Befehlszeilenoption
     ‘--user’ wird übergeben (siehe unten).

‘--network’
‘-N’
     Bei isolierten Umgebungen („Containern“) wird hiermit der
     Netzwerk-Namensraum mit dem des Wirtssystems geteilt. Container,
     die ohne diese Befehlszeilenoption erzeugt wurden, haben nur
     Zugriff auf das Loopback-Gerät.

‘--link-profile’
‘-P’
     Bei isolierten Umgebungen („Containern“) wird das Umgebungsprofil
     im Container als ‘~/.guix-profile’ verknüpft. Das ist äquivalent
     dazu, den Befehl ‘ln -s $GUIX_ENVIRONMENT ~/.guix-profile’ im
     Container auszuführen. Wenn das Verzeichnis bereits existiert,
     schlägt das Verknüpfen fehl und die Umgebung wird nicht
     hergestellt. Dieser Fehler wird immer eintreten, wenn ‘guix
     environment’ im persönlichen Verzeichnis des Benutzers aufgerufen
     wurde.

     Bestimmte Pakete sind so eingerichtet, dass sie in
     ‘~/.guix-profile’ nach Konfigurationsdateien und Daten suchen,(2)
     weshalb ‘--link-profile’ benutzt werden kann, damit sich diese
     Programme auch in der isolierten Umgebung wie erwartet verhalten.

‘--user=BENUTZER’
‘-u BENUTZER’
     Bei isolierten Umgebungen („Containern“) wird der Benutzername
     BENUTZER anstelle des aktuellen Benutzers benutzt. Der erzeugte
     Eintrag in ‘/etc/passwd’ im Container wird also den Namen BENUTZER
     enthalten und das persönliche Verzeichnis wird den Namen
     ‘/home/BENUTZER’ tragen; keine GECOS-Daten über den Nutzer werden
     in die Umgebung übernommen. Des Weiteren sind UID und GID innerhalb
     der isolierten Umgebung auf 1000 gesetzt. BENUTZER muss auf dem
     System nicht existieren.

     Zusätzlich werden alle geteilten oder exponierten Pfade (siehe
     jeweils ‘--share’ und ‘--expose’), deren Ziel innerhalb des
     persönlichen Verzeichnisses des aktuellen Benutzers liegt, relativ
     zu ‘/home/BENUTZER’ erscheinen, einschließlich der automatischen
     Zuordnung des aktuellen Arbeitsverzeichnisses.

          # wird Pfade als /home/foo/wd, /home/foo/test und /home/foo/target exponieren
          cd $HOME/wd
          guix environment --container --user=foo \
               --expose=$HOME/test \
               --expose=/tmp/target=$HOME/target

     Obwohl dies das Datenleck von Nutzerdaten durch Pfade im
     persönlichen Verzeichnis und die Benutzereinträge begrenzt, kann
     dies nur als Teil einer größeren Lösung für Datenschutz und
     Anonymität sinnvoll eingesetzt werden. Es sollte nicht für sich
     allein dazu eingesetzt werden.

‘--no-cwd’
     In isolierten Umgebungen („Containern“) ist das vorgegebene
     Verhalten, das aktuelle Arbeitsverzeichnis mit dem isolierten
     Container zu teilen und in der Umgebung sofort in dieses
     Verzeichnis zu wechseln. Wenn das nicht gewünscht wird, kann das
     Angeben von ‘--no-cwd’ dafür sorgen, dass das Arbeitsverzeichnis
     _nicht_ automatisch geteilt wird und stattdessen in das Persönliche
     Verzeichnis („Home“-Verzeichnis) gewechselt wird. Siehe auch
     ‘--user’.

‘--expose=QUELLE[=ZIEL]’
‘--share=QUELLE[=ZIEL]’
     Bei isolierten Umgebungen („Containern“) wird das Dateisystem unter
     QUELLE vom Wirtssystem als Nur-Lese-Dateisystem ZIEL (bzw. für
     ‘--share’ auch mit Schreibrechten) im Container zugänglich gemacht.
     Wenn kein ZIEL angegeben wurde, wird die QUELLE auch als
     Ziel-Einhängepunkt in der isolierten Umgebung benutzt.

     Im folgenden Beispiel wird eine Guile-REPL in einer isolierten
     Umgebung gestartet, in der das persönliche Verzeichnis des
     Benutzers als Verzeichnis ‘/austausch’ nur für Lesezugriffe
     zugänglich gemacht wurde:

          guix environment --container --expose=$HOME=/austausch --ad-hoc guile -- guile

   ‘guix environment’ unterstützt auch alle gemeinsamen
Erstellungsoptionen, die von ‘guix build’ unterstützt werden (siehe
*note Gemeinsame Erstellungsoptionen::), und die
Paketumwandlungsoptionen (siehe *note Paketumwandlungsoptionen::).

   ---------- Footnotes ----------

   (1) Manchmal ergänzen Nutzer fälschlicherweise Umgebungsvariable wie
‘PATH’ in ihrer ‘~/.bashrc’-Datei. Das hat zur Folge, dass wenn ‘guix
environment’ Bash startet, selbige ‘~/.bashrc’ von Bash gelesen wird und
die neuen Umgebungen somit „verunreinigt“. Es ist ein Fehler, solche
Umgebungsvariable in ‘.bashrc’ zu definieren, stattdessen sollten sie in
‘.bash_profile’ geschrieben werden, was nur von Login-Shells mit
„source“ geladen wird. Siehe *note (bash)Bash Startup Files:: für
Details über beim Starten von Bash gelesene Dateien

   (2) Zum Beispiel inspiziert das Paket ‘fontconfig’ das Verzeichnis
‘~/.guix-profile/share/fonts’, um zusätzliche Schriftarten zu finden.


File: guix.de.info,  Node: Aufruf von guix pack,  Prev: Aufruf von guix environment,  Up: Entwicklung

5.2 ‘guix pack’ aufrufen
========================

Manchmal möchten Sie Software an Leute weitergeben, die (noch!) nicht
das Glück haben, Guix zu benutzen. Mit Guix würden sie nur ‘guix package
-i IRGENDETWAS’ einzutippen brauchen, aber wenn sie kein Guix haben,
muss es anders gehen. Hier kommt ‘guix pack’ ins Spiel.

     Anmerkung: Wenn Sie aber nach einer Möglichkeit suchen,
     Binärdateien unter Maschinen auszutauschen, auf denen Guix bereits
     läuft, sollten Sie einen Blick auf die Abschnitte *note Aufruf von
     guix copy::, *note Aufruf von guix publish:: und *note Aufruf von
     guix archive:: werfen.

   Der Befehl ‘guix pack’ erzeugt ein gut verpacktes “Software-Bündel”:
Konkret wird dadurch ein Tarball oder eine andere Art von Archiv mit den
Binärdateien der Software erzeugt, die Sie sich gewünscht haben,
zusammen mit all ihren Abhängigkeiten. Der resultierende Archiv kann
auch auf jeder Maschine genutzt werden, die kein Guix hat, und jeder
kann damit genau dieselben Binärdateien benutzen, die Ihnen unter Guix
zur Verfügung stehen. Das Bündel wird dabei auf eine Bit für Bit
reproduzierbare Art erzeugt, damit auch jeder nachprüfen kann, dass
darin wirklich diejenigen Binärdateien enthalten sind, von denen Sie es
behaupten.

   Um zum Beispiel ein Bündel mit Guile, Emacs, Geiser und all ihren
Abhängigkeiten zu erzeugen, führen Sie diesen Befehl aus:

     $ guix pack guile emacs geiser
     …
     /gnu/store/…-pack.tar.gz

   Als Ergebnis erhalten Sie einen Tarball mit einem Verzeichnis
‘/gnu/store’, worin sich alles relevanten Pakete befinden. Der
resultierende Tarball enthält auch ein “Profil” mit den drei angegebenen
Paketen; es ist dieselbe Art von Profil, die auch ‘guix package -i’
erzeugen würde. Mit diesem Mechanismus wird auch der binäre Tarball zur
Installation von Guix erzeugt (siehe *note Aus Binärdatei
installieren::).

   Benutzer des Bündels müssten dann aber zum Beispiel
‘/gnu/store/…-profile/bin/guile’ eintippen, um Guile auszuführen, was
Ihnen zu unbequem sein könnte. Ein Ausweg wäre, dass Sie etwa eine
symbolische Verknüpfung ‘/opt/gnu/bin’ auf das Profil anlegen:

     guix pack -S /opt/gnu/bin=bin guile emacs geiser

Benutzer müssten dann nur noch ‘/opt/gnu/bin/guile’ eintippen, um Guile
zu genießen.

   Doch was ist, wenn die Empfängerin Ihres Bündels keine
Administratorrechte auf ihrer Maschine hat, das Bündel also nicht ins
Wurzelverzeichnis ihres Dateisystems entpacken kann? Dann möchten Sie
vielleicht die Befehlszeilenoption ‘--relocatable’ benutzen (siehe
weiter unten). Mit dieser Option werden “verschiebliche Binärdateien”
erzeugt, die auch in einem beliebigen anderen Verzeichnis in der
Dateisystemhierarchie abgelegt und von dort ausgeführt werden können.
Man könnte sagen, sie sind pfad-agnostisch. In obigem Beispiel würden
Benutzer Ihren Tarball in ihr Persönliches Verzeichnis (das
„Home“-Verzeichnis) entpacken und von dort den Befehl
‘./opt/gnu/bin/guile’ ausführen.

   Eine weitere Möglichkeit ist, das Bündel im Format eines
Docker-Abbilds (englisch Docker-Image) zu erzeugen. Das geht mit dem
folgenden Befehl:

     guix pack -f docker -S /bin=bin guile guile-readline

Das Ergebnis ist ein Tarball, der dem Befehl ‘docker load’ übergeben
werden kann, gefolgt von ‘docker run’:

     docker load < DATEI
     docker run -ti guile-guile-readline /bin/guile

Dabei steht DATEI für das durch GUIX PACK gelieferte Abbild und
‘guile-guile-readline’ für den „Image-Tag“, der diesem zugewiesen wurde.
In der Dokumentation von Docker
(https://docs.docker.com/engine/reference/commandline/load/) finden Sie
nähere Informationen.

   Und noch eine weitere Möglichkeit ist, dass Sie ein SquashFS-Abbild
mit folgendem Befehl erzeugen:

     guix pack -f squashfs bash guile emacs geiser

Das Ergebnis ist ein SquashFS-Dateisystemabbild, dass entweder als
Dateisystem eingebunden oder mit Hilfe der
Singularity-Container-Ausführungsumgebung (https://singularity.lbl.gov)
als Dateisystemcontainer benutzt werden kann, mit Befehlen wie
‘singularity shell’ oder ‘singularity exec’.

   Es gibt mehrere Befehlszeilenoptionen, mit denen Sie Ihr Bündel
anpassen können:

‘--format=FORMAT’
‘-f FORMAT’
     Generiert ein Bündel im angegebenen FORMAT.

     Die verfügbaren Formate sind:

     ‘tarball’
          Das standardmäßig benutzte Format. Damit wird ein Tarball
          generiert, der alle angegebenen Binärdateien und symbolischen
          Verknüpfungen enthält.

     ‘docker’
          Generiert einen Tarball gemäß der Spezifikation für
          Docker-Abbilder
          (https://github.com/docker/docker/blob/master/image/spec/v1.2.md).
          Der „Repository-Name“, wie er in der Ausgabe des Befehls
          ‘docker images’ erscheint, wird anhand der Paketnamen
          berechnet, die auf der Befehlszeile oder in der Manifest-Datei
          angegeben wurden.

     ‘squashfs’
          Generiert ein SquashFS-Abbild, das alle angegebenen
          Binärdateien und symbolischen Verknüpfungen enthält, sowie
          leere Einhängepunkte für virtuelle Dateisysteme wie procfs.

               Anmerkung: Für Singularity _müssen_ Sie eine ‘/bin/sh’ in
               das Abbild aufnehmen. Aus diesem Grund gilt für ‘guix
               pack -f squashfs’ implizit immer auch ‘-S /bin=bin’.
               Daher muss Ihr Aufruf von ‘guix pack’ immer ungefähr so
               beginnen:

                    guix pack -f squashfs bash …

               Wenn Sie vergessen, das ‘bash’-Paket (oder etwas
               Ähnliches) zu bündeln, werden ‘singularity run’ und
               ‘singularity exec’ mit der wenig hilfreichen Meldung
               „Datei oder Verzeichnis nicht gefunden“ scheitern.

‘--relocatable’
‘-R’
     Erzeugt “verschiebliche Binärdateien” — also pfad-agnostische,
     „portable“ Binärdateien, die an einer beliebigen Stelle in der
     Dateisystemhierarchie platziert und von dort ausgeführt werden
     können.

     Wenn diese Befehlszeilenoption einmal übergeben wird, funktionieren
     die erzeugten Binärdateien nur dann, wenn “Benutzernamensräume” des
     Linux-Kernels unterstützt werden. Wenn sie _zweimal_(1) übergeben
     wird, laufen die Binärdateien notfalls mit PRoot, wenn keine
     Benutzernamensräume zur Verfügung stehen, funktionieren also
     ziemlich überall — siehe unten für die Auswirkungen.

     Zum Beispiel können Sie ein Bash enthalltendes Bündel erzeugen mit:

          guix pack -RR -S /mybin=bin bash

     … Sie können dieses dann auf eine Maschine ohne Guix kopieren und
     als normaler Nutzer aus Ihrem Persönlichen Verzeichnis (auch
     „Home“-Verzeichnis genannt) dann ausführen mit:

          tar xf pack.tar.gz
          ./meine-bin/sh

     Wenn Sie in der so gestarteten Shell dann ‘ls /gnu/store’
     eintippen, sehen Sie, dass Ihnen angezeigt wird, in ‘/gnu/store’
     befänden sich alle Abhängigkeiten von ‘bash’, obwohl auf der
     Maschine überhaupt kein Verzeichnis ‘/gnu/store’ existiert! Dies
     ist vermutlich die einfachste Art, mit Guix erstellte Software für
     eine Maschine ohne Guix auszuliefern.

          Anmerkung: Wenn die Voreinstellung verwendet wird,
          funktionieren verschiebliche Binärdateien nur mit
          “Benutzernamensräumen” (englisch “User namespaces”), einer
          Funktionalität des Linux-Kernels, mit der Benutzer ohne
          besondere Berechtigungen Dateisysteme einbinden (englisch
          „mount“) oder die Wurzel des Dateisystems wechseln können
          („change root“, kurz „chroot“). Alte Versionen von Linux haben
          diese Funktionalität noch nicht unterstützt und manche
          Distributionen von GNU/Linux schalten sie ab.

          Um verschiebliche Binärdateien zu erzeugen, die auch ohne
          Benutzernamensräume funktionieren, können Sie die
          Befehlszeilenoption ‘--relocatable’ oder ‘-R’ _zweimal_
          angeben. In diesem Fall werden die Binärdateien zuerst
          überprüfen, ob Benutzernamensräume unterstützt werden, und
          sonst notfalls PRoot benutzen, um das Programm auszuführen,
          wenn Benutzernamensräume nicht unterstützt werden.

          Das Programm PRoot (https://proot-me.github.io/) bietet auch
          Unterstützung für Dateisystemvirtualisierung, indem der
          Systemaufruf ‘ptrace’ auf das laufende Programm angewendet
          wird. Dieser Ansatz funktioniert auch ohne besondere
          Kernel-Unterstützung, aber das Programm braucht mehr Zeit, um
          selbst Systemaufrufe durchzuführen.

‘--entry-point=BEFEHL’
     Den BEFEHL als den “Einsprungpunkt” des erzeugten Bündels
     verwenden, wenn das Bündelformat einen solchen unterstützt —
     derzeit tun das ‘docker’ und ‘squashfs’ (Singularity). Der BEFEHL
     wird relativ zum Profil ausgeführt, das sich im Bündel befindet.

     Der Einsprungpunkt gibt den Befehl an, der mit ‘docker run’ oder
     ‘singularity run’ beim Start nach Voreinstellung automatisch
     ausgeführt wird. Zum Beispiel können Sie das hier benutzen:

          guix pack -f docker --entry-point=bin/guile guile

     Dann kann das erzeugte Bündel mit z.B. ‘docker run’ ohne weitere
     Befehlszeilenargumente einfach geladen und ausgeführt werden, um
     ‘bin/guile’ zu starten:

          docker load -i pack.tar.gz
          docker run ABBILD-ID

‘--expression=AUSDRUCK’
‘-e AUSDRUCK’
     Als Paket benutzen, wozu der AUSDRUCK ausgewertet wird.

     Der Zweck hiervon ist derselbe wie bei der gleichnamigen
     Befehlszeilenoption in ‘guix build’ (siehe *note ‘--expression’ in
     ‘guix build’: Zusätzliche Erstellungsoptionen.).

‘--manifest=DATEI’
‘-m DATEI’
     Die Pakete benutzen, die im Manifest-Objekt aufgeführt sind, das
     vom Scheme-Code in der angegebenen DATEI geliefert wird. Wenn diese
     Befehlszeilenoption mehrmals wiederholt angegeben wird, werden die
     Manifeste aneinandergehängt.

     Dies hat einen ähnlichen Zweck wie die gleichnamige
     Befehlszeilenoption in ‘guix package’ (siehe *note ‘--manifest’:
     profile-manifest.) und benutzt dieselben Regeln für
     Manifest-Dateien. Damit können Sie eine Reihe von Paketen einmal
     definieren und dann sowohl zum Erzeugen von Profilesn als auch zum
     Erzeugen von Archiven benutzen, letztere für Maschinen, auf denen
     Guix nicht installiert ist. Beachten Sie, dass Sie _entweder_ eine
     Manifest-Datei _oder_ eine Liste von Paketen angeben können, aber
     nicht beides.

‘--system=SYSTEM’
‘-s SYSTEM’
     Versuchen, für die angegebene Art von SYSTEM geeignete Binärdateien
     zu erstellen — z.B. ‘i686-linux’ — statt für die Art von System,
     das die Erstellung durchführt.

‘--target=TRIPEL’
     Lässt für das angegebene TRIPEL cross-erstellen, dieses muss ein
     gültiges GNU-Tripel wie z.B. ‘"mips64el-linux-gnu"’ sein (siehe
     *note GNU configuration triplets: (autoconf)Specifying target
     triplets.).

‘--compression=WERKZEUG’
‘-C WERKZEUG’
     Komprimiert den resultierenden Tarball mit dem angegebenen WERKZEUG
     — dieses kann ‘gzip’, ‘bzip2’, ‘xz’, ‘lzip’ oder ‘none’ für keine
     Kompression sein.

‘--symlink=SPEZIFIKATION’
‘-S SPEZIFIKATION’
     Fügt die in der SPEZIFIKATION festgelegten symbolischen
     Verknüpfungen zum Bündel hinzu. Diese Befehlszeilenoption darf
     mehrmals vorkommen.

     Die SPEZIFIKATION muss von der Form ‘QUELLORT=ZIELORT’ sein, wobei
     der QUELLORT der Ort der symbolischen Verknüpfung, die erstellt
     wird, und ZIELORT das Ziel der symbolischen Verknüpfung ist.

     Zum Beispiel wird mit ‘-S /opt/gnu/bin=bin’ eine symbolische
     Verknüpfung ‘/opt/gnu/bin’ auf das Unterverzeichnis ‘bin’ im Profil
     erzeugt.

‘--save-provenance’
     Provenienzinformationen für die auf der Befehlszeile übergebenen
     Pakete speichern. Zu den Provenienzinformationen gehören die URL
     und der Commit jedes benutzten Kanals (siehe *note Kanäle::).

     Provenienzinformationen werden in der Datei
     ‘/gnu/store/…-profile/manifest’ im Bündel zusammen mit den üblichen
     Paketmetadaten abgespeichert — also Name und Version jedes Pakets,
     welche Eingaben dabei propagiert werden und so weiter. Die
     Informationen nützen den Empfängern des Bündels, weil sie dann
     wissen, woraus das Bündel (angeblich) besteht.

     Der Vorgabe nach wird diese Befehlszeilenoption _nicht_ verwendet,
     weil Provenienzinformationen genau wie Zeitstempel nichts zum
     Erstellungsprozess beitragen. Mit anderen Worten gibt es unendlich
     viele Kanal-URLs und Commit-IDs, aus denen dasselbe Bündel stammen
     könnte. Wenn solche „stillen“ Metadaten Teil des Ausgabe sind, dann
     wird also die bitweise Reproduzierbarkeit von Quellcode zu
     Binärdateien eingeschränkt.

‘--root=DATEI’
‘-r DATEI’
     Die DATEI zu einer symbolischen Verknüpfung auf das erzeugte Bündel
     machen und als Müllsammlerwurzel registrieren.

‘--localstatedir’
‘--profile-name=NAME’
     Das „lokale Zustandsverzeichnis“ ‘/var/guix’ ins resultierende
     Bündel aufnehmen, speziell auch das Profil
     ‘/var/guix/profiles/per-user/root/NAME’ — der vorgegebene NAME ist
     ‘guix-profile’, was ‘~root/.guix-profile’ entspricht.

     ‘/var/guix’ enthält die Store-Datenbank (siehe *note Der Store::)
     sowie die Müllsammlerwurzeln (siehe *note Aufruf von guix gc::). Es
     ins Bündel aufzunehmen, bedeutet, dass der enthaltene Store
     „vollständig“ ist und von Guix verwaltet werden kann, andernfalls
     wäre der Store im Bündel „tot“ und nach dem Auspacken des Bündels
     könnte Guix keine Objekte mehr dort hinzufügen oder entfernen.

     Ein Anwendungsfall hierfür ist der eigenständige, alle Komponenten
     umfassende binäre Tarball von Guix (siehe *note Aus Binärdatei
     installieren::).

‘--derivation’
‘-d’
     Den Namen der Ableitung ausgeben, die das Bündel erstellt.

‘--bootstrap’
     Mit den Bootstrap-Binärdateien das Bündel erstellen. Diese Option
     ist nur für Guix-Entwickler nützlich.

   Außerdem unterstützt ‘guix pack’ alle gemeinsamen Erstellungsoptionen
(siehe *note Gemeinsame Erstellungsoptionen::) und alle
Paketumwandlungsoptionen (siehe *note Paketumwandlungsoptionen::).

   ---------- Footnotes ----------

   (1) Es gibt einen Trick, wie Sie sich das merken können: ‘-RR’, womit
PRoot-Unterstützung hinzugefügt wird, kann man sich als Abkürzung für
„Rundum Relocatable“ oder englisch „Really Relocatable“ vorstellen. Ist
das nicht prima?


File: guix.de.info,  Node: Programmierschnittstelle,  Next: Zubehör,  Prev: Entwicklung,  Up: Top

6 Programmierschnittstelle
**************************

GNU Guix bietet mehrere Programmierschnittstellen (APIs) in der
Programmiersprache Scheme an, mit denen Software-Pakete definiert,
erstellt und gesucht werden können. Die erste Schnittstelle erlaubt es
Nutzern, ihre eigenen Paketdefinitionen in einer Hochsprache zu
schreiben. Diese Definitionen nehmen Bezug auf geläufige Konzepte der
Paketverwaltung, wie den Namen und die Version eines Pakets, sein
Erstellungssystem (Build System) und seine Abhängigkeiten
(Dependencies). Diese Definitionen können dann in konkrete
Erstellungsaktionen umgewandelt werden.

   Erstellungsaktionen werden vom Guix-Daemon für dessen Nutzer
durchgeführt. Bei einer normalen Konfiguration hat der Daemon
Schreibzugriff auf den Store, also das Verzeichnis ‘/gnu/store’, Nutzer
hingegen nicht. Die empfohlene Konfiguration lässt den Daemon die
Erstellungen in chroot-Umgebungen durchführen, mit eigenen
Benutzerkonten für „Erstellungsbenutzer“, um gegenseitige Beeinflussung
der Erstellung und des übrigen Systems zu minimieren.

   Systemnahe APIs stehen zur Verfügung, um mit dem Daemon und dem Store
zu interagieren. Um den Daemon anzuweisen, eine Erstellungsaktion
durchzuführen, versorgen ihn Nutzer jeweils mit einer “Ableitung”. Eine
Ableitung ist, wie durchzuführende Erstellungsaktionen, sowie die
Umgebungen, in denen sie durchzuführen sind, in Guix eigentlich intern
dargestellt werden. Ableitungen verhalten sich zu Paketdefinitionen
vergleichbar mit Assembler-Code zu C-Programmen. Der Begriff „Ableitung“
kommt daher, dass Erstellungsergebnisse daraus _abgeleitet_ werden.

   Dieses Kapitel beschreibt der Reihe nach all diese
Programmierschnittstellen (APIs), angefangen mit hochsprachlichen
Paketdefinitionen.

* Menu:

* Paketmodule::              Pakete aus Sicht des Programmierers.
* Pakete definieren::        Wie Sie neue Pakete definieren.
* Erstellungssysteme::       Angeben, wie Pakete erstellt werden.
* Der Store::                Den Paket-Store verändern.
* Ableitungen::              Systemnahe Schnittstelle für Paketableitungen.
* Die Store-Monade::         Rein funktionale Schnittstelle zum Store.
* G-Ausdrücke::             Erstellungsausdrücke verarbeiten.
* Aufruf von guix repl::     Interaktiv an Guix herumbasteln.


File: guix.de.info,  Node: Paketmodule,  Next: Pakete definieren,  Up: Programmierschnittstelle

6.1 Paketmodule
===============

Aus Programmierersicht werden die Paketdefinitionen der GNU-Distribution
als Guile-Module in Namensräumen wie ‘(gnu packages …)’ sichtbar
gemacht(1) (siehe *note Guile modules: (guile)Module.). Zum Beispiel
exportiert das Modul ‘(gnu packages emacs)’ eine Variable namens
‘emacs’, die an ein ‘<package>’-Objekt gebunden ist (siehe *note Pakete
definieren::).

   Der Modulnamensraum ‘(gnu packages …)’ wird von
Befehlszeilenwerkzeugen automatisch nach Paketen durchsucht. Wenn Sie
zum Beispiel ‘guix install emacs’ ausführen, werden alle ‘(gnu packages
…)’-Module durchlaufen, bis eines gefunden wird, das ein Paketobjekt mit
dem Namen ‘emacs’ exportiert. Diese Paketsuchfunktion ist im Modul ‘(gnu
packages)’ implementiert.

   Benutzer können Paketdefinitionen auch in Modulen mit anderen Namen
unterbringen — z.B. ‘(my-packages emacs)’(2). Es gibt zwei Arten, solche
Paketdefinitionen für die Benutzungsschnittstelle sichtbar zu machen:

  1. Eine Möglichkeit ist, das Verzeichnis, in dem Ihre Paketmodule
     stehen, mit der Befehlszeilenoption ‘-L’ von ‘guix package’ und
     anderen Befehlen (siehe *note Gemeinsame Erstellungsoptionen::)
     oder durch Setzen der unten beschriebenen Umgebungsvariablen
     ‘GUIX_PACKAGE_PATH’ zum Suchpfad hinzuzufügen.

  2. Die andere Möglichkeit ist, einen “Kanal” zu definieren und ‘guix
     pull’ so zu konfigurieren, dass es davon seine Module bezieht. Ein
     Kanal ist im Kern nur ein Git-Repository, in welchem Paketmodule
     liegen. Siehe *note Kanäle:: für mehr Informationen, wie Kanäle
     definiert und benutzt werden.

   ‘GUIX_PACKAGE_PATH’ funktioniert ähnlich wie andere Variable mit
Suchpfaden:

 -- Umgebungsvariable: GUIX_PACKAGE_PATH
     Dies ist eine doppelpunktgetrennte Liste von Verzeichnissen, die
     nach zusätzlichen Paketmodulen durchsucht werden. In dieser
     Variablen aufgelistete Verzeichnisse haben Vorrang vor den Modulen,
     die zur Distribution gehören.

   Die Distribution wird komplett von Grund auf initialisiert — man sagt
zur Initialisierung auch “Bootstrapping” — und sie ist “eigenständig”
(„self-contained“): Jedes Paket wird nur auf Basis von anderen Paketen
in der Distribution erstellt. Die Wurzel dieses Abhängigkeitsgraphen ist
ein kleiner Satz von Initialisierungsbinärdateien, den
“Bootstrap-Binärdateien”, die im Modul ‘(gnu packages bootstrap)’
verfügbar gemacht werden. Für mehr Informationen über Bootstrapping,
siehe *note Bootstrapping::.

   ---------- Footnotes ----------

   (1) Beachten Sie, dass Pakete unter dem Modulnamensraum ‘(gnu
packages …)’ nicht notwendigerweise auch „GNU-Pakete“ sind. Dieses
Schema für die Benennung von Modulen folgt lediglich den üblichen
Guile-Konventionen: ‘gnu’ bedeutet, dass die Module als Teil des
GNU-Systems ausgeliefert werden, und ‘packages’ gruppiert Module mit
Paketdefinitionen.

   (2) Beachten Sie, dass Dateiname und Modulname übereinstimmen müssen.
Zum Beispiel muss das Modul ‘(my-packages emacs)’ in einer Datei
‘my-packages/emacs.scm’ relativ zum mit ‘--load-path’ oder
‘GUIX_PACKAGE_PATH’ angegebenen Ladepfad stehen. Siehe *note
(guile)Modules and the File System:: für Details.


File: guix.de.info,  Node: Pakete definieren,  Next: Erstellungssysteme,  Prev: Paketmodule,  Up: Programmierschnittstelle

6.2 Pakete definieren
=====================

Mit den Modulen ‘(guix packages)’ und ‘(guix build-system)’ können
Paketdefinitionen auf einer hohen Abstraktionsebene geschrieben werden.
Zum Beispiel sieht die Paketdefinition bzw. das “Rezept” für das Paket
von GNU Hello so aus:

     (define-module (gnu packages hello)
       #:use-module (guix packages)
       #:use-module (guix download)
       #:use-module (guix build-system gnu)
       #:use-module (guix licenses)
       #:use-module (gnu packages gawk))

     (define-public hello
       (package
         (name "hello")
         (version "2.10")
         (source (origin
                   (method url-fetch)
                   (uri (string-append "mirror://gnu/hello/hello-" version
                                       ".tar.gz"))
                   (sha256
                    (base32
                     "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
         (build-system gnu-build-system)
         (arguments '(#:configure-flags '("--enable-silent-rules")))
         (inputs `(("gawk" ,gawk)))
         (synopsis "Hello, GNU world: An example GNU package")
         (description "Guess what GNU Hello prints!")
         (home-page "https://www.gnu.org/software/hello/")
         (license gpl3+)))

Auch ohne ein Experte in Scheme zu sein, könnten Leser erraten haben,
was die verschiedenen Felder dabei bedeuten. Dieser Ausdruck bindet die
Variable ‘hello’ an ein ‘<package>’-Objekt, was an sich nur ein Verbund
(Record) ist (siehe *note Scheme records: (guile)SRFI-9.). Die Felder
dieses Paket-Objekts lassen sich mit den Prozeduren aus dem Modul ‘(guix
packages)’ auslesen, zum Beispiel liefert ‘(package-name hello)’ —
Überraschung! — ‘"hello"’.

   Mit etwas Glück können Sie die Definition vielleicht teilweise oder
sogar ganz aus einer anderen Paketsammlung importieren, indem Sie den
Befehl ‘guix import’ verwenden (siehe *note Aufruf von guix import::).

   In obigem Beispiel wurde HELLO in einem eigenen Modul ganz für sich
alleine definiert, und zwar ‘(gnu packages hello)’. Technisch gesehen
muss es nicht unbedingt in einem solchen Modul definiert werden, aber es
ist bequem, denn alle Module unter ‘(gnu packages …)’ werden automatisch
von den Befehlszeilenwerkzeugen gefunden (siehe *note Paketmodule::).

   Ein paar Dinge sind noch erwähnenswert in der obigen Paketdefinition:

   • Das ‘source’-Feld für die Quelle des Pakets ist ein
     ‘<origin>’-Objekt, was den Paketursprung angibt (siehe *note
     „origin“-Referenz:: für eine vollständige Referenz). Hier wird
     dafür die Methode ‘url-fetch’ aus dem Modul ‘(guix download)’
     benutzt, d.h. die Quelle ist eine Datei, die über FTP oder HTTP
     heruntergeladen werden soll.

     Das Präfix ‘mirror://gnu’ lässt ‘url-fetch’ einen der
     GNU-Spiegelserver benutzen, die in ‘(guix download)’ definiert
     sind.

     Das Feld ‘sha256’ legt den erwarteten SHA256-Hashwert der
     herunterzuladenden Datei fest. Ihn anzugeben ist Pflicht und er
     ermöglicht es Guix, die Integrität der Datei zu überprüfen. Die
     Form ‘(base32 …)’ geht der base32-Darstellung des Hash-Wertes
     voraus. Sie finden die base32-Darstellung mit Hilfe der Befehle
     ‘guix download’ (siehe *note Aufruf von guix download::) und ‘guix
     hash’ (siehe *note Aufruf von guix hash::).

     Wenn nötig kann in der ‘origin’-Form auch ein ‘patches’-Feld
     stehen, wo anzuwendende Patches aufgeführt werden, sowie ein
     ‘snippet’-Feld mit einem Scheme-Ausdruck mit den Anweisungen, wie
     der Quellcode zu modifizieren ist.

   • Das Feld ‘build-system’ legt fest, mit welcher Prozedur das Paket
     erstellt werden soll (siehe *note Erstellungssysteme::). In diesem
     Beispiel steht GNU-BUILD-SYSTEM für das wohlbekannte
     GNU-Erstellungssystem, wo Pakete mit der üblichen Befehlsfolge
     ‘./configure && make && make check && make install’ konfiguriert,
     erstellt und installiert werden.

   • Das Feld ‘arguments’ gibt an, welche Optionen dem Erstellungssystem
     mitgegeben werden sollen (siehe *note Erstellungssysteme::). In
     diesem Fall interpretiert GNU-BUILD-SYSTEM diese als Auftrag,
     ‘configure’ mit der Befehlszeilenoption ‘--enable-silent-rules’
     auszuführen.

     Was hat es mit diesen einfachen Anführungszeichen (‘'’) auf sich?
     Sie gehören zur Syntax von Scheme und führen eine wörtlich zu
     interpretierende Datenlisten ein; dies nennt sich Maskierung oder
     Quotierung. ‘'’ ist synonym mit ‘quote’. *note quoting:
     (guile)Expression Syntax. enthält weitere Details. Hierbei ist also
     der Wert des ‘arguments’-Feldes eine Liste von Argumenten, die an
     das Erstellungssystem weitergereicht werden, wie bei ‘apply’ (siehe
     *note ‘apply’: (guile)Fly Evaluation.).

     Ein Doppelkreuz gefolgt von einem Doppelpunkt (‘#:’) definiert ein
     Scheme-“Schlüsselwort” (siehe *note (guile)Keywords::) und
     ‘#:configure-flags’ ist ein Schlüsselwort, um eine
     Befehlszeilenoption an das Erstellungssystem mitzugeben (siehe
     *note (guile)Coding With Keywords::).

   • Das Feld ‘inputs’ legt Eingaben an den Erstellungsprozess fest —
     d.h. Abhängigkeiten des Pakets zur Erstellungs- oder Laufzeit. Hier
     definieren wir eine Eingabe namens ‘"gawk"’, deren Wert wir auf den
     Wert der GAWK-Variablen festlegen; GAWK ist auch selbst wiederum an
     ein ‘<package>’-Objekt als Variablenwert gebunden.

     Auch mit ‘`’ (einem Backquote, stattdessen kann man auch das
     längere Synonym ‘quasiquote’ schreiben) können wir eine wörtlich
     als Daten interpretierte Liste im ‘inputs’-Feld einführen, aber bei
     dieser „Quasimaskierung“ kann ‘,’ (ein Komma, oder dessen Synonym
     ‘unquote’) benutzt werden, um den ausgewerteten Wert eines
     Ausdrucks in diese Liste einzufügen (siehe *note unquote:
     (guile)Expression Syntax.).

     Beachten Sie, dass GCC, Coreutils, Bash und andere essenzielle
     Werkzeuge hier nicht als Eingaben aufgeführt werden müssen.
     Stattdessen sorgt schon GNU-BUILD-SYSTEM dafür, dass diese
     vorhanden sein müssen (siehe *note Erstellungssysteme::).

     Sämtliche anderen Abhängigkeiten müssen aber im ‘inputs’-Feld
     aufgezählt werden. Jede hier nicht angegebene Abhängigkeit wird
     während des Erstellungsprozesses schlicht nicht verfügbar sein,
     woraus ein Erstellungsfehler resultieren kann.

   Siehe *note „package“-Referenz:: für eine umfassende Beschreibung
aller erlaubten Felder.

   Sobald eine Paketdefinition eingesetzt wurde, können Sie das Paket
mit Hilfe des Befehlszeilenwerkzeugs ‘guix build’ dann auch tatsächlich
erstellen (siehe *note Aufruf von guix build::) und dabei jegliche
Erstellungsfehler, auf die Sie stoßen, beseitigen (siehe *note
Fehlschläge beim Erstellen untersuchen::). Sie können den Befehl ‘guix
edit’ benutzen, um leicht zur Paketdefinition zurückzuspringen (siehe
*note Aufruf von guix edit::). Unter *note Paketrichtlinien:: finden Sie
mehr Informationen darüber, wie Sie Paketdefinitionen testen, und unter
*note Aufruf von guix lint:: finden Sie Informationen, wie Sie prüfen,
ob eine Definition alle Stilkonventionen einhält. Zuletzt finden Sie
unter *note Kanäle:: Informationen, wie Sie die Distribution um Ihre
eigenen Pakete in einem „Kanal“ erweitern.

   Zu all dem sei auch erwähnt, dass Sie das Aktualisieren einer
Paketdefinition auf eine vom Anbieter neu veröffentlichte Version mit
dem Befehl ‘guix refresh’ teilweise automatisieren können (siehe *note
Aufruf von guix refresh::).

   Hinter den Kulissen wird die einem ‘<package>’-Objekt entsprechende
Ableitung zuerst durch ‘package-derivation’ berechnet. Diese Ableitung
wird in der ‘.drv’-Datei unter ‘/gnu/store’ gespeichert. Die von ihr
vorgeschriebenen Erstellungsaktionen können dann durch die Prozedur
‘build-derivations’ umgesetzt werden (siehe *note Der Store::).

 -- Scheme-Prozedur: package-derivation STORE PAKET [SYSTEM]
     Das ‘<derivation>’-Objekt zum PAKET für das angegebene SYSTEM
     liefern (siehe *note Ableitungen::).

     Als PAKET muss ein gültiges ‘<package>’-Objekt angegeben werden und
     das SYSTEM muss eine Zeichenkette sein, die das Zielsystem angibt —
     z.B. ‘"x86_64-linux"’ für ein auf x86_64 laufendes, Linux-basiertes
     GNU-System. STORE muss eine Verbindung zum Daemon sein, der die
     Operationen auf dem Store durchführt (siehe *note Der Store::).

Auf ähnliche Weise kann eine Ableitung berechnet werden, die ein Paket
für ein anderes System cross-erstellt.

 -- Scheme-Prozedur: package-cross-derivation STORE PAKET ZIEL [SYSTEM]
          Liefert das
     ‘<derivation>’-Objekt, um das PAKET zu cross-erstellen vom SYSTEM
     aus für das ZIEL-System.

     Als ZIEL muss ein gültiges GNU-Tripel angegeben werden, was die
     Ziel-Hardware und das zugehörige Betriebssystem beschreibt, wie
     z.B. ‘"mips64el-linux-gnu"’ (siehe *note (autoconf)Specifying
     Target Triplets::).

   Pakete können auf beliebige Art verändert werden. Ein Beispiel für
eine nützliche Veränderung ist das “Umschreiben von Eingaben”, womit der
Abhängigkeitsbaum eines Pakets umgeschrieben wird, indem bestimmte
Eingaben durch andere ersetzt werden:

 -- Scheme-Prozedur: package-input-rewriting ERSETZUNGEN
          [UMGESCHRIEBENER-NAME] Eine Prozedur liefern, die für ein ihr
     übergebenes Paket dessen direkte und indirekte Abhängigkeit (aber
     nicht dessen implizite Eingaben) gemäß den ERSETZUNGEN umschreibt.
     ERSETZUNGEN ist eine Liste von Paketpaaren; das erste Element eines
     Paares ist das zu ersetzende Paket und das zweite ist, wodurch es
     ersetzt werden soll.

     Optional kann als UMGESCHRIEBENER-NAME eine ein Argument nehmende
     Prozedur angegeben werden, die einen Paketnamen nimmt und den Namen
     nach dem Umschreiben zurückliefert.

Betrachten Sie dieses Beispiel:

     (define libressl-statt-openssl
       ;; Dies ist eine Prozedur, mit der OPENSSL durch LIBRESSL
       ;; rekursiv ersetzt wird.
       (package-input-rewriting `((,openssl . ,libressl))))

     (define git-mit-libressl
       (libressl-statt-openssl git))

Hier definieren wir zuerst eine Umschreibeprozedur, die OPENSSL durch
LIBRESSL ersetzt. Dann definieren wir damit eine “Variante” des
GIT-Pakets, die LIBRESSL statt OPENSSL benutzt. Das ist genau, was auch
die Befehlszeilenoption ‘--with-input’ tut (siehe *note ‘--with-input’:
Paketumwandlungsoptionen.).

   Die folgende Variante von ‘package-input-rewriting’ kann für die
Ersetzung passende Pakete anhand ihres Namens finden, statt zu prüfen,
ob der Wert identisch ist.

 -- Scheme-Prozedur: package-input-rewriting/spec ERSETZUNGEN
     Liefert eine Prozedur, die für ein gegebenes Paket die angegebenen
     ERSETZUNGEN auf dessen gesamten Paketgraphen anwendet (außer auf
     implizite Eingaben). ERSETZUNGEN muss dabei eine Liste von Paaren
     aus je einer Spezifikation und Prozedur sein. Dabei ist jede
     Spezifikation eine Paketspezifikation wie ‘"gcc"’ oder ‘"guile@2"’
     und jede Prozedur nimmt ein passendes Paket und liefert dafür einen
     Ersatz für das Paket.

   Das obige Beispiel könnte auch so geschrieben werden:

     (define libressl-statt-openssl
       ;; Rekursiv alle Pakete namens "openssl" durch LibreSSL ersetzen.
       (package-input-rewriting/spec `(("openssl" . ,(const libressl)))))

   Der Hauptunterschied ist hier, dass diesmal Pakete zur Spezifikation
passen müssen und nicht deren Wert identisch sein muss, damit sie
ersetzt werden. Mit anderen Worten wird jedes Paket im Graphen ersetzt,
das ‘openssl’ heißt.

   Eine allgemeiner anwendbare Prozedur, um den Abhängigkeitsgraphen
eines Pakets umzuschreiben, ist ‘package-mapping’. Sie unterstützt
beliebige Änderungen an den Knoten des Graphen.

 -- Scheme-Prozedur: package-mapping PROZEDUR [SCHNITT?]
     Liefert eine Prozedur, die, wenn ihr ein Paket übergeben wird, die
     an ‘package-mapping’ übergebene PROZEDUR auf alle vom Paket
     abhängigen Pakete anwendet. Die Prozedur liefert das resultierende
     Paket. Wenn SCHNITT? für ein Paket davon einen wahren Wert liefert,
     findet kein rekursiver Abstieg in dessen Abhängigkeiten statt.

* Menu:

* „package“-Referenz::   Der Datentyp für Pakete.
* „origin“-Referenz::    Datentyp für Paketursprünge.


File: guix.de.info,  Node: „package“-Referenz,  Next: „origin“-Referenz,  Up: Pakete definieren

6.2.1 ‘package’-Referenz
------------------------

Dieser Abschnitt fasst alle in ‘package’-Deklarationen zur Verfügung
stehenden Optionen zusammen (siehe *note Pakete definieren::).

 -- Datentyp: package
     Dieser Datentyp steht für ein Paketrezept.

     ‘name’
          Der Name des Pakets als Zeichenkette.

     ‘version’
          Die Version des Pakets als Zeichenkette.

     ‘source’
          Ein Objekt, das beschreibt, wie der Quellcode des Pakets
          bezogen werden soll. Meistens ist es ein ‘origin’-Objekt,
          welches für eine aus dem Internet heruntergeladene Datei steht
          (siehe *note „origin“-Referenz::). Es kann aber auch ein
          beliebiges anderes „dateiähnliches“ Objekt sein, wie z.B. ein
          ‘local-file’, was eine Datei im lokalen Dateisystem bezeichnet
          (siehe *note ‘local-file’: G-Ausdrücke.).

     ‘build-system’
          Das Erstellungssystem, mit dem das Paket erstellt werden soll
          (siehe *note Erstellungssysteme::).

     ‘arguments’ (Vorgabe: ‘'()’)
          Die Argumente, die an das Erstellungssystem übergeben werden
          sollen. Dies ist eine Liste, typischerweise eine Reihe von
          Schlüssel-Wert-Paaren.

     ‘inputs’ (Vorgabe: ‘'()’)
     ‘native-inputs’ (Vorgabe: ‘'()’)
     ‘propagated-inputs’ (Vorgabe: ‘'()’)
          In diesen Feldern werden die Abhängigkeiten des Pakets
          aufgeführt. Jedes dieser Felder enthält eine Liste von Tupeln,
          wobei jedes Tupel eine Bezeichnung für die Eingabe (als
          Zeichenkette) als erstes Element, dann ein „package“-,
          „origin“- oder „derivation“-Objekt (Paket, Ursprung oder
          Ableitung) als zweites Element und optional die Benennung der
          davon zu benutzenden Ausgabe umfasst; letztere hat als
          Vorgabewert ‘"out"’ (siehe *note Pakete mit mehreren
          Ausgaben.:: für mehr Informationen zu Paketausgaben). Im
          folgenden Beispiel etwa werden drei Eingaben festgelegt:

               `(("libffi" ,libffi)
                 ("libunistring" ,libunistring)
                 ("glib:bin" ,glib "bin"))  ;Ausgabe "bin" von Glib

          Die Unterscheidung zwischen ‘native-inputs’ und ‘inputs’ ist
          wichtig, damit Cross-Kompilieren möglich ist. Beim
          Cross-Kompilieren werden als ‘inputs’ aufgeführte
          Abhängigkeiten für die Ziel-Prozessorarchitektur (_target_)
          erstellt, andersherum werden als ‘native-inputs’ aufgeführte
          Abhängigkeiten für die Prozessorarchitektur der erstellenden
          Maschine (_build_) erstellt.

          ‘native-inputs’ listet typischerweise die Werkzeuge auf, die
          während der Erstellung gebraucht werden, aber nicht zur
          Laufzeit des Programms gebraucht werden. Beispiele sind
          Autoconf, Automake, pkg-config, Gettext oder Bison. ‘guix
          lint’ kann melden, ob wahrscheinlich Fehler in der Auflistung
          sind (siehe *note Aufruf von guix lint::).

          Schließlich ist ‘propagated-inputs’ ähnlich wie ‘inputs’, aber
          die angegebenen Pakete werden automatisch mit ins Profil
          installiert, wenn das Paket installiert wird, zu dem sie
          gehören (siehe *note ‘guix package’:
          package-cmd-propagated-inputs. für Informationen darüber, wie
          ‘guix package’ mit propagierten Eingaben umgeht).

          Dies ist zum Beispiel nötig, wenn eine C-/C++-Bibliothek
          Header-Dateien einer anderen Bibliothek braucht, um mit ihr
          kompilieren zu können, oder wenn sich eine pkg-config-Datei
          auf eine andere über ihren ‘Requires’-Eintrag bezieht.

          Noch ein Beispiel, wo ‘propagated-inputs’ nützlich ist, sind
          Sprachen, die den Laufzeit-Suchpfad _nicht_ zusammen mit dem
          Programm abspeichern (_nicht_ wie etwa im ‘RUNPATH’ bei
          ELF-Dateien), also Sprachen wie Guile, Python, Perl und
          weitere. Damit auch in solchen Sprachen geschriebene
          Bibliotheken zur Laufzeit den von ihnen benötigten Code finden
          können, müssen deren Laufzeit-Abhängigkeiten in
          ‘propagated-inputs’ statt in ‘inputs’ aufgeführt werden.

     ‘outputs’ (Vorgabe: ‘'("out")’)
          Die Liste der Benennungen der Ausgaben des Pakets. Der
          Abschnitt *note Pakete mit mehreren Ausgaben.:: beschreibt
          übliche Nutzungen zusätzlicher Ausgaben.

     ‘native-search-paths’ (Vorgabe: ‘'()’)
     ‘search-paths’ (Vorgabe: ‘'()’)
          Eine Liste von ‘search-path-specification’-Objekten, die
          Umgebungsvariable für von diesem Paket beachtete Suchpfade
          („search paths“) beschreiben.

     ‘replacement’ (Vorgabe: ‘#f’)
          Dies muss entweder ‘#f’ oder ein package-Objekt sein, das als
          Ersatz (“replacement”) dieses Pakets benutzt werden soll. Im
          Abschnitt *note grafts: Sicherheitsaktualisierungen. wird dies
          erklärt.

     ‘synopsis’
          Eine einzeilige Beschreibung des Pakets.

     ‘description’
          Eine ausführlichere Beschreibung des Pakets.

     ‘license’
          Die Lizenz des Pakets; benutzt werden kann ein Wert aus dem
          Modul ‘(guix licenses)’ oder eine Liste solcher Werte.

     ‘home-page’
          Die URL, die die Homepage des Pakets angibt, als Zeichenkette.

     ‘supported-systems’ (default: ‘%supported-systems’)
          Die Liste der vom Paket unterstützten Systeme als
          Zeichenketten der Form ‘Architektur-Kernel’, zum Beispiel
          ‘"x86_64-linux"’.

     ‘location’ (Vorgabe: die Stelle im Quellcode, wo die ‘package’-Form steht)
          Wo im Quellcode das Paket definiert wurde. Es ist sinnvoll,
          dieses Feld manuell zuzuweisen, wenn das Paket von einem
          anderen Paket erbt, weil dann dieses Feld nicht automatisch
          berichtigt wird.

 -- Scheme-Syntax: this-package
     Wenn dies im _lexikalischen Geltungsbereich_ der Definition eines
     Feldes im Paket steht, bezieht sich dieser Bezeichner auf das
     Paket, das gerade definiert wird.

     Das folgende Beispiel zeigt, wie man ein Paket als native Eingabe
     von sich selbst beim Cross-Kompilieren deklariert:

          (package
            (name "guile")
            ;; …

            ;; Wenn es cross-kompiliert wird, hängt zum Beispiel
            ;; Guile von einer nativen Version von sich selbst ab.
            ;; Wir fügen sie hier hinzu.
            (native-inputs (if (%current-target-system)
                               `(("self" ,this-package))
                               '())))

     Es ist ein Fehler, außerhalb einer Paketdefinition auf
     ‘this-package’ zu verweisen.


File: guix.de.info,  Node: „origin“-Referenz,  Prev: „package“-Referenz,  Up: Pakete definieren

6.2.2 ‘origin’-Referenz
-----------------------

Dieser Abschnitt fasst alle Optionen zusammen, die in
‘origin’-Deklarationen zur Verfügung stehen (siehe *note Pakete
definieren::).

 -- Datentyp: origin
     Mit diesem Datentyp wird ein Ursprung, von dem Quellcode geladen
     werden kann, beschrieben.

     ‘uri’
          Ein Objekt, was die URI des Quellcodes enthält. Der Objekttyp
          hängt von der ‘Methode’ ab (siehe unten). Zum Beispiel sind,
          wenn die URL-FETCH-Methode aus ‘(guix download)’ benutzt wird,
          die gültigen Werte für ‘uri’: eine URL dargestellt als
          Zeichenkette oder eine Liste solcher URLs.

     ‘method’
          Eine Prozedur, die die URI verwertet.

          Beispiele sind unter anderem:

          URL-FETCH aus ‘(guix download)’
               Herunterladen einer Datei von einer HTTP-, HTTPS- oder
               FTP-URL, die im ‘uri’-Feld angegeben wurde.

          GIT-FETCH aus ‘(guix git-download)’
               Das im ‘uri’-Feld spezifizierte Repository des
               Git-Versionskontrollsystems klonen und davon den im
               ‘uri’-Feld als ein ‘git-reference’-Objekt angegebenen
               Commit benutzen; eine ‘git-reference’ sieht so aus:

                    (git-reference
                      (url "https://git.savannah.gnu.org/git/hello.git")
                      (commit "v2.10"))

     ‘sha256’
          Ein Bytevektor, der den SHA-256-Hash der Quelldateien enthält.
          Typischerweise wird hier mit der ‘base32’-Form der Bytevektor
          aus einer Base-32-Zeichenkette generiert.

          Diese Informationen liefert Ihnen der Befehl ‘guix download’
          (siehe *note Aufruf von guix download::) oder ‘guix hash’
          (siehe *note Aufruf von guix hash::).

     ‘file-name’ (Vorgabe: ‘#f’)
          Der Dateiname, unter dem der Quellcode abgespeichert werden
          soll. Wenn er auf ‘#f’ steht, wird ein vernünftiger Name
          automatisch gewählt. Falls der Quellcode von einer URL geladen
          wird, wird der Dateiname aus der URL genommen. Wenn der
          Quellcode von einem Versionskontrollsystem bezogen wird,
          empfiehlt es sich, den Dateinamen ausdrücklich anzugeben, weil
          dann keine sprechende Benennung automatisch gefunden werden
          kann.

     ‘patches’ (Vorgabe: ‘'()’)
          Eine Liste von Dateinamen, Ursprüngen oder dateiähnlichen
          Objekten (siehe *note dateiartige Objekte: G-Ausdrücke.) mit
          Patches, welche auf den Quellcode anzuwenden sind.

          Die Liste von Patches kann nicht von Parametern der Erstellung
          abhängen. Insbesondere kann sie nicht vom Wert von
          ‘%current-system’ oder ‘%current-target-system’ abḧängen.

     ‘snippet’ (Vorgabe: ‘#f’)
          Ein im Quellcode-Verzeichnis auszuführender G-Ausdruck (siehe
          *note G-Ausdrücke::) oder S-Ausdruck. Hiermit kann der
          Quellcode bequem modifiziert werden, manchmal ist dies
          bequemer als mit einem Patch.

     ‘patch-flags’ (Vorgabe: ‘'("-p1")’)
          Eine Liste der Befehlszeilenoptionen, die dem ‘patch’-Befehl
          übergeben werden sollen.

     ‘patch-inputs’ (Vorgabe: ‘#f’)
          Eingabepakete oder -ableitungen für den Patch-Prozess. Bei
          ‘#f’ werden die üblichen Patcheingaben wie GNU Patch
          bereitgestellt.

     ‘modules’ (Vorgabe: ‘'()’)
          Eine Liste von Guile-Modulen, die während des Patch-Prozesses
          und während der Ausführung des ‘snippet’-Felds geladen sein
          sollen.

     ‘patch-guile’ (Vorgabe: ‘#f’)
          Welches Guile-Paket für den Patch-Prozess benutzt werden soll.
          Bei ‘#f’ wird ein vernünftiger Vorgabewert angenommen.


File: guix.de.info,  Node: Erstellungssysteme,  Next: Der Store,  Prev: Pakete definieren,  Up: Programmierschnittstelle

6.3 Erstellungssysteme
======================

Jede Paketdefinition legt ein “Erstellungssystem” („build system“) sowie
dessen Argumente fest (siehe *note Pakete definieren::). Das
‘build-system’-Feld steht für die Erstellungsprozedur des Pakets sowie
für weitere implizite Eingaben für die Erstellungsprozedur.

   Erstellungssysteme sind ‘<build-system>’-Objekte. Die Schnittstelle,
um solche zu erzeugen und zu verändern, ist im Modul ‘(guix
build-system)’ zu finden, und die eigentlichen Erstellungssysteme werden
jeweils von ihren eigenen Modulen exportiert.

   Intern funktionieren Erstellungssysteme, indem erst Paketobjekte zu
“Bags” kompiliert werden. Eine Bag (deutsch: Beutel, Sack) ist wie ein
Paket, aber mit weniger Zierrat — anders gesagt ist eine Bag eine
systemnähere Darstellung eines Pakets, die sämtliche Eingaben des Pakets
einschließlich vom Erstellungssystem hinzugefügter Eingaben enthält.
Diese Zwischendarstellung wird dann zur eigentlichen Ableitung
kompiliert (siehe *note Ableitungen::).

   Erstellungssysteme akzeptieren optional eine Liste von “Argumenten”.
In Paketdefinitionen werden diese über das ‘arguments’-Feld übergeben
(siehe *note Pakete definieren::). Sie sind in der Regel
Schlüsselwort-Argumente (siehe *note keyword arguments in Guile:
(guile)Optional Arguments.). Der Wert dieser Argumente wird
normalerweise vom Erstellungssystem in der “Erstellungsschicht”
ausgewertet, d.h. von einem durch den Daemon gestarteten Guile-Prozess
(siehe *note Ableitungen::).

   Das häufigste Erstellungssystem ist ‘gnu-build-system’, was die
übliche Erstellungsprozedur für GNU-Pakete und viele andere Pakete
darstellt. Es wird vom Modul ‘(guix build-system gnu)’ bereitgestellt.

 -- Scheme-Variable: gnu-build-system
     ‘gnu-build-system’ steht für das GNU-Erstellungssystem und
     Varianten desselben (siehe *note configuration and makefile
     conventions: (standards)Configuration.).

     Kurz gefasst werden Pakete, die es benutzen, konfiguriert, erstellt
     und installiert mit der üblichen Befehlsfolge ‘./configure && make
     && make check && make install’. In der Praxis braucht man oft noch
     ein paar weitere Schritte. Alle Schritte sind in voneinander
     getrennte “Phasen” unterteilt. Erwähnt werden sollten(1):

     ‘unpack’
          Den Quell-Tarball entpacken und das Arbeitsverzeichnis
          wechseln in den entpackten Quellbaum. Wenn die Quelle bereits
          ein Verzeichnis ist, wird es in den Quellbaum kopiert und
          dorthin gewechselt.

     ‘patch-source-shebangs’
          „Shebangs“ in Quelldateien beheben, damit Sie sich auf die
          richtigen Store-Dateipfade beziehen. Zum Beispiel könnte
          ‘#!/bin/sh’ zu ‘#!/gnu/store/…-bash-4.3/bin/sh’ geändert
          werden.

     ‘configure’
          Das Skript ‘configure’ mit einigen vorgegebenen
          Befehlszeilenoptionen ausführen, wie z.B. mit
          ‘--prefix=/gnu/store/…’, sowie mit den im
          ‘#:configure-flags’-Argument angegebenen Optionen.

     ‘build’
          ‘make’ ausführen mit den Optionen aus der Liste in
          ‘#:make-flags’. Wenn das Argument ‘#:parallel-build?’ auf wahr
          gesetzt ist (was der Vorgabewert ist), wird ‘make -j’ zum
          Erstellen ausgeführt.

     ‘check’
          ‘make check’ (oder statt ‘check’ ein anderes bei
          ‘#:test-target’ angegebenes Ziel) ausführen, außer falls
          ‘#:tests? #f’ gesetzt ist. Wenn das Argument
          ‘#:parallel-tests?’ auf wahr gesetzt ist (der Vorgabewert),
          führe ‘make check -j’ aus.

     ‘install’
          ‘make install’ mit den in ‘#:make-flags’ aufgelisteten
          Optionen ausführen.

     ‘patch-shebangs’
          Shebangs in den installierten ausführbaren Dateien beheben.

     ‘strip’
          Symbole zur Fehlerbehebung aus ELF-Dateien entfernen (außer
          ‘#:strip-binaries?’ ist auf falsch gesetzt) und in die
          ‘debug’-Ausgabe kopieren, falls diese verfügbar ist (siehe
          *note Dateien zur Fehlersuche installieren::).

     Das erstellungsseitige Modul ‘(guix build gnu-build-system)’
     definiert ‘%standard-phases’ als die vorgegebene Liste der
     Erstellungsphasen. ‘%standard-phases’ ist eine Liste von Paaren aus
     je einem Symbol und einer Prozedur. Letztere implementiert die
     eigentliche Phase.

     Die Liste der Phasen, die für ein bestimmtes Paket verwendet werden
     sollen, kann vom Parameter ‘#:phases’ überschrieben werden. Zum
     Beispiel werden bei Übergabe von:

          #:phases (modify-phases %standard-phases (delete 'configure))

     alle oben beschriebenen Phasen benutzt außer der ‘configure’-Phase.

     Zusätzlich stellt dieses Erstellungssystem sicher, dass die
     „Standard“-Umgebung für GNU-Pakete zur Verfügung steht. Diese
     umfasst Werkzeuge wie GCC, libc, Coreutils, Bash, Make, Diffutils,
     grep und sed (siehe das Modul ‘(guix build-system gnu)’ für eine
     vollständige Liste). Wir bezeichnen sie als “implizite Eingaben”
     eines Pakets, weil Paketdefinitionen sie nicht aufführen müssen.

   Andere ‘<build-system>’-Objekte werden definiert, um andere
Konventionen und Werkzeuge von Paketen für freie Software zu
unterstützen. Die anderen Erstellungssysteme erben den Großteil vom
‘gnu-build-system’ und unterscheiden sich hauptsächlich darin, welche
Eingaben dem Erstellungsprozess implizit hinzugefügt werden und welche
Liste von Phasen durchlaufen wird. Manche dieser Erstellungssysteme sind
im Folgenden aufgeführt.

 -- Scheme-Variable: ant-build-system
     Diese Variable wird vom Modul ‘(guix build-system ant)’ exportiert.
     Sie implementiert die Erstellungsprozedur für Java-Pakete, die mit
     dem Ant build tool (https://ant.apache.org/) erstellt werden
     können.

     Sowohl ‘ant’ als auch der “Java Development Kit” (JDK), wie er vom
     Paket ‘icedtea’ bereitgestellt wird, werden zu den Eingaben
     hinzugefügt. Wenn andere Pakete dafür benutzt werden sollen, können
     sie jeweils mit den Parametern ‘#:ant’ und ‘#:jdk’ festgelegt
     werden.

     Falls das ursprüngliche Paket über keine nutzbare
     Ant-Erstellungsdatei („Ant-Buildfile“) verfügt, kann aus der Angabe
     im Parameter ‘#:jar-name’ eine minimale Ant-Erstellungsdatei
     ‘build.xml’ erzeugt werden, in der die für die Erstellung
     durchzuführenden Aufgaben (Tasks) für die Erstellung des
     angegebenen Jar-Archivs stehen. In diesem Fall kann der Parameter
     ‘#:source-dir’ benutzt werden, um das Unterverzeichnis mit dem
     Quellcode anzugeben; sein Vorgabewert ist „src“.

     Der Parameter ‘#:main-class’ kann mit einer minimalen
     Ant-Erstellungsdatei benutzt werden, um die Hauptklasse des
     resultierenden Jar-Archivs anzugeben. Dies ist nötig, wenn die
     Jar-Datei ausführbar sein soll. Mit dem Parameter ‘#:test-include’
     kann eine Liste angegeben werden, welche Junit-Tests auszuführen
     sind. Der Vorgabewert ist ‘(list "**/*Test.java")’. Mit
     ‘#:test-exclude’ kann ein Teil der Testdateien ignoriert werden.
     Der Vorgabewert ist ‘(list "**/Abstract*.java")’, weil abstrakte
     Klassen keine ausführbaren Tests enthalten können.

     Der Parameter ‘#:build-target’ kann benutzt werden, um die
     Ant-Aufgabe (Task) anzugeben, die während der ‘build’-Phase
     ausgeführt werden soll. Vorgabe ist, dass die Aufgabe (Task) „jar“
     ausgeführt wird.

 -- Scheme-Variable: android-ndk-build-system
     Diese Variable wird von ‘(guix build-system android-ndk)’
     exportiert. Sie implementiert eine Erstellungsprozedur für das
     Android NDK (Native Development Kit) benutzende Pakete mit einem
     Guix-spezifischen Erstellungsprozess.

     Für das Erstellungssystem wird angenommen, dass Pakete die zu ihrer
     öffentlichen Schnittstelle gehörenden Header-Dateien im
     Unterverzeichnis "include" der Ausgabe "out" und ihre Bibliotheken
     im Unterverzeichnis "lib" der Ausgabe "out" platzieren.

     Ebenso wird angenommen, dass es keine im Konflikt stehenden Dateien
     unter der Vereinigung aller Abhängigkeiten gibt.

     Derzeit wird Cross-Kompilieren hierfür nicht unterstützt, also wird
     dabei vorausgesetzt, dass Bibliotheken und Header-Dateien dieselben
     wie im Wirtssystem sind.

 -- Scheme-Variable: asdf-build-system/source
 -- Scheme-Variable: asdf-build-system/sbcl
 -- Scheme-Variable: asdf-build-system/ecl

     Diese Variablen, die vom Modul ‘(guix build-system asdf)’
     exportiert werden, implementieren Erstellungsprozeduren für
     Common-Lisp-Pakete, welche „ASDF“
     (https://common-lisp.net/project/asdf/) benutzen. ASDF dient der
     Systemdefinition für Common-Lisp-Programme und -Bibliotheken.

     Das Erstellungssystem ‘asdf-build-system/source’ installiert die
     Pakete in Quellcode-Form und kann via ASDF mit jeder
     Common-Lisp-Implementierung geladen werden. Die anderen
     Erstellungssysteme wie ‘asdf-build-system/sbcl’ installieren binäre
     Systeme in dem Format, das von einer bestimmten Implementierung
     verstanden wird. Diese Erstellungssysteme können auch benutzt
     werden, um ausführbare Programme zu erzeugen oder um Lisp-Abbilder
     mit einem vorab geladenen Satz von Paketen zu erzeugen.

     Das Erstellungssystem benutzt gewisse Namenskonventionen. Bei
     Binärpaketen sollte dem Paketnamen die Lispimplementierung als
     Präfix vorangehen, z.B. ‘sbcl-’ für ‘asdf-build-system/sbcl’.

     Zudem sollte das entsprechende Quellcode-Paket mit der Konvention
     wie bei Python-Paketen (siehe *note Python-Module::) ein ‘cl-’ als
     Präfix bekommen.

     Für Binärpakete sollte für jedes System ein Guix-Paket definiert
     werden. Wenn für einen Ursprung im ‘origin’ mehrere Systeme
     enthalten sind, können Paketvarianten geschrieben werden, mit denen
     alle Systeme erstellt werden. Quellpakete, die
     ‘asdf-build-system/source’ benutzen, können mehrere Systeme
     enthalten.

     Um ausführbare Programme und Abbilder zu erzeugen, können die
     erstellungsseitigen Prozeduren ‘build-program’ und ‘build-image’
     benutzt werden. Sie sollten in einer Erstellungsphase nach der
     ‘create-symlinks’-Phase aufgerufen werden, damit das gerade
     erstellte System Teil des resultierenden Abbilds sein kann. An
     ‘build-program’ muss eine Liste von Common-Lisp-Ausdrücken über das
     Argument ‘#:entry-program’ übergeben werden.

     Wenn das System nicht in seiner eigenen gleichnamigen ‘.asd’-Datei
     definiert ist, sollte der Parameter ‘#:asd-file’ benutzt werden, um
     anzugeben, in welcher Datei das System definiert ist. Außerdem wird
     bei Paketen, für deren Tests ein System in einer separaten Datei
     definiert wurde, dieses System geladen, bevor die Tests ablaufen,
     wenn es im Parameter ‘#:test-asd-file’ steht. Ist dafür kein Wert
     gesetzt, werden die Dateien ‘<system>-tests.asd’,
     ‘<system>-test.asd’, ‘tests.asd’ und ‘test.asd’ durchsucht, wenn
     sie existieren.

     Wenn aus irgendeinem Grund der Paketname nicht den
     Namenskonventionen folgen kann, kann der Parameter
     ‘#:asd-system-name’ benutzt werden, um den Namen des Systems
     anzugeben.

 -- Scheme-Variable: cargo-build-system
     Diese Variable wird vom Modul ‘(guix build-system cargo)’
     exportiert. Damit können Pakete mit Cargo erstellt werden, dem
     Erstellungswerkzeug der Rust-Programmiersprache
     (https://www.rust-lang.org).

     Das Erstellungssystem fügt ‘rustc’ und ‘cargo’ zu den Eingaben
     hinzu. Ein anderes Rust-Paket kann mit dem Parameter ‘#:rust’
     angegeben werden.

     Normale cargo-Abhängigkeiten sollten zur Paketdefinition über den
     Parameter ‘#:cargo-inputs’ als eine Liste von Paaren aus Name und
     Spezifikation hinzugefügt werden, wobei als Spezifikation ein Paket
     oder eine Quellcode-Definition angegeben werden kann. Beachten Sie,
     dass die Spezifikation zu einem mit gzip komprimierten Tarball
     ausgewertet werden muss, der eine Datei ‘Cargo.toml’ in seinem
     Wurzelverzeichnis enthält, ansonsten wird sie ignoriert. Analog
     sollten solche Abhängigkeiten, die in cargo als „dev-dependencies“
     deklariert werden, zur Paketdefinition über den Parameter
     ‘#:cargo-development-inputs’ hinzugefügt werden.

     In seiner ‘configure’-Phase sorgt dieses Erstellungssystem dafür,
     dass cargo alle Quellcodeeingaben zur Verfügung stehen, die in den
     Parametern ‘#:cargo-inputs’ und ‘#:cargo-development-inputs’
     angegeben wurden. Außerdem wird eine enthaltene ‘Cargo.lock’-Datei
     entfernt, damit ‘cargo’ selbige während der ‘build’-Phase neu
     erzeugt. Die ‘install’-Phase installiert die in jeder Crate
     definierten Binärdateien.

 -- Scheme-Variable: copy-build-system
     Diese Variable wird vom Modul ‘(guix build-system copy)’
     exportiert. Damit können einfache Pakete erstellt werden, für die
     nur wenig kompiliert werden muss, sondern in erster Linie Dateien
     kopiert werden.

     Dadurch wird ein Großteil der ‘gnu-build-system’ zur Menge der
     Paketeingaben hinzugefügt. Deswegen kann man bei Nutzung des
     ‘copy-build-system’ auf große Teile des Codes verzichten, der beim
     ‘trivial-build-system’ anfallen würde.

     Um den Dateiinstallationsvorgang weiter zu vereinfachen, wird ein
     Argument ‘#:install-plan’ zur Verfügung gestellt, mit dem der
     Paketautor angeben kann, welche Dateien wohin gehören. Der
     Installationsplan ist eine Liste aus ‘(QUELLE ZIEL [FILTER])’. Die
     FILTER sind optional.

        • Wenn die QUELLE einer Datei oder einem Verzeichnis ohne
          Schrägstrich am Ende entspricht, wird sie nach ZIEL
          installiert.
             • Hat das ZIEL einen Schrägstrich am Ende, wird mit dem
               Basisnamen der QUELLE innerhalb von ZIEL installiert.
             • Andernfalls wird die QUELLE als ZIEL installiert.

        • Falls es sich bei der QUELLE um ein Verzeichnis mit
          Schrägstrich am Ende handelt oder wenn FILTER benutzt werden,
          so ist der Schrägstrich am Ende von ZIEL mit der Bedeutung wie
          oben implizit.
             • Ohne Angabe von FILTERn wird der gesamte _Inhalt_ der
               QUELLE nach ZIEL installiert.
             • Werden FILTER als ‘#:include’, ‘#:include-regexp’,
               ‘#:exclude’ oder ‘#:exclude-regexp’ aufgeführt, werden je
               nach Filter nur die ausgewählten Dateien installiert.
               Jeder Filter wird als Liste von Zeichenketten angegeben.
                  • Bei ‘#:include’ werden all die Dateien installiert,
                    deren Pfad als Suffix zu mindestens einem der
                    Elemente der angegebenen Liste passt.
                  • Bei ‘#:include-regexp’ werden all die Dateien
                    installiert, deren Unterpfad zu mindestens einem der
                    regulären Ausdrücke in der angegebenen Liste passt.
                  • Die Filter ‘#:exclude’ und ‘#:exclude-regexp’
                    bewirken das Gegenteil ihrer Include-Entsprechungen.
                    Ohne ‘#:include’-Angaben werden alle Dateien außer
                    den zu den Exclude-Filtern passenden installiert.
                    Werden sowohl ‘#:include’ als auch ‘#:exclude’
                    angegeben, werden zuerst die ‘#:include’-Angaben
                    beachtet und danach wird durch ‘#:exclude’
                    gefiltert.
          In jedem Fall bleiben die Pfade relativ zur QUELLE innerhalb
          des ZIELs erhalten.

     Beispiele:

        • ‘("foo/bar" "share/my-app/")’: Installiert ‘bar’ nach
          ‘share/my-app/bar’.
        • ‘("foo/bar" "share/my-app/baz")’: Installiert ‘bar’ nach
          ‘share/my-app/baz’.
        • ‘("foo/" "share/my-app")’: Installiert den Inhalt von ‘foo’
          innerhalb von ‘share/my-app’. Zum Beispiel wird
          ‘foo/sub/datei’ nach ‘share/my-app/sub/datei’ installiert.
        • ‘("foo/" "share/my-app" #:include ("sub/datei"))’: Installiert
          nur ‘foo/sub/datei’ nach ‘share/my-app/sub/datei’.
        • ‘("foo/sub" "share/my-app" #:include ("datei"))’: Installiert
          ‘foo/sub/datei’ nach ‘share/my-app/datei’.

 -- Scheme-Variable: clojure-build-system
     Diese Variable wird durch das Modul ‘(guix build-system clojure)’
     exportiert. Sie implementiert eine einfache Erstellungsprozedur für
     in Clojure (https://clojure.org/) geschriebene Pakete mit dem guten
     alten ‘compile’ in Clojure. Cross-Kompilieren wird noch nicht
     unterstützt.

     Das Erstellungssystem fügt ‘clojure’, ‘icedtea’ und ‘zip’ zu den
     Eingaben hinzu. Sollen stattdessen andere Pakete benutzt werden,
     können diese jeweils mit den Parametern ‘#:clojure’, ‘#:jdk’ und
     ‘#:zip’ spezifiziert werden.

     Eine Liste der Quellcode-Verzeichnisse, Test-Verzeichnisse und
     Namen der Jar-Dateien können jeweils über die Parameter
     ‘#:source-dirs’, ‘#:test-dirs’ und ‘#:jar-names’ angegeben werden.
     Das Verzeichnis, in das kompiliert wird, sowie die Hauptklasse
     können jeweils mit den Parametern ‘#:compile-dir’ und
     ‘#:main-class’ angegeben werden. Andere Parameter sind im Folgenden
     dokumentiert.

     Dieses Erstellungssystem ist eine Erweiterung des
     ‘ant-build-system’, bei der aber die folgenden Phasen geändert
     wurden:

     ‘build’
          Diese Phase ruft ‘compile’ in Clojure auf, um Quelldateien zu
          kompilieren, und führt ‘jar’ aus, um Jar-Dateien aus sowohl
          Quelldateien als auch kompilierten Dateien zu erzeugen,
          entsprechend der jeweils in ‘#:aot-include’ und
          ‘#:aot-exclude’ festgelegten Listen aus in der Menge der
          Quelldateien eingeschlossenen und ausgeschlossenen
          Bibliotheken. Die Ausschlussliste hat Vorrang vor der
          Einschlussliste. Diese Listen setzen sich aus Symbolen
          zusammen, die für Clojure-Bibliotheken stehen oder dem
          Schlüsselwort ‘#:all’ entsprechen, was für alle im
          Quellverzeichis gefundenen Clojure-Bibliotheken steht. Der
          Parameter ‘#:omit-source?’ entscheidet, ob Quelldateien in die
          Jar-Archive aufgenommen werden sollen.

     ‘check’
          In dieser Phase werden Tests auf die durch Einschluss- und
          Ausschlussliste ‘#:test-include’ bzw. ‘#:test-exclude’
          angegebenen Dateien ausgeführt. Deren Bedeutung ist analog zu
          ‘#:aot-include’ und ‘#:aot-exclude’, außer dass das besondere
          Schlüsselwort ‘#:all’ jetzt für alle Clojure-Bibliotheken in
          den Test-Verzeichnissen steht. Der Parameter ‘#:tests?’
          entscheidet, ob Tests ausgeführt werden sollen.

     ‘install’
          In dieser Phase werden alle zuvor erstellten Jar-Dateien
          installiert.

     Zusätzlich zu den bereits angegebenen enthält dieses
     Erstellungssystem noch eine weitere Phase.

     ‘install-doc’
          Diese Phase installiert alle Dateien auf oberster Ebene, deren
          Basisnamen ohne Verzeichnisangabe zu ‘%doc-regex’ passen. Ein
          anderer regulärer Ausdruck kann mit dem Parameter
          ‘#:doc-regex’ verwendet werden. All die so gefundenen oder
          (rekursiv) in den mit ‘#:doc-dirs’ angegebenen
          Dokumentationsverzeichnissen liegenden Dateien werden
          installiert.

 -- Scheme-Variable: cmake-build-system
     Diese Variable wird von ‘(guix build-system cmake)’ exportiert. Sie
     implementiert die Erstellungsprozedur für Pakete, die das
     CMake-Erstellungswerkzeug (https://www.cmake.org) benutzen.

     Das Erstellungssystem fügt automatisch das Paket ‘cmake’ zu den
     Eingaben hinzu. Welches Paket benutzt wird, kann mit dem Parameter
     ‘#:cmake’ geändert werden.

     Der Parameter ‘#:configure-flags’ wird als Liste von
     Befehlszeilenoptionen aufgefasst, die an den Befehl ‘cmake’
     übergeben werden. Der Parameter ‘#:build-type’ abstrahiert, welche
     Befehlszeilenoptionen dem Compiler übergeben werden; der
     Vorgabewert ist ‘"RelWithDebInfo"’ (kurz für „release mode with
     debugging information“), d.h. kompiliert wird für eine
     Produktionsumgebung und Informationen zur Fehlerbehebung liegen
     bei, was ungefähr ‘-O2 -g’ entspricht, wie bei der Vorgabe für
     Autoconf-basierte Pakete.

 -- Scheme-Variable: dune-build-system
     Diese Variable wird vom Modul ‘(guix build-system dune)’
     exportiert. Sie unterstützt es, Pakete mit Dune
     (https://dune.build/) zu erstellen, einem Erstellungswerkzeug für
     die Programmiersprache OCaml, und ist als Erweiterung des unten
     beschriebenen OCaml-Erstellungssystems ‘ocaml-build-system’
     implementiert. Als solche können auch die Parameter ‘#:ocaml’ und
     ‘#:findlib’ an dieses Erstellungssystem übergeben werden.

     Das Erstellungssystem fügt automatisch das Paket ‘dune’ zu den
     Eingaben hinzu. Welches Paket benutzt wird, kann mit dem Parameter
     ‘#:dune’ geändert werden.

     Es gibt keine ‘configure’-Phase, weil dune-Pakete typischerweise
     nicht konfiguriert werden müssen. Vom Parameter ‘#:build-flags’
     wird erwartet, dass es sich um eine Liste von Befehlszeilenoptionen
     handelt, die zur Erstellung an den ‘dune’-Befehl übergeben werden.

     Der Parameter ‘#:jbuild?’ kann übergeben werden, um den Befehl
     ‘jbuild’ anstelle des neueren ‘dune’-Befehls aufzurufen, um das
     Paket zu erstellen. Der Vorgabewert ist ‘#f’.

     Mit dem Parameter ‘#:package’ kann ein Paketname angegeben werden,
     wenn im Paket mehrere Pakete enthalten sind und nur eines davon
     erstellt werden soll. Es ist äquivalent dazu, die
     Befehlszeilenoption ‘-p’ an ‘dune’ zu übergeben.

 -- Scheme-Variable: go-build-system
     Diese Variable wird vom Modul ‘(guix build-system go)’ exportiert.
     Mit ihr ist eine Erstellungsprozedur für Go-Pakete implementiert,
     die dem normalen Go-Erstellungsmechanismus
     (https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies)
     entspricht.

     Beim Aufruf wird ein Wert für den Schlüssel ‘#:import-path’ und
     manchmal auch für ‘#:unpack-path’ erwartet. Der „import path“
     (https://golang.org/doc/code.html#ImportPaths) entspricht dem
     Dateisystempfad, den die Erstellungsskripts des Pakets und darauf
     Bezug nehmende Pakete erwarten; durch ihn wird ein Go-Paket
     eindeutig bezeichnet. Typischerweise setzt er sich aus einer
     Kombination der entfernten URI des Paketquellcodes und der
     Dateisystemhierarchie zusammen. Manchmal ist es nötig, den
     Paketquellcode in ein anderes als das vom „import path“ bezeichnete
     Verzeichnis zu entpacken; diese andere Verzeichnisstruktur sollte
     dann als ‘#:unpack-path’ angegeben werden.

     Pakete, die Go-Bibliotheken zur Verfügung stellen, sollten ihren
     Quellcode auch in die Erstellungsausgabe installieren. Der
     Schlüssel ‘#:install-source?’, sein Vorgabewert ist ‘#t’, steuert,
     ob Quellcode installiert wird. Bei Paketen, die nur ausführbare
     Dateien liefern, kann der Wert auf ‘#f’ gesetzt werden.

 -- Scheme-Variable: glib-or-gtk-build-system
     Diese Variable wird vom Modul ‘(guix build-system glib-or-gtk)’
     exportiert. Sie ist für Pakete gedacht, die GLib oder GTK benutzen.

     Dieses Erstellungssystem fügt die folgenden zwei Phasen zu denen
     von ‘gnu-build-system’ hinzu:

     ‘glib-or-gtk-wrap’
          Die Phase ‘glib-or-gtk-wrap’ stellt sicher, dass Programme in
          ‘bin/’ in der Lage sind, GLib-„Schemata“ und GTK-Module
          (https://developer.gnome.org/gtk3/stable/gtk-running.html) zu
          finden. Dazu wird für das Programm ein Wrapper-Skript erzeugt,
          dass das eigentliche Programm mit den richtigen Werten für die
          Umgebungsvariablen ‘XDG_DATA_DIRS’ und ‘GTK_PATH’ aufruft.

          Es ist möglich, bestimmte Paketausgaben von diesem
          Wrapping-Prozess auszunehmen, indem Sie eine Liste ihrer Namen
          im Parameter ‘#:glib-or-gtk-wrap-excluded-outputs’ angeben.
          Das ist nützlich, wenn man von einer Ausgabe weiß, dass sie
          keine Binärdateien enthält, die GLib oder GTK benutzen, und
          diese Ausgabe durch das Wrappen ohne Not eine weitere
          Abhängigkeit von GLib und GTK bekäme.

     ‘glib-or-gtk-compile-schemas’
          Mit der Phase ‘glib-or-gtk-compile-schemas’ wird
          sichergestellt, dass alle GSettings-Schemata
          (https://developer.gnome.org/gio/stable/glib-compile-schemas.html)
          für GLib kompiliert werden. Dazu wird das Programm
          ‘glib-compile-schemas’ ausgeführt. Es kommt aus dem Paket
          ‘glib:bin’, was automatisch vom Erstellungssystem importiert
          wird. Welches ‘glib’-Paket dieses ‘glib-compile-schemas’
          bereitstellt, kann mit dem Parameter ‘#:glib’ spezifiziert
          werden.

     Beide Phasen finden nach der ‘install’-Phase statt.

 -- Scheme-Variable: guile-build-system
     Dieses Erstellungssystem ist für Guile-Pakete gedacht, die nur aus
     Scheme-Code bestehen und so schlicht sind, dass sie nicht einmal
     ein Makefile und erst recht keinen ‘configure’-Skript enthalten.
     Hierzu wird Scheme-Code mit ‘guild compile’ kompiliert (siehe *note
     (guile)Compilation::) und die ‘.scm’- und ‘.go’-Dateien an den
     richtigen Pfad installiert. Auch Dokumentation wird installiert.

     Das Erstellungssystem unterstützt Cross-Kompilieren durch die
     Befehlszeilenoption ‘--target’ für ‘guild compile’.

     Mit ‘guile-build-system’ erstellte Pakete müssen ein Guile-Paket in
     ihrem ‘native-inputs’-Feld aufführen.

 -- Scheme-Variable: julia-build-system
     Diese Variable wird vom Modul ‘(guix build-system julia)’
     exportiert. Sie entspricht einer Implementierung der durch
     Julia-Pakete (https://julialang.org/) genutzten Erstellungsprozedur
     und verhält sich in Prinzip so, wie wenn man ‘julia -e 'using Pkg;
     Pkg.add(paket)'’ in einer Umgebung auszuführt, in der die
     Umgebungsvariable ‘JULIA_LOAD_PATH’ die Pfade aller Julia-Pakete
     unter den Paketeingaben enthält. Es werden _keine_ Tests
     ausgeführt.

     Für Julia-Pakete wird vorausgesetzt, dass der Dateiname im
     ‘file-name’-Feld der Quelle der echte Name des Pakets ist, in der
     richtigen Groß-/Kleinschreibung.

     Für Pakete, die als Abhängigkeiten gemeinsame Bibliotheken („Shared
     Libraries“) verlangen, müssen Sie die ‘/deps/deps.jl’-Datei unter
     Umständen selbst schreiben. Normalerweise enthält sie eine Zeile
     wie ‘const variable = /gnu/store/library.so’ für jede Abhängigkeit
     sowie eine Funktion ‘check_deps() = nothing’ ohne Rückgabe.

     Für manche ältere Pakete, die noch keine ‘Package.toml’ benutzen,
     muss auch diese Datei erstellt werden. Die Funktion
     ‘julia-create-package-toml’ hilft dabei. Sie müssen ihr nur die
     Ausgaben und die Quelle des Pakets übergeben sowie seinen Namen
     (derselbe wie beim Parameter ‘file-name’), die Paket-UUID, die
     Paketversion und eine Liste von Abhängigkeiten, jeweils angegeben
     über ihren Namen und ihre UUID.

 -- Scheme-Variable: minify-build-system
     Diese Variable wird vom Modul ‘(guix build-system minify)’
     exportiert. Sie implementiert eine Prozedur zur Minifikation
     einfacher JavaScript-Pakete.

     Es fügt ‘uglify-js’ zur Menge der Eingaben hinzu und komprimiert
     damit alle JavaScript-Dateien im ‘src’-Verzeichnis. Ein anderes
     Programm zur Minifikation kann verwendet werden, indem es mit dem
     Parameter ‘#:uglify-js’ angegeben wird; es wird erwartet, dass das
     angegebene Paket den minifizierten Code auf der Standardausgabe
     ausgibt.

     Wenn die Eingabe-JavaScript-Dateien nicht alle im ‘src’-Verzeichnis
     liegen, kann mit dem Parameter ‘#:javascript-files’ eine Liste der
     Dateinamen übergeben werden, auf die das Minifikationsprogramm
     aufgerufen wird.

 -- Scheme-Variable: ocaml-build-system
     Diese Variable wird vom Modul ‘(guix build-system ocaml)’
     exportiert. Mit ihr ist ein Erstellungssystem für OCaml-Pakete
     (https://ocaml.org) implementiert, was bedeutet, dass es die
     richtigen auszuführenden Befehle für das jeweilige Paket auswählt.
     OCaml-Pakete können sehr unterschiedliche Befehle erwarten. Dieses
     Erstellungssystem probiert manche davon durch.

     Wenn im Paket eine Datei ‘setup.ml’ auf oberster Ebene vorhanden
     ist, wird ‘ocaml setup.ml -configure’, ‘ocaml setup.ml -build’ und
     ‘ocaml setup.ml -install’ ausgeführt. Das Erstellungssystem wird
     annehmen, dass die Datei durch OASIS
     (http://oasis.forge.ocamlcore.org/) erzeugt wurde, und wird das
     Präfix setzen und Tests aktivieren, wenn diese nicht abgeschaltet
     wurden. Sie können Befehlszeilenoptionen zum Konfigurieren und
     Erstellen mit den Parametern ‘#:configure-flags’ und
     ‘#:build-flags’ übergeben. Der Schlüssel ‘#:test-flags’ kann
     übergeben werden, um die Befehlszeilenoptionen zu ändern, mit denen
     die Tests aktiviert werden. Mit dem Parameter ‘#:use-make?’ kann
     dieses Erstellungssystem für die build- und install-Phasen
     abgeschaltet werden.

     Verfügt das Paket über eine ‘configure’-Datei, wird angenommen,
     dass diese von Hand geschrieben wurde mit einem anderen Format für
     Argumente als bei einem Skript des ‘gnu-build-system’. Sie können
     weitere Befehlszeilenoptionen mit dem Schlüssel ‘#:configure-flags’
     hinzufügen.

     Falls dem Paket ein ‘Makefile’ beiliegt (oder ‘#:use-make?’ auf
     ‘#t’ gesetzt wurde), wird dieses benutzt und weitere
     Befehlszeilenoptionen können mit dem Schlüssel ‘#:make-flags’ zu
     den build- und install-Phasen hinzugefügt werden.

     Letztlich gibt es in manchen Pakete keine solchen Dateien, sie
     halten sich aber an bestimmte Konventionen, wo ihr eigenes
     Erstellungssystem zu finden ist. In diesem Fall führt Guix’
     OCaml-Erstellungssystem ‘ocaml pkg/pkg.ml’ oder ‘ocaml
     pkg/build.ml’ aus und kümmert sich darum, dass der Pfad zu dem
     benötigten findlib-Modul passt. Weitere Befehlszeilenoptionen
     können über den Schlüssel ‘#:build-flags’ übergeben werden. Um die
     Installation kümmert sich ‘opam-installer’. In diesem Fall muss das
     ‘opam’-Paket im ‘native-inputs’-Feld der Paketdefinition stehen.

     Beachten Sie, dass die meisten OCaml-Pakete davon ausgehen, dass
     sie in dasselbe Verzeichnis wie OCaml selbst installiert werden,
     was wir in Guix aber nicht so haben wollen. Solche Pakete
     installieren ihre ‘.so’-Dateien in das Verzeichnis ihres Moduls,
     was für die meisten anderen Einrichtungen funktioniert, weil es im
     OCaml-Compilerverzeichnis liegt. Jedoch können so in Guix die
     Bibliotheken nicht gefunden werden, deswegen benutzen wir
     ‘CAML_LD_LIBRARY_PATH’. Diese Umgebungsvariable zeigt auf
     ‘lib/ocaml/site-lib/stubslibs’ und dorthin sollten
     ‘.so’-Bibliotheken installiert werden.

 -- Scheme-Variable: python-build-system
     Diese Variable wird vom Modul ‘(guix build-system python)’
     exportiert. Sie implementiert mehr oder weniger die konventionelle
     Erstellungsprozedur, wie sie für Python-Pakete üblich ist, d.h.
     erst wird ‘python setup.py build’ ausgeführt und dann ‘python
     setup.py install --prefix=/gnu/store/…’.

     Für Pakete, die eigenständige Python-Programme nach ‘bin/’
     installieren, sorgt dieses Erstellungssystem dafür, dass die
     Programme in ein Wrapper-Skript verpackt werden, welches die
     eigentlichen Programme mit einer Umgebungsvariablen ‘PYTHONPATH’
     aufruft, die alle Python-Bibliotheken auflistet, von denen die
     Programme abhängen.

     Welches Python-Paket benutzt wird, um die Erstellung durchzuführen,
     kann mit dem Parameter ‘#:python’ bestimmt werden. Das ist
     nützlich, wenn wir erzwingen wollen, dass ein Paket mit einer
     bestimmten Version des Python-Interpretierers arbeitet. Das kann
     nötig sein, wenn das Programm nur mit einer einzigen
     Interpretiererversion kompatibel ist.

     Standardmäßig ruft Guix ‘setup.py’ auf, was zu ‘setuptools’ gehört,
     ähnlich wie es auch ‘pip’ tut. Manche Pakete sind mit setuptools
     (und pip) inkompatibel, deswegen können Sie diese Einstellung
     abschalten, indem Sie den Parameter ‘#:use-setuptools?’ auf ‘#f’
     setzen.

 -- Scheme-Variable: perl-build-system
     Diese Variable wird vom Modul ‘(guix build-system perl)’
     exportiert. Mit ihr wird die Standard-Erstellungsprozedur für
     Perl-Pakete implementiert, welche entweder darin besteht, ‘perl
     Build.PL --prefix=/gnu/store/…’ gefolgt von ‘Build’ und ‘Build
     install’ auszuführen, oder ‘perl Makefile.PL PREFIX=/gnu/store/…’
     gefolgt von ‘make’ und ‘make install’ auszuführen, je nachdem, ob
     eine Datei ‘Build.PL’ oder eine Datei ‘Makefile.PL’ in der
     Paketdistribution vorliegt. Den Vorrang hat erstere, wenn sowohl
     ‘Build.PL’ als auch ‘Makefile.PL’ in der Paketdistribution
     existieren. Der Vorrang kann umgekehrt werden, indem ‘#t’ für den
     Parameter ‘#:make-maker?’ angegeben wird.

     Der erste Aufruf von ‘perl Makefile.PL’ oder ‘perl Build.PL’
     übergibt die im Parameter ‘#:make-maker-flags’ bzw.
     ‘#:module-build-flags’ angegebenen Befehlszeilenoptionen, je
     nachdem, was verwendet wird.

     Welches Perl-Paket dafür benutzt wird, kann mit ‘#:perl’ angegeben
     werden.

 -- Scheme-Variable: qt-build-system
     Diese Variable wird vom Modul ‘(guix build-system qt)’ exportiert.
     Sie ist für Anwendungen gedacht, die Qt oder KDE benutzen.

     Dieses Erstellungssystem fügt die folgenden zwei Phasen zu denen
     von ‘cmake-build-system’ hinzu:

     ‘check-setup’
          Die Phase ‘check-setup’ bereitet die Umgebung für
          Überprüfungen vor, wie sie von Qt-Test-Programmen
          üblicherweise benutzt werden. Zur Zeit werden nur manche
          Umgebungsvariable gesetzt: ‘QT_QPA_PLATFORM=offscreen’,
          ‘DBUS_FATAL_WARNINGS=0’ und ‘CTEST_OUTPUT_ON_FAILURE=1’.

          Diese Phase wird vor der ‘check’-Phase hinzugefügt. Es handelt
          sich um eine eigene Phase, die nach Bedarf angepasst werden
          kann.

     ‘qt-wrap’
          In der Phase ‘qt-wrap’ wird nach Qt5-Plugin-Pfaden, QML-Pfaden
          und manchen XDG-Daten in den Ein- und Ausgaben gesucht. Wenn
          solch ein Pfad gefunden wird, werden für alle Programme in den
          Verzeichnissen ‘bin/’, ‘sbin/’, ‘libexec/’ und ‘lib/libexec/’
          in der Ausgabe Wrapper-Skripte erzeugt, die die nötigen
          Umgebungsvariablen definieren.

          Es ist möglich, bestimmte Paketausgaben von diesem
          Wrapping-Prozess auszunehmen, indem Sie eine Liste ihrer Namen
          im Parameter ‘#:qt-wrap-excluded-outputs’ angeben. Das ist
          nützlich, wenn man von einer Ausgabe weiß, dass sie keine
          Qt-Binärdateien enthält, und diese Ausgabe durch das Wrappen
          ohne Not eine weitere Abhängigkeit von Qt, KDE oder Ähnlichem
          bekäme.

          Diese Phase wird nach der ‘install’-Phase hinzugefügt.

 -- Scheme-Variable: r-build-system
     Diese Variable wird vom Modul ‘(guix build-system r)’ exportiert.
     Sie entspricht einer Implementierung der durch R-Pakete
     (https://r-project.org) genutzten Erstellungsprozedur, die wenig
     mehr tut, als ‘R CMD INSTALL --library=/gnu/store/…’ in einer
     Umgebung auszuführen, in der die Umgebungsvariable ‘R_LIBS_SITE’
     die Pfade aller R-Pakete unter den Paketeingaben enthält. Tests
     werden nach der Installation mit der R-Funktion
     ‘tools::testInstalledPackage’ ausgeführt.

 -- Scheme-Variable: rakudo-build-system
     Diese Variable wird vom Modul ‘(guix build-system rakudo)’
     exportiert. Sie implementiert die Erstellungsprozedur, die von
     Rakudo (https://rakudo.org/) für Perl6-Pakete (https://perl6.org/)
     benutzt wird. Pakete werden ins Verzeichnis
     ‘/gnu/store/…/NAME-VERSION/share/perl6’ abgelegt und Binärdateien,
     Bibliotheksdateien und Ressourcen werden installiert, zudem werden
     die Dateien im Verzeichnis ‘bin/’ in Wrapper-Skripte verpackt.
     Tests können übersprungen werden, indem man ‘#f’ im Parameter
     ‘tests?’ übergibt.

     Welches rakudo-Paket benutzt werden soll, kann mit dem Parameter
     ‘rakudo’ angegeben werden. Das perl6-tap-harness-Paket, das für die
     Tests benutzt wird, kann mit ‘#:prove6’ ausgewählt werden; es kann
     auch entfernt werden, indem man ‘#f’ für den Parameter
     ‘with-prove6?’ übergibt. Welches perl6-zef-Paket für Tests und
     Installation verwendet wird, kann mit dem Parameter ‘#:zef’
     angegeben werden; es kann auch entfernt werden, indem man ‘#f’ für
     den Parameter ‘with-zef?’ übergibt.

 -- Scheme-Variable: texlive-build-system
     Diese Variable wird vom Modul ‘(guix build-system texlive)’
     exportiert. Mit ihr werden TeX-Pakete in Stapelverarbeitung („batch
     mode“) mit der angegebenen Engine erstellt. Das Erstellungssystem
     setzt die Variable ‘TEXINPUTS’ so, dass alle TeX-Quelldateien unter
     den Eingaben gefunden werden können.

     Standardmäßig wird ‘luatex’ auf allen Dateien mit der Dateiendung
     ‘ins’ ausgeführt. Eine andere Engine oder ein anderes Format kann
     mit dem Argument ‘#:tex-format’ angegeben werden. Verschiedene
     Erstellungsziele können mit dem Argument ‘#:build-targets’
     festgelegt werden, das eine Liste von Dateinamen erwartet. Das
     Erstellungssystem fügt nur ‘texlive-bin’ und ‘texlive-latex-base’
     zu den Eingaben hinzu (beide kommen aus dem Modul ‘(gnu packages
     tex’). Für beide kann das zu benutzende Paket jeweils mit den
     Argumenten ‘#:texlive-bin’ oder ‘#:texlive-latex-base’ geändert
     werden.

     Der Parameter ‘#:tex-directory’ sagt dem Erstellungssystem, wohin
     die installierten Dateien im texmf-Verzeichnisbaum installiert
     werden sollen.

 -- Scheme-Variable: ruby-build-system
     Diese Variable wird vom Modul ‘(guix build-system ruby)’
     exportiert. Sie steht für eine Implementierung der
     RubyGems-Erstellungsprozedur, die für Ruby-Pakete benutzt wird,
     wobei ‘gem build’ gefolgt von ‘gem install’ ausgeführt wird.

     Das ‘source’-Feld eines Pakets, das dieses Erstellungssystem
     benutzt, verweist typischerweise auf ein Gem-Archiv, weil
     Ruby-Entwickler dieses Format benutzen, wenn sie ihre Software
     veröffentlichen. Das Erstellungssystem entpackt das Gem-Archiv,
     spielt eventuell Patches für den Quellcode ein, führt die Tests
     aus, verpackt alles wieder in ein Gem-Archiv und installiert
     dieses. Neben Gem-Archiven darf das Feld auch auf Verzeichnisse und
     Tarballs verweisen, damit es auch möglich ist, unveröffentlichte
     Gems aus einem Git-Repository oder traditionelle
     Quellcode-Veröffentlichungen zu benutzen.

     Welches Ruby-Paket benutzt werden soll, kann mit dem Parameter
     ‘#:ruby’ festgelegt werden. Eine Liste zusätzlicher
     Befehlszeilenoptionen für den Aufruf des ‘gem’-Befehls kann mit dem
     Parameter ‘#:gem-flags’ angegeben werden.

 -- Scheme-Variable: waf-build-system
     Diese Variable wird durch das Modul ‘(guix build-system waf)’
     exportiert. Damit ist eine Erstellungsprozedur rund um das
     ‘waf’-Skript implementiert. Die üblichen Phasen — ‘configure’,
     ‘build’ und ‘install’ — sind implementiert, indem deren Namen als
     Argumente an das ‘waf’-Skript übergeben werden.

     Das ‘waf’-Skript wird vom Python-Interpetierer ausgeführt. Mit
     welchem Python-Paket das Skript ausgeführt werden soll, kann mit
     dem Parameter ‘#:python’ angegeben werden.

 -- Scheme-Variable: scons-build-system
     Diese Variable wird vom Modul ‘(guix build-system scons)’
     exportiert. Sie steht für eine Implementierung der
     Erstellungsprozedur, die das SCons-Softwarekonstruktionswerkzeug
     („software construction tool“) benutzt. Das Erstellungssystem führt
     ‘scons’ aus, um das Paket zu erstellen, führt mit ‘scons test’
     Tests aus und benutzt ‘scons install’, um das Paket zu
     installieren.

     Zusätzliche Optionen, die an ‘scons’ übergeben werden sollen,
     können mit dem Parameter ‘#:scons-flags’ angegeben werden. Die
     voreingestellten Erstellungs- und Installationsziele können jeweils
     durch ‘#:build-targets’ und ‘#:install-targets’ ersetzt werden. Die
     Python-Version, die benutzt werden soll, um SCons auszuführen, kann
     festgelegt werden, indem das passende SCons-Paket mit dem Parameter
     ‘#:scons’ ausgewählt wird.

 -- Scheme-Variable: haskell-build-system
     Diese Variable wird vom Modul ‘(guix build-system haskell)’
     exportiert. Sie bietet Zugang zur Cabal-Erstellungsprozedur, die
     von Haskell-Paketen benutzt wird, was bedeutet, ‘runhaskell
     Setup.hs configure --prefix=/gnu/store/…’ und ‘runhaskell Setup.hs
     build’ auszuführen. Statt das Paket mit dem Befehl ‘runhaskell
     Setup.hs install’ zu installieren, benutzt das Erstellungssystem
     ‘runhaskell Setup.hs copy’ gefolgt von ‘runhaskell Setup.hs
     register’, um keine Bibliotheken im Store-Verzeichnis des Compilers
     zu speichern, auf dem keine Schreibberechtigung besteht. Zusätzlich
     generiert das Erstellungssystem Dokumentation durch Ausführen von
     ‘runhaskell Setup.hs haddock’, außer ‘#:haddock? #f’ wurde
     übergeben. Optional können an Haddock Parameter mit Hilfe des
     Parameters ‘#:haddock-flags’ übergeben werden. Wird die Datei
     ‘Setup.hs’ nicht gefunden, sucht das Erstellungssystem stattdessen
     nach ‘Setup.lhs’.

     Welcher Haskell-Compiler benutzt werden soll, kann über den
     ‘#:haskell’-Parameter angegeben werden. Als Vorgabewert verwendet
     er ‘ghc’.

 -- Scheme-Variable: dub-build-system
     Diese Variable wird vom Modul ‘(guix build-system dub)’ exportiert.
     Sie verweist auf eine Implementierung des Dub-Erstellungssystems,
     das von D-Paketen benutzt wird. Dabei werden ‘dub build’ und ‘dub
     run’ ausgeführt. Die Installation wird durch manuelles Kopieren der
     Dateien durchgeführt.

     Welcher D-Compiler benutzt wird, kann mit dem Parameter ‘#:ldc’
     festgelegt werden, was als Vorgabewert ‘ldc’ benutzt.

 -- Scheme-Variable: emacs-build-system
     Diese Variable wird vom Modul ‘(guix build-system emacs)’
     exportiert. Darin wird eine Installationsprozedur ähnlich der des
     Paketsystems von Emacs selbst implementiert (siehe *note
     (emacs)Packages::).

     Zunächst wird eine Datei ‘Paket-autoloads.el’ erzeugt, dann werden
     alle Emacs-Lisp-Dateien zu Bytecode kompiliert. Anders als beim
     Emacs-Paketsystem werden die Info-Dokumentationsdateien in das
     Standardverzeichnis für Dokumentation verschoben und die Datei
     ‘dir’ gelöscht. Die Dateien des Elisp-Pakets werden direkt in
     ‘share/emacs/site-lisp’ installiert.

 -- Scheme-Variable: font-build-system
     Diese Variable wird vom Modul ‘(guix build-system font)’
     exportiert. Mit ihr steht eine Installationsprozedur für
     Schriftarten-Pakete zur Verfügung für vom Anbieter vorkompilierte
     TrueType-, OpenType- und andere Schriftartendateien, die nur an die
     richtige Stelle kopiert werden müssen. Dieses Erstellungssystem
     kopiert die Schriftartendateien an den Konventionen folgende Orte
     im Ausgabeverzeichnis.

 -- Scheme-Variable: meson-build-system
     Diese Variable wird vom Modul ‘(guix build-system meson)’
     exportiert. Sie enthält die Erstellungsprozedur für Pakete, die
     Meson (https://mesonbuild.com) als ihr Erstellungssystem benutzen.

     Mit ihr werden sowohl Meson als auch Ninja
     (https://ninja-build.org/) zur Menge der Eingaben hinzugefügt; die
     Pakete dafür können mit den Parametern ‘#:meson’ und ‘#:ninja’
     geändert werden, wenn nötig. Das vorgegebene Meson-Paket ist
     ‘meson-for-build’, ein besonderes Paket, dessen Besonderheit darin
     besteht, den ‘RUNPATH’ von Binärdateien und Bibliotheken _nicht_ zu
     entfernen, wenn sie installiert werden.

     Dieses Erstellungssystem ist eine Erweiterung für das
     ‘gnu-build-system’, aber mit Änderungen an den folgenden Phasen,
     die Meson-spezifisch sind:

     ‘configure’
          Diese Phase führt den ‘meson’-Befehl mit den in
          ‘#:configure-flags’ angegebenen Befehlszeilenoptionen aus. Die
          Befehlszeilenoption ‘--build-type’ wird immer auf ‘plain’
          gesetzt, solange nichts anderes mit dem Parameter
          ‘#:build-type’ angegeben wurde.

     ‘build’
          Diese Phase ruft ‘ninja’ auf, um das Paket standardmäßig
          parallel zu erstellen. Die Vorgabeeinstellung, dass parallel
          erstellt wird, kann verändert werden durch Setzen von
          ‘#:parallel-build?’.

     ‘check’
          Diese Phase führt ‘ninja’ mit dem als ‘#:test-target’
          spezifizierten Ziel für Tests auf, der Vorgabewert ist das
          Ziel namens ‘"test"’.

     ‘install’
          Diese Phase führt ‘ninja install’ aus und kann nicht verändert
          werden.

     Dazu fügt das Erstellungssystem noch folgende neue Phasen:

     ‘fix-runpath’
          In dieser Phase wird sichergestellt, dass alle Binärdateien
          die von ihnen benötigten Bibliotheken finden können. Die
          benötigten Bibliotheken werden in den Unterverzeichnissen des
          Pakets, das erstellt wird, gesucht, und zum ‘RUNPATH’
          hinzugefügt, wann immer es nötig ist. Auch werden diejenigen
          Referenzen zu Bibliotheken aus der Erstellungsphase wieder
          entfernt, die bei ‘meson-for-build’ hinzugefügt wurden, aber
          eigentlich zur Laufzeit nicht gebraucht werden, wie
          Abhängigkeiten nur für Tests.

     ‘glib-or-gtk-wrap’
          Diese Phase ist dieselbe, die auch im
          ‘glib-or-gtk-build-system’ zur Verfügung gestellt wird, und
          mit Vorgabeeinstellungen wird sie nicht durchlaufen. Wenn sie
          gebraucht wird, kann sie mit dem Parameter ‘#:glib-or-gtk?’
          aktiviert werden.

     ‘glib-or-gtk-compile-schemas’
          Diese Phase ist dieselbe, die auch im
          ‘glib-or-gtk-build-system’ zur Verfügung gestellt wird, und
          mit Vorgabeeinstellungen wird sie nicht durchlaufen. Wenn sie
          gebraucht wird, kann sie mit dem Parameter ‘#:glib-or-gtk?’
          aktiviert werden.

 -- Scheme-Variable: linux-module-build-system
     Mit ‘linux-module-build-system’ können Linux-Kernelmodule erstellt
     werden.

     Dieses Erstellungssystem ist eine Erweiterung des
     ‘gnu-build-system’, bei der aber die folgenden Phasen geändert
     wurden:

     ‘configure’
          Diese Phase konfiguriert die Umgebung so, dass das externe
          Kernel-Modul durch das Makefile des Linux-Kernels erstellt
          werden kann.

     ‘build’
          Diese Phase benutzt das Makefile des Linux-Kernels, um das
          externe Kernel-Modul zu erstellen.

     ‘install’
          Diese Phase benutzt das Makefile des Linux-Kernels zur
          Installation des externen Kernel-Moduls.

     Es ist möglich und hilfreich, den für die Erstellung des Moduls zu
     benutzenden Linux-Kernel anzugeben (in der „arguments“-Form eines
     Pakets, dass das linux-module-build-system als Erstellungssystem
     benutzt, wird dazu der Schlüssel #:linux benutzt).

 -- Scheme-Variable: node-build-system
     Diese Variable wird vom Modul ‘(guix build-system node)’
     exportiert. Sie stellt eine Implementierung der Erstellungsprozedur
     von Node.js (https://nodejs.org) dar, die annäherungsweise der
     Funktion des Befehls ‘npm install’ gefolgt vom Befehl ‘npm test’
     entspricht.

     Welches Node.js-Paket zur Interpretation der ‘npm’-Befehle benutzt
     wird, kann mit dem Parameter ‘#:node’ angegeben werden. Dessen
     Vorgabewert ist ‘node’.

   Letztlich gibt es für die Pakete, die bei weitem nichts so komplexes
brauchen, ein „triviales“ Erstellungssystem. Es ist in dem Sinn trivial,
dass es praktisch keine Hilfestellungen gibt: Es fügt keine impliziten
Eingaben hinzu und hat kein Konzept von Erstellungsphasen.

 -- Scheme-Variable: trivial-build-system
     Diese Variable wird vom Modul ‘(guix build-system trivial)’
     exportiert.

     Diesem Erstellungssystem muss im Argument ‘#:builder’ ein
     Scheme-Ausdruck übergeben werden, der die Paketausgabe(n) erstellt
     — wie bei ‘build-expression->derivation’ (siehe *note
     ‘build-expression->derivation’: Ableitungen.).

   ---------- Footnotes ----------

   (1) Bitte schauen Sie in den Modulen unter ‘(guix build
gnu-build-system)’, wenn Sie mehr Details zu Erstellungsphasen brauchen.

